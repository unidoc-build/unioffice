//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this source code is governed by the terms of the Affero GNU General
// Public License version 3.0 as published by the Free Software Foundation and
// appearing in the file LICENSE included in the packaging of this file. A
// commercial license can be purchased on https://unidoc.io.
package spreadsheet ;import (_caaa "archive/zip";_facb "errors";_cgg "flag";_ddb "fmt";_cbb "github.com/unidoc/unioffice";_ccfb "github.com/unidoc/unioffice/chart";_gacd "github.com/unidoc/unioffice/color";_acgc "github.com/unidoc/unioffice/common";_cdbg "github.com/unidoc/unioffice/common/license";_gebcd "github.com/unidoc/unioffice/measurement";_cgb "github.com/unidoc/unioffice/schema/soo/dml";_acd "github.com/unidoc/unioffice/schema/soo/dml/chart";_ebgb "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_bcabf "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_ecbba "github.com/unidoc/unioffice/schema/soo/sml";_bcecg "github.com/unidoc/unioffice/spreadsheet/format";_cfeg "github.com/unidoc/unioffice/spreadsheet/formula";_cddgb "github.com/unidoc/unioffice/spreadsheet/reference";_cfa "github.com/unidoc/unioffice/spreadsheet/update";_gffd "github.com/unidoc/unioffice/vmldrawing";_ffe "github.com/unidoc/unioffice/zippkg";_bcaa "image";_cacf "image/jpeg";_ddeed "io";_fgc "io/ioutil";_febd "log";_gaef "math";_facf "math/big";_abe "os";_cgac "path/filepath";_gfba "regexp";_gdbb "runtime";_cafdc "sort";_feff "strconv";_eggdf "strings";_dbf "time";);

// Fonts returns the list of fonts defined in the stylesheet.
func (_dccg StyleSheet )Fonts ()[]Font {_cddg :=[]Font {};for _ ,_dfecd :=range _dccg ._cag .Fonts .Font {_cddg =append (_cddg ,Font {_dfecd ,_dccg ._cag });};return _cddg ;};

// ClearAutoFilter removes the autofilters from the sheet.
func (_fbc *Sheet )ClearAutoFilter (){_fbc ._eba .AutoFilter =nil ;_bdda :="\u0027"+_fbc .Name ()+"\u0027\u0021";for _ ,_bffg :=range _fbc ._dg .DefinedNames (){if _bffg .Name ()==_dgba {if _eggdf .HasPrefix (_bffg .Content (),_bdda ){_fbc ._dg .RemoveDefinedName (_bffg );break ;};};};};

// GetFilename returns the filename of the context's workbook.
func (_cgag *evalContext )GetFilename ()string {return _cgag ._bada ._dg .GetFilename ()};

// X returns the inner wrapped XML type.
func (_bfca SheetProtection )X ()*_ecbba .CT_SheetProtection {return _bfca ._cgfa };

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_agd CellStyle )SetNumberFormatStandard (s StandardFormat ){_agd ._cbc .NumFmtIdAttr =_cbb .Uint32 (uint32 (s ));_agd ._cbc .ApplyNumberFormatAttr =_cbb .Bool (true );};

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_fbfff Cell )SetStyleIndex (idx uint32 ){_fbfff ._aeb .SAttr =_cbb .Uint32 (idx )};func (_agfa DataValidationCompare )SetValue2 (v string ){_agfa ._fffc .Formula2 =&v };

// X returns the inner wrapped XML type.
func (_eca Drawing )X ()*_ebgb .WsDr {return _eca ._aaba };const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_face *_ecbba .CT_Rst };

// Name returns the name of the defined name.
func (_edgd DefinedName )Name ()string {return _edgd ._affa .NameAttr };

// Cell is a single cell within a sheet.
type Cell struct{_dcd *Workbook ;_aefa *Sheet ;_gcf *_ecbba .CT_Row ;_aeb *_ecbba .CT_Cell ;};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_fcdc Border )InitializeDefaults (){_fcdc ._gcac .Left =_ecbba .NewCT_BorderPr ();_fcdc ._gcac .Bottom =_ecbba .NewCT_BorderPr ();_fcdc ._gcac .Right =_ecbba .NewCT_BorderPr ();_fcdc ._gcac .Top =_ecbba .NewCT_BorderPr ();_fcdc ._gcac .Diagonal =_ecbba .NewCT_BorderPr ();};func (_gad *Sheet )updateAfterRemove (_ecffe uint32 ,_ebab _cfa .UpdateAction )error {_fegb :=_gad .Name ();_fd :=&_cfa .UpdateQuery {UpdateType :_ebab ,ColumnIdx :_ecffe ,SheetToUpdate :_fegb };for _ ,_edfb :=range _gad ._dg .Sheets (){_fd .UpdateCurrentSheet =_fegb ==_edfb .Name ();for _ ,_cdfa :=range _edfb .Rows (){for _ ,_faa :=range _cdfa .Cells (){if _faa .X ().F !=nil {_bf :=_faa .X ().F .Content ;_bdfd :=_cfeg .ParseString (_bf );if _bdfd ==nil {_faa .SetError ("\u0023\u0052\u0045F\u0021");}else {_bffa :=_bdfd .Update (_fd );_faa .X ().F .Content =_ddb .Sprintf ("\u003d\u0025\u0073",_bffa .String ());};};};};};return nil ;};

// GetLocked returns true if the cell is locked.
func (_cae *evalContext )GetLocked (cellRef string )bool {return _cae ._bada .Cell (cellRef ).getLocked ()};

// SetRow set the row of the cell marker.
func (_acaf CellMarker )SetRow (row int32 ){_acaf ._ecdbe .Row =row };

// SetHeightAuto sets the row height to be automatically determined.
func (_dedc Row )SetHeightAuto (){_dedc ._eaeb .HtAttr =nil ;_dedc ._eaeb .CustomHeightAttr =nil };

// SetStyle applies a style to the cell.  This style is referenced in the
// generated XML via CellStyle.Index().
func (_ggbe Cell )SetStyle (cs CellStyle ){_ggbe .SetStyleIndex (cs .Index ())};

// DefinedNames returns a slice of all defined names in the workbook.
func (_dgde *Workbook )DefinedNames ()[]DefinedName {if _dgde ._bcf .DefinedNames ==nil {return nil ;};_agcd :=[]DefinedName {};for _ ,_dd :=range _dgde ._bcf .DefinedNames .DefinedName {_agcd =append (_agcd ,DefinedName {_dd });};return _agcd ;};

// BottomRight is a no-op.
func (_bdfb AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};func (_dadbd CellStyle )SetShrinkToFit (b bool ){if _dadbd ._cbc .Alignment ==nil {_dadbd ._cbc .Alignment =_ecbba .NewCT_CellAlignment ();};_dadbd ._cbc .ApplyAlignmentAttr =_cbb .Bool (true );if !b {_dadbd ._cbc .Alignment .ShrinkToFitAttr =nil ;}else {_dadbd ._cbc .Alignment .ShrinkToFitAttr =_cbb .Bool (b );};};

// IsError returns true if the cell is an error type cell.
func (_geff Cell )IsError ()bool {return _geff ._aeb .TAttr ==_ecbba .ST_CellTypeE };

// Column returns the cell column
func (_bagc Cell )Column ()(string ,error ){_dbcd ,_aeba :=_cddgb .ParseCellReference (_bagc .Reference ());if _aeba !=nil {return "",_aeba ;};return _dbcd .Column ,nil ;};

// LockSheet controls the locking of the sheet.
func (_dfae SheetProtection )LockSheet (b bool ){if !b {_dfae ._cgfa .SheetAttr =nil ;}else {_dfae ._cgfa .SheetAttr =_cbb .Bool (true );};};func _bdce (_ggfe *Workbook ){_ggfe .Close ()};func (_gage *evalContext )NamedRange (ref string )_cfeg .Reference {for _ ,_fdc :=range _gage ._bada ._dg .DefinedNames (){if _fdc .Name ()==ref {return _cfeg .MakeRangeReference (_fdc .Content ());};};for _ ,_gaed :=range _gage ._bada ._dg .Tables (){if _gaed .Name ()==ref {return _cfeg .MakeRangeReference (_ddb .Sprintf ("\u0025\u0073\u0021%\u0073",_gage ._bada .Name (),_gaed .Reference ()));};};return _cfeg .ReferenceInvalid ;};

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_ebfd *_ecbba .CT_ConditionalFormatting ;};func (_gdfd *Sheet )setShared (_ggba string ,_cfdg ,_fcf _cddgb .CellReference ,_fecdf string ){_aec :=_gdfd .FormulaContext ();_dabd :=_cfeg .NewEvaluator ();for _gaeg :=_cfdg .RowIdx ;_gaeg <=_fcf .RowIdx ;_gaeg ++{for _bdaf :=_cfdg .ColumnIdx ;_bdaf <=_fcf .ColumnIdx ;_bdaf ++{_eaed :=_gaeg -_cfdg .RowIdx ;_ebge :=_bdaf -_cfdg .ColumnIdx ;_aec .SetOffset (_ebge ,_eaed );_dcfc :=_dabd .Eval (_aec ,_fecdf );_bc :=_ddb .Sprintf ("\u0025\u0073\u0025\u0064",_cddgb .IndexToColumn (_bdaf ),_gaeg );_abgb :=_gdfd .Cell (_bc );if _dcfc .Type ==_cfeg .ResultTypeNumber {_abgb .X ().TAttr =_ecbba .ST_CellTypeN ;}else {_abgb .X ().TAttr =_ecbba .ST_CellTypeInlineStr ;};_abgb .X ().V =_cbb .String (_dcfc .Value ());};};_ =_dabd ;_ =_aec ;};

// X returns the inner wrapped XML type.
func (_gef DifferentialStyle )X ()*_ecbba .CT_Dxf {return _gef ._bea };

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_eafc *Workbook )SetActiveSheet (s Sheet ){for _cbg ,_gbbc :=range _eafc ._fccf {if s ._eba ==_gbbc {_eafc .SetActiveSheetIndex (uint32 (_cbg ));};};};

// IsSheetLocked returns whether the sheet is locked.
func (_gebca SheetProtection )IsSheetLocked ()bool {return _gebca ._cgfa .SheetAttr !=nil &&*_gebca ._cgfa .SheetAttr ;};

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_dab ConditionalFormattingRule )SetColorScale ()ColorScale {_dab .clear ();_dab .SetType (_ecbba .ST_CfTypeColorScale );_dab ._gacg .ColorScale =_ecbba .NewCT_ColorScale ();return ColorScale {_dab ._gacg .ColorScale };};

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_fadab *Workbook )Close ()error {if _fadab .TmpPath !=""&&_eggdf .HasPrefix (_fadab .TmpPath ,_abe .TempDir ()){return _abe .RemoveAll (_fadab .TmpPath );};return nil ;};func (_gebf Border )SetTop (style _ecbba .ST_BorderStyle ,c _gacd .Color ){if _gebf ._gcac .Top ==nil {_gebf ._gcac .Top =_ecbba .NewCT_BorderPr ();};_gebf ._gcac .Top .Color =_ecbba .NewCT_Color ();_gebf ._gcac .Top .Color .RgbAttr =c .AsRGBAString ();_gebf ._gcac .Top .StyleAttr =style ;};

// LockObject controls the locking of the sheet objects.
func (_cgfg SheetProtection )LockObject (b bool ){if !b {_cgfg ._cgfa .ObjectsAttr =nil ;}else {_cgfg ._cgfa .ObjectsAttr =_cbb .Bool (true );};};

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_agf ConditionalFormattingRule )SetDataBar ()DataBarScale {_agf .clear ();_agf .SetType (_ecbba .ST_CfTypeDataBar );_agf ._gacg .DataBar =_ecbba .NewCT_DataBar ();_cdbe :=DataBarScale {_agf ._gacg .DataBar };_cdbe .SetShowValue (true );_cdbe .SetMinLength (10);_cdbe .SetMaxLength (90);return _cdbe ;};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_cdg *_ebgb .CT_AbsoluteAnchor };

// Wrapped returns true if the cell will wrap text.
func (_dgfe CellStyle )Wrapped ()bool {if _dgfe ._cbc .Alignment ==nil {return false ;};if _dgfe ._cbc .Alignment .WrapTextAttr ==nil {return false ;};return *_dgfe ._cbc .Alignment .WrapTextAttr ;};

// HasFormula returns true if the cell contains formula.
func (_edbdb *evalContext )HasFormula (cellRef string )bool {return _edbdb ._bada .Cell (cellRef ).HasFormula ();};

// AddHyperlink creates and sets a hyperlink on a cell.
func (_ggfa Cell )AddHyperlink (url string ){for _ageg ,_bbaa :=range _ggfa ._dcd ._fccf {if _bbaa ==_ggfa ._aefa ._eba {_ggfa .SetHyperlink (_ggfa ._dcd ._ecff [_ageg ].AddHyperlink (url ));return ;};};};

// CellStyle is a formatting style for a cell.  CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_gfeb *Workbook ;_cbc *_ecbba .CT_Xf ;_b *_ecbba .CT_CellXfs ;};

// StandardFormat is a standard ECMA 376 number format.
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);var _egg =_cbb .RelativeFilename (_cbb .DocTypeSpreadsheet ,_cbb .OfficeDocumentType ,_cbb .SharedStringsType ,0);

// IsDBCS returns if a workbook's default language is among DBCS.
func (_bg *evalContext )IsDBCS ()bool {_fed :=_bg ._bada ._dg .CoreProperties .X ().Language ;if _fed ==nil {return false ;};_ccceg :=string (_fed .Data );for _ ,_ccca :=range _egcd {if _ccceg ==_ccca {return true ;};};return false ;};

// SetPattern sets the pattern of the fill.
func (_gcd PatternFill )SetPattern (p _ecbba .ST_PatternType ){_gcd ._afdb .PatternTypeAttr =p };

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_ecdd Comments )AddComment (cellRef string ,author string )RichText {_dbgg :=_ecbba .NewCT_Comment ();_ecdd ._agfd .CommentList .Comment =append (_ecdd ._agfd .CommentList .Comment ,_dbgg );_dbgg .RefAttr =cellRef ;_dbgg .AuthorIdAttr =_ecdd .getOrCreateAuthor (author );_dbgg .Text =_ecbba .NewCT_Rst ();return RichText {_dbgg .Text };};

// Reference returns the table reference (the cells within the table)
func (_eegdg Table )Reference ()string {return _eegdg ._ggd .RefAttr };

// AddMergedCells merges cells within a sheet.
func (_egcb *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _egcb ._eba .MergeCells ==nil {_egcb ._eba .MergeCells =_ecbba .NewCT_MergeCells ();};_egbc :=_ecbba .NewCT_MergeCell ();_egbc .RefAttr =_ddb .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );_egcb ._eba .MergeCells .MergeCell =append (_egcb ._eba .MergeCells .MergeCell ,_egbc );_egcb ._eba .MergeCells .CountAttr =_cbb .Uint32 (uint32 (len (_egcb ._eba .MergeCells .MergeCell )));return MergedCell {_egcb ._dg ,_egcb ,_egbc };};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_bbd Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _gcgga ,_fbcb Cell ;for _ ,_aaff :=range lhs .Cells (){_dbcb ,_ :=_cddgb .ParseCellReference (_aaff .Reference ());if _dbcb .Column ==column {_gcgga =_aaff ;break ;};};for _ ,_caf :=range rhs .Cells (){_dcdca ,_ :=_cddgb .ParseCellReference (_caf .Reference ());if _dcdca .Column ==column {_fbcb =_caf ;break ;};};return _bbd .LessCells (_gcgga ,_fbcb );};

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_fgfc Cell )SetTime (d _dbf .Time ){_fgfc .clearValue ();d =_befb (d );_efd :=_fgfc ._dcd .Epoch ();if d .Before (_efd ){_cbb .Log ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_beda :=d .Sub (_efd );_dfac :=new (_facf .Float );_abee :=new (_facf .Float );_abee .SetPrec (128);_abee .SetUint64 (uint64 (_beda ));_adgc :=new (_facf .Float );_adgc .SetUint64 (24*60*60*1e9);_dfac .Quo (_abee ,_adgc );_fgfc ._aeb .V =_cbb .String (_dfac .Text ('g',20));};

// X returns the inner wrapped XML type.
func (_ega ConditionalFormatting )X ()*_ecbba .CT_ConditionalFormatting {return _ega ._ebfd };

// Comments returns the list of comments for this sheet
func (_gbb Comments )Comments ()[]Comment {_cdaaf :=[]Comment {};for _ ,_ga :=range _gbb ._agfd .CommentList .Comment {_cdaaf =append (_cdaaf ,Comment {_gbb ._ecgc ,_ga ,_gbb ._agfd });};return _cdaaf ;};

// MoveTo repositions the anchor without changing the objects size.
func (_egca TwoCellAnchor )MoveTo (col ,row int32 ){_gedc :=_egca .TopLeft ();_aaab :=_egca .BottomRight ();_debf :=_aaab .Col ()-_gedc .Col ();_aebe :=_aaab .Row ()-_gedc .Row ();_gedc .SetCol (col );_gedc .SetRow (row );_aaab .SetCol (col +_debf );_aaab .SetRow (row +_aebe );};

// SetReference sets the regin of cells that the merged cell applies to.
func (_aedb MergedCell )SetReference (ref string ){_aedb ._bb .RefAttr =ref };func (_fab ConditionalFormattingRule )clear (){_fab ._gacg .OperatorAttr =_ecbba .ST_ConditionalFormattingOperatorUnset ;_fab ._gacg .ColorScale =nil ;_fab ._gacg .IconSet =nil ;_fab ._gacg .Formula =nil ;};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_ggfc StyleSheet )RemoveFont (f Font )error {for _dgad ,_ccdb :=range _ggfc ._cag .Fonts .Font {if _ccdb ==f .X (){_ggfc ._cag .Fonts .Font =append (_ggfc ._cag .Fonts .Font [:_dgad ],_ggfc ._cag .Fonts .Font [_dgad +1:]...);return nil ;};};return _facb .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_fffc *_ecbba .CT_DataValidation };

// SetRowOffset sets a column offset in absolute distance.
func (_cdae CellMarker )SetRowOffset (m _gebcd .Distance ){_cdae ._ecdbe .RowOff .ST_CoordinateUnqualified =_cbb .Int64 (int64 (m /_gebcd .EMU ));};

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_ecbba .Comments )Comments {return Comments {w ,x }};func (_acca SortOrder )String ()string {if _acca >=SortOrder (len (_gbac )-1){return _ddb .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_acca );};return _dbe [_gbac [_acca ]:_gbac [_acca +1]];};

// Name returns the name of the table
func (_fdab Table )Name ()string {if _fdab ._ggd .NameAttr !=nil {return *_fdab ._ggd .NameAttr ;};return "";};

// IsBool returns true if the cell boolean value.
func (_eecb *evalContext )IsBool (cellRef string )bool {return _eecb ._bada .Cell (cellRef ).IsBool ()};

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_abbg *Sheet )InsertRow (rowNum int )Row {_ebag :=uint32 (rowNum );for _ ,_bdde :=range _abbg .Rows (){if _bdde ._eaeb .RAttr !=nil &&*_bdde ._eaeb .RAttr >=_ebag {*_bdde ._eaeb .RAttr ++;for _ ,_fad :=range _bdde .Cells (){_gda ,_efag :=_cddgb .ParseCellReference (_fad .Reference ());if _efag !=nil {continue ;};_gda .RowIdx ++;_fad ._aeb .RAttr =_cbb .String (_gda .String ());};};};for _ ,_dfde :=range _abbg .MergedCells (){_edg ,_bcaf ,_dcfd :=_cddgb .ParseRangeReference (_dfde .Reference ());if _dcfd !=nil {continue ;};if int (_edg .RowIdx )>=rowNum {_edg .RowIdx ++;};if int (_bcaf .RowIdx )>=rowNum {_bcaf .RowIdx ++;};_aacb :=_ddb .Sprintf ("\u0025\u0073\u003a%\u0073",_edg ,_bcaf );_dfde .SetReference (_aacb );};return _abbg .AddNumberedRow (_ebag );};

// SetText sets the text to be displayed.
func (_cfcc RichTextRun )SetText (s string ){_cfcc ._gdf .T =s };

// AddString adds a string to the shared string cache.
func (_fcdb SharedStrings )AddString (v string )int {if _cgccf ,_gddd :=_fcdb ._acg [v ];_gddd {return _cgccf ;};_bdafg :=_ecbba .NewCT_Rst ();_bdafg .T =_cbb .String (v );_fcdb ._agfe .Si =append (_fcdb ._agfe .Si ,_bdafg );_cff :=len (_fcdb ._agfe .Si )-1;_fcdb ._acg [v ]=_cff ;_fcdb ._agfe .CountAttr =_cbb .Uint32 (uint32 (len (_fcdb ._agfe .Si )));_fcdb ._agfe .UniqueCountAttr =_fcdb ._agfe .CountAttr ;return _cff ;};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_bedg *Workbook )AddDrawing ()Drawing {_beb :=_ebgb .NewWsDr ();_bedg ._ecfd =append (_bedg ._ecfd ,_beb );_fffd :=_cbb .AbsoluteFilename (_cbb .DocTypeSpreadsheet ,_cbb .DrawingType ,len (_bedg ._ecfd ));_bedg .ContentTypes .AddOverride (_fffd ,_cbb .DrawingContentType );_bedg ._agg =append (_bedg ._agg ,_acgc .NewRelationships ());return Drawing {_bedg ,_beb };};func _bbcd ()*_ebgb .CT_OneCellAnchor {_bee :=_ebgb .NewCT_OneCellAnchor ();return _bee };func (_adac Cell )clearValue (){_adac ._aeb .F =nil ;_adac ._aeb .Is =nil ;_adac ._aeb .V =nil ;_adac ._aeb .TAttr =_ecbba .ST_CellTypeUnset ;};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_dceb Sheet )Validate ()error {_gdec :=[]func ()error {_dceb .validateRowCellNumbers ,_dceb .validateMergedCells ,_dceb .validateSheetNames };for _ ,_cfb :=range _gdec {if _bfcc :=_cfb ();_bfcc !=nil {return _bfcc ;};};if _ggcd :=_dceb ._eba .Validate ();_ggcd !=nil {return _ggcd ;};return _dceb ._eba .Validate ();};

// SetWidth controls the width of a column.
func (_fcbg Column )SetWidth (w _gebcd .Distance ){_fcbg ._ccfa .WidthAttr =_cbb .Float64 (float64 (w /_gebcd .Character ));};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_daca Comparer )LessCells (lhs ,rhs Cell )bool {if _daca .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_aged ,_ce :=lhs .getRawSortValue ();_ggcgb ,_decf :=rhs .getRawSortValue ();switch {case _ce &&_decf :_bdba ,_ :=_feff .ParseFloat (_aged ,64);_addd ,_ :=_feff .ParseFloat (_ggcgb ,64);return _bdba < _addd ;case _ce :return true ;case _decf :return false ;};_aged =lhs .GetFormattedValue ();_ggcgb =rhs .GetFormattedValue ();return _aged < _ggcgb ;};func (_aa PatternFill )ClearBgColor (){_aa ._afdb .BgColor =nil };

// Author returns the author of the comment
func (_dadg Comment )Author ()string {if _dadg ._fcccd .AuthorIdAttr < uint32 (len (_dadg ._dgb .Authors .Author )){return _dadg ._dgb .Authors .Author [_dadg ._fcccd .AuthorIdAttr ];};return "";};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_fbd Cell )SetFormulaArray (s string ){_fbd .clearValue ();_fbd ._aeb .TAttr =_ecbba .ST_CellTypeStr ;_fbd ._aeb .F =_ecbba .NewCT_CellFormula ();_fbd ._aeb .F .TAttr =_ecbba .ST_CellFormulaTypeArray ;_fbd ._aeb .F .Content =s ;};

// SetColOffset sets the column offset of the top-left anchor.
func (_ffg OneCellAnchor )SetColOffset (m _gebcd .Distance ){_ffg .TopLeft ().SetColOffset (m )};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_bede *Sheet )SetBorder (cellRange string ,border Border )error {_gfc ,_geba ,_eaga :=_cddgb .ParseRangeReference (cellRange );if _eaga !=nil {return _eaga ;};_befe :=_bede ._dg .StyleSheet .AddCellStyle ();_gcea :=_bede ._dg .StyleSheet .AddBorder ();_befe .SetBorder (_gcea );_gcea ._gcac .Top =border ._gcac .Top ;_gcea ._gcac .Left =border ._gcac .Left ;_fcfd :=_bede ._dg .StyleSheet .AddCellStyle ();_fde :=_bede ._dg .StyleSheet .AddBorder ();_fcfd .SetBorder (_fde );_fde ._gcac .Top =border ._gcac .Top ;_fde ._gcac .Right =border ._gcac .Right ;_fee :=_bede ._dg .StyleSheet .AddCellStyle ();_dggc :=_bede ._dg .StyleSheet .AddBorder ();_fee .SetBorder (_dggc );_dggc ._gcac .Top =border ._gcac .Top ;_ddbeb :=_bede ._dg .StyleSheet .AddCellStyle ();_gcfb :=_bede ._dg .StyleSheet .AddBorder ();_ddbeb .SetBorder (_gcfb );_gcfb ._gcac .Left =border ._gcac .Left ;_gcgg :=_bede ._dg .StyleSheet .AddCellStyle ();_fedf :=_bede ._dg .StyleSheet .AddBorder ();_gcgg .SetBorder (_fedf );_fedf ._gcac .Right =border ._gcac .Right ;_efggb :=_bede ._dg .StyleSheet .AddCellStyle ();_cffb :=_bede ._dg .StyleSheet .AddBorder ();_efggb .SetBorder (_cffb );_cffb ._gcac .Bottom =border ._gcac .Bottom ;_aadf :=_bede ._dg .StyleSheet .AddCellStyle ();_gee :=_bede ._dg .StyleSheet .AddBorder ();_aadf .SetBorder (_gee );_gee ._gcac .Bottom =border ._gcac .Bottom ;_gee ._gcac .Left =border ._gcac .Left ;_cga :=_bede ._dg .StyleSheet .AddCellStyle ();_bfa :=_bede ._dg .StyleSheet .AddBorder ();_cga .SetBorder (_bfa );_bfa ._gcac .Bottom =border ._gcac .Bottom ;_bfa ._gcac .Right =border ._gcac .Right ;_gac :=_gfc .RowIdx ;_acec :=_gfc .ColumnIdx ;_acf :=_geba .RowIdx ;_bbb :=_geba .ColumnIdx ;for _cfga :=_gac ;_cfga <=_acf ;_cfga ++{for _dbff :=_acec ;_dbff <=_bbb ;_dbff ++{_dagf :=_ddb .Sprintf ("\u0025\u0073\u0025\u0064",_cddgb .IndexToColumn (_dbff ),_cfga );switch {case _cfga ==_gac &&_dbff ==_acec :_bede .Cell (_dagf ).SetStyle (_befe );case _cfga ==_gac &&_dbff ==_bbb :_bede .Cell (_dagf ).SetStyle (_fcfd );case _cfga ==_acf &&_dbff ==_acec :_bede .Cell (_dagf ).SetStyle (_aadf );case _cfga ==_acf &&_dbff ==_bbb :_bede .Cell (_dagf ).SetStyle (_cga );case _cfga ==_gac :_bede .Cell (_dagf ).SetStyle (_fee );case _cfga ==_acf :_bede .Cell (_dagf ).SetStyle (_efggb );case _dbff ==_acec :_bede .Cell (_dagf ).SetStyle (_ddbeb );case _dbff ==_bbb :_bede .Cell (_dagf ).SetStyle (_gcgg );};};};return nil ;};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_fada *Workbook )Epoch ()_dbf .Time {if _fada .Uses1904Dates (){_dbf .Date (1904,1,1,0,0,0,0,_dbf .UTC );};return _dbf .Date (1899,12,30,0,0,0,0,_dbf .UTC );};

// CellMarker represents a cell position
type CellMarker struct{_ecdbe *_ebgb .CT_Marker };func (_edfe Font )SetBold (b bool ){if b {_edfe ._afdbd .B =[]*_ecbba .CT_BooleanProperty {{}};}else {_edfe ._afdbd .B =nil ;};};

// Row is a row within a spreadsheet.
type Row struct{_ggfg *Workbook ;_faag *Sheet ;_eaeb *_ecbba .CT_Row ;};

// SetName sets the sheet name.
func (_afe *Sheet )SetName (name string ){_afe ._aefde .NameAttr =name };func _eefa (_dca bool )int {if _dca {return 1;};return 0;};

// X returns the inner wrapped XML type.
func (_gadg Comments )X ()*_ecbba .Comments {return _gadg ._agfd };

// IsEmpty checks if the cell style contains nothing.
func (_gfce CellStyle )IsEmpty ()bool {return _gfce ._gfeb ==nil ||_gfce ._cbc ==nil ||_gfce ._b ==nil ||_gfce ._b .Xf ==nil ;};

// GetFormula returns the formula for a cell.
func (_adcdd Cell )GetFormula ()string {if _adcdd ._aeb .F !=nil {return _adcdd ._aeb .F .Content ;};return "";};

// IsWindowLocked returns whether the workbook windows are locked.
func (_baca WorkbookProtection )IsWindowLocked ()bool {return _baca ._aab .LockWindowsAttr !=nil &&*_baca ._aab .LockWindowsAttr ;};

// SetFormat sets the number format code.
func (_bgab NumberFormat )SetFormat (f string ){_bgab ._dcff .FormatCodeAttr =f };

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_agfe *_ecbba .Sst ;_acg map[string ]int ;};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_fdcf *Workbook )Save (w _ddeed .Writer )error {if !_cdbg .GetLicenseKey ().IsLicensed ()&&_cgg .Lookup ("\u0074\u0065\u0073\u0074\u002e\u0076")==nil {_ddb .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_ddb .Println ("\u002d\u0020Ge\u0074\u0020\u0061 \u006c\u0069\u0063\u0065nse\u0020on\u0020\u0068\u0074\u0074\u0070\u0073\u003a//\u0075\u006e\u0069\u0064\u006f\u0063\u002ei\u006f");for _ ,_feccg :=range _fdcf .Sheets (){_abad :=_feccg .Row (1);_abad .SetHeight (50);_aed :=_abad .Cell ("\u0041");_ddcc :=_aed .SetRichTextString ();_acfa :=_ddcc .AddRun ();_acfa .SetText ("\u0055\u006e\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0064\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006ff\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065\u0020\u002d\u0020\u0047\u0065\u0074\u0020\u0061\u0020\u006c\u0069c\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a/\u002f\u0075\u006ei\u0064\u006f\u0063\u002e\u0069\u006f");_acfa .SetBold (true );_acfa .SetColor (_gacd .Red );};};_gaeb :=_caaa .NewWriter (w );defer _gaeb .Close ();_fffa :=_cbb .DocTypeSpreadsheet ;if _cdbd :=_ffe .MarshalXML (_gaeb ,_cbb .BaseRelsFilename ,_fdcf .Rels .X ());_cdbd !=nil {return _cdbd ;};if _cbfag :=_ffe .MarshalXMLByType (_gaeb ,_fffa ,_cbb .ExtendedPropertiesType ,_fdcf .AppProperties .X ());_cbfag !=nil {return _cbfag ;};if _bfgf :=_ffe .MarshalXMLByType (_gaeb ,_fffa ,_cbb .CorePropertiesType ,_fdcf .CoreProperties .X ());_bfgf !=nil {return _bfgf ;};_dcdb :=_cbb .AbsoluteFilename (_fffa ,_cbb .OfficeDocumentType ,0);if _edge :=_ffe .MarshalXML (_gaeb ,_dcdb ,_fdcf ._bcf );_edge !=nil {return _edge ;};if _ebf :=_ffe .MarshalXML (_gaeb ,_ffe .RelationsPathFor (_dcdb ),_fdcf ._feed .X ());_ebf !=nil {return _ebf ;};if _fdce :=_ffe .MarshalXMLByType (_gaeb ,_fffa ,_cbb .StylesType ,_fdcf .StyleSheet .X ());_fdce !=nil {return _fdce ;};for _eacba ,_gdd :=range _fdcf ._egeg {if _fdeb :=_ffe .MarshalXMLByTypeIndex (_gaeb ,_fffa ,_cbb .ThemeType ,_eacba +1,_gdd );_fdeb !=nil {return _fdeb ;};};for _fa ,_eggg :=range _fdcf ._fccf {_eggg .Dimension .RefAttr =Sheet {_fdcf ,nil ,_eggg }.Extents ();_ddfb :=_cbb .AbsoluteFilename (_fffa ,_cbb .WorksheetType ,_fa +1);_ffe .MarshalXML (_gaeb ,_ddfb ,_eggg );_ffe .MarshalXML (_gaeb ,_ffe .RelationsPathFor (_ddfb ),_fdcf ._ecff [_fa ].X ());};if _gaebf :=_ffe .MarshalXMLByType (_gaeb ,_fffa ,_cbb .SharedStringsType ,_fdcf .SharedStrings .X ());_gaebf !=nil {return _gaebf ;};if _fdcf .Thumbnail !=nil {_cggd :=_cbb .AbsoluteFilename (_fffa ,_cbb .ThumbnailType ,0);_de ,_ffgg :=_gaeb .Create (_cggd );if _ffgg !=nil {return _ffgg ;};if _dbafd :=_cacf .Encode (_de ,_fdcf .Thumbnail ,nil );_dbafd !=nil {return _dbafd ;};};for _agbdg ,_dc :=range _fdcf ._abbff {_begc :=_cbb .AbsoluteFilename (_fffa ,_cbb .ChartType ,_agbdg +1);_ffe .MarshalXML (_gaeb ,_begc ,_dc );};for _dba ,_bcd :=range _fdcf ._dafa {_agbe :=_cbb .AbsoluteFilename (_fffa ,_cbb .TableType ,_dba +1);_ffe .MarshalXML (_gaeb ,_agbe ,_bcd );};for _ggb ,_aeab :=range _fdcf ._ecfd {_efdbd :=_cbb .AbsoluteFilename (_fffa ,_cbb .DrawingType ,_ggb +1);_ffe .MarshalXML (_gaeb ,_efdbd ,_aeab );if !_fdcf ._agg [_ggb ].IsEmpty (){_ffe .MarshalXML (_gaeb ,_ffe .RelationsPathFor (_efdbd ),_fdcf ._agg [_ggb ].X ());};};for _dcgee ,_accb :=range _fdcf ._cdeg {_ffe .MarshalXML (_gaeb ,_cbb .AbsoluteFilename (_fffa ,_cbb .VMLDrawingType ,_dcgee +1),_accb );};for _gefg ,_cdaaa :=range _fdcf .Images {if _cbbb :=_acgc .AddImageToZip (_gaeb ,_cdaaa ,_gefg +1,_cbb .DocTypeSpreadsheet );_cbbb !=nil {return _cbbb ;};};if _fdgd :=_ffe .MarshalXML (_gaeb ,_cbb .ContentTypesFilename ,_fdcf .ContentTypes .X ());_fdgd !=nil {return _fdgd ;};for _cecb ,_aaf :=range _fdcf ._efb {if _aaf ==nil {continue ;};_ffe .MarshalXML (_gaeb ,_cbb .AbsoluteFilename (_fffa ,_cbb .CommentsType ,_cecb +1),_aaf );};if _acc :=_fdcf .WriteExtraFiles (_gaeb );_acc !=nil {return _acc ;};return _gaeb .Close ();};func (_fefe *evalContext )SetOffset (col ,row uint32 ){_fefe ._ecace =col ;_fefe ._beba =row };

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_bdbc *_ecbba .CT_DataValidation };

// AddView adds a sheet view.
func (_gbff *Sheet )AddView ()SheetView {if _gbff ._eba .SheetViews ==nil {_gbff ._eba .SheetViews =_ecbba .NewCT_SheetViews ();};_ggg :=_ecbba .NewCT_SheetView ();_gbff ._eba .SheetViews .SheetView =append (_gbff ._eba .SheetViews .SheetView ,_ggg );return SheetView {_ggg };};

// PasswordHash returns the hash of the workbook password.
func (_ff WorkbookProtection )PasswordHash ()string {if _ff ._aab .WorkbookPasswordAttr ==nil {return "";};return *_ff ._aab .WorkbookPasswordAttr ;};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_dfa *Sheet )ClearCachedFormulaResults (){for _ ,_faefc :=range _dfa .Rows (){for _ ,_acga :=range _faefc .Cells (){if _acga .X ().F !=nil {_acga .X ().V =nil ;};};};};func (_cbbd *Sheet )removeColumnFromMergedCells (_aaa uint32 )error {if _cbbd ._eba .MergeCells ==nil ||_cbbd ._eba .MergeCells .MergeCell ==nil {return nil ;};_deefc :=[]*_ecbba .CT_MergeCell {};for _ ,_ebb :=range _cbbd .MergedCells (){_ade :=_cefd (_ebb .Reference (),_aaa ,true );if _ade !=""{_ebb .SetReference (_ade );_deefc =append (_deefc ,_ebb .X ());};};_cbbd ._eba .MergeCells .MergeCell =_deefc ;return nil ;};

// IsNumber returns true if the cell is a number type cell.
func (_fddg Cell )IsNumber ()bool {switch _fddg ._aeb .TAttr {case _ecbba .ST_CellTypeN :return true ;case _ecbba .ST_CellTypeS ,_ecbba .ST_CellTypeB :return false ;};return _fddg ._aeb .V !=nil &&_bcecg .IsNumber (*_fddg ._aeb .V );};

// SetShowRuler controls the visibility of the ruler
func (_fgbg SheetView )SetShowRuler (b bool ){if !b {_fgbg ._fca .ShowRulerAttr =_cbb .Bool (false );}else {_fgbg ._fca .ShowRulerAttr =nil ;};};func (_affg Cell )getFormat ()string {if _affg ._aeb .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_abfge :=*_affg ._aeb .SAttr ;_fecd :=_affg ._dcd .StyleSheet .GetCellStyle (_abfge );_gde :=_affg ._dcd .StyleSheet .GetNumberFormat (_fecd .NumberFormat ());return _gde .GetFormat ();};type ConditionalFormattingRule struct{_gacg *_ecbba .CT_CfRule };

// SetWidth sets the width of the anchored object.
func (_bgd OneCellAnchor )SetWidth (w _gebcd .Distance ){_bgd ._egcc .Ext .CxAttr =int64 (w /_gebcd .EMU )};

// New constructs a new workbook.
func New ()*Workbook {_ebbb :=&Workbook {};_ebbb ._bcf =_ecbba .NewWorkbook ();_gdbb .SetFinalizer (_ebbb ,_bdce );_ebbb .AppProperties =_acgc .NewAppProperties ();_ebbb .CoreProperties =_acgc .NewCoreProperties ();_ebbb .StyleSheet =NewStyleSheet (_ebbb );_ebbb .Rels =_acgc .NewRelationships ();_ebbb ._feed =_acgc .NewRelationships ();_ebbb .Rels .AddRelationship (_cbb .RelativeFilename (_cbb .DocTypeSpreadsheet ,"",_cbb .ExtendedPropertiesType ,0),_cbb .ExtendedPropertiesType );_ebbb .Rels .AddRelationship (_cbb .RelativeFilename (_cbb .DocTypeSpreadsheet ,"",_cbb .CorePropertiesType ,0),_cbb .CorePropertiesType );_ebbb .Rels .AddRelationship (_cbb .RelativeFilename (_cbb .DocTypeSpreadsheet ,"",_cbb .OfficeDocumentType ,0),_cbb .OfficeDocumentType );_ebbb ._feed .AddRelationship (_cbb .RelativeFilename (_cbb .DocTypeSpreadsheet ,_cbb .OfficeDocumentType ,_cbb .StylesType ,0),_cbb .StylesType );_ebbb .ContentTypes =_acgc .NewContentTypes ();_ebbb .ContentTypes .AddDefault ("\u0076\u006d\u006c",_cbb .VMLDrawingContentType );_ebbb .ContentTypes .AddOverride (_cbb .AbsoluteFilename (_cbb .DocTypeSpreadsheet ,_cbb .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");_ebbb .ContentTypes .AddOverride (_cbb .AbsoluteFilename (_cbb .DocTypeSpreadsheet ,_cbb .StylesType ,0),_cbb .SMLStyleSheetContentType );_ebbb .SharedStrings =NewSharedStrings ();_ebbb .ContentTypes .AddOverride (_cbb .AbsoluteFilename (_cbb .DocTypeSpreadsheet ,_cbb .SharedStringsType ,0),_cbb .SharedStringsContentType );_ebbb ._feed .AddRelationship (_cbb .RelativeFilename (_cbb .DocTypeSpreadsheet ,_cbb .OfficeDocumentType ,_cbb .SharedStringsType ,0),_cbb .SharedStringsType );return _ebbb ;};

// AddDataValidation adds a data validation rule to a sheet.
func (_afde *Sheet )AddDataValidation ()DataValidation {if _afde ._eba .DataValidations ==nil {_afde ._eba .DataValidations =_ecbba .NewCT_DataValidations ();};_cd :=_ecbba .NewCT_DataValidation ();_cd .ShowErrorMessageAttr =_cbb .Bool (true );_afde ._eba .DataValidations .DataValidation =append (_afde ._eba .DataValidations .DataValidation ,_cd );_afde ._eba .DataValidations .CountAttr =_cbb .Uint32 (uint32 (len (_afde ._eba .DataValidations .DataValidation )));return DataValidation {_cd };};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_fdb Row )RowNumber ()uint32 {if _fdb ._eaeb .RAttr !=nil {return *_fdb ._eaeb .RAttr ;};return 0;};func (_dece Cell )setLocked (_cecf bool ){_eb :=_dece ._aeb .SAttr ;if _eb !=nil {_fgg :=_dece ._dcd .StyleSheet .GetCellStyle (*_eb );if _fgg ._cbc .Protection ==nil {_fgg ._cbc .Protection =_ecbba .NewCT_CellProtection ();};_fgg ._cbc .Protection .LockedAttr =&_cecf ;};};

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_dbfbe TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_dbfbe ._bef .To }};func (_eabe PatternFill )X ()*_ecbba .CT_PatternFill {return _eabe ._afdb };

// MoveTo is a no-op.
func (_cagg AbsoluteAnchor )MoveTo (x ,y int32 ){};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_cecfc ,_gaa :=_abe .Open (filename );if _gaa !=nil {return nil ,_ddb .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_gaa );};defer _cecfc .Close ();_aece ,_gaa :=_abe .Stat (filename );if _gaa !=nil {return nil ,_ddb .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_gaa );};_fggc ,_gaa :=Read (_cecfc ,_aece .Size ());if _gaa !=nil {return nil ,_gaa ;};_bd ,_ :=_cgac .Abs (_cgac .Dir (filename ));_fggc ._abgff =_cgac .Join (_bd ,filename );return _fggc ,nil ;};func (_gbg Cell )getLabelPrefix ()string {if _gbg ._aeb .SAttr ==nil {return "";};_addb :=*_gbg ._aeb .SAttr ;_dagb :=_gbg ._dcd .StyleSheet .GetCellStyle (_addb );switch _dagb ._cbc .Alignment .HorizontalAttr {case _ecbba .ST_HorizontalAlignmentLeft :return "\u0027";case _ecbba .ST_HorizontalAlignmentRight :return "\u0022";case _ecbba .ST_HorizontalAlignmentCenter :return "\u005e";case _ecbba .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_cgfb Drawing )AddChart (at AnchorType )(_ccfb .Chart ,Anchor ){_dgaed :=_acd .NewChartSpace ();_cgfb ._ceg ._abbff =append (_cgfb ._ceg ._abbff ,_dgaed );_cfce :=_cbb .AbsoluteFilename (_cbb .DocTypeSpreadsheet ,_cbb .ChartContentType ,len (_cgfb ._ceg ._abbff ));_cgfb ._ceg .ContentTypes .AddOverride (_cfce ,_cbb .ChartContentType );var _ebgd string ;for _bbg ,_bcebe :=range _cgfb ._ceg ._ecfd {if _bcebe ==_cgfb ._aaba {_cgdg :=_cbb .RelativeFilename (_cbb .DocTypeSpreadsheet ,_cbb .DrawingType ,_cbb .ChartType ,len (_cgfb ._ceg ._abbff ));_ccef :=_cgfb ._ceg ._agg [_bbg ].AddRelationship (_cgdg ,_cbb .ChartType );_ebgd =_ccef .ID ();break ;};};var _eafd Anchor ;var _eddd *_ebgb .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_ggda :=_ebaf ();_cgfb ._aaba .EG_Anchor =append (_cgfb ._aaba .EG_Anchor ,&_ebgb .EG_Anchor {AbsoluteAnchor :_ggda });_ggda .Choice =&_ebgb .EG_ObjectChoicesChoice {};_ggda .Choice .GraphicFrame =_ebgb .NewCT_GraphicalObjectFrame ();_eddd =_ggda .Choice .GraphicFrame ;_eafd =AbsoluteAnchor {_ggda };case AnchorTypeOneCell :_dfbe :=_bbcd ();_cgfb ._aaba .EG_Anchor =append (_cgfb ._aaba .EG_Anchor ,&_ebgb .EG_Anchor {OneCellAnchor :_dfbe });_dfbe .Choice =&_ebgb .EG_ObjectChoicesChoice {};_dfbe .Choice .GraphicFrame =_ebgb .NewCT_GraphicalObjectFrame ();_eddd =_dfbe .Choice .GraphicFrame ;_eafd =OneCellAnchor {_dfbe };case AnchorTypeTwoCell :_bcca :=_dfga ();_cgfb ._aaba .EG_Anchor =append (_cgfb ._aaba .EG_Anchor ,&_ebgb .EG_Anchor {TwoCellAnchor :_bcca });_bcca .Choice =&_ebgb .EG_ObjectChoicesChoice {};_bcca .Choice .GraphicFrame =_ebgb .NewCT_GraphicalObjectFrame ();_eddd =_bcca .Choice .GraphicFrame ;_eafd =TwoCellAnchor {_bcca };};_eddd .NvGraphicFramePr =_ebgb .NewCT_GraphicalObjectFrameNonVisual ();_eddd .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_cgfb ._aaba .EG_Anchor ));_eddd .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_eddd .Graphic =_cgb .NewGraphic ();_eddd .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";_ecbgg :=_acd .NewChart ();_ecbgg .IdAttr =_ebgd ;_eddd .Graphic .GraphicData .Any =[]_cbb .Any {_ecbgg };_ffda :=_ccfb .MakeChart (_dgaed );_ffda .Properties ().SetSolidFill (_gacd .White );_ffda .SetDisplayBlanksAs (_acd .ST_DispBlanksAsGap );return _ffda ,_eafd ;};func (_gfbg Fills )AddFill ()Fill {_gcdc :=_ecbba .NewCT_Fill ();_gfbg ._dac .Fill =append (_gfbg ._dac .Fill ,_gcdc );_gfbg ._dac .CountAttr =_cbb .Uint32 (uint32 (len (_gfbg ._dac .Fill )));return Fill {_gcdc ,_gfbg ._dac };};

// X returns the inner wrapped XML type.
func (_aefdea Cell )X ()*_ecbba .CT_Cell {return _aefdea ._aeb };func (_cef Comments )getOrCreateAuthor (_geg string )uint32 {for _geef ,_cac :=range _cef ._agfd .Authors .Author {if _cac ==_geg {return uint32 (_geef );};};_gccg :=uint32 (len (_cef ._agfd .Authors .Author ));_cef ._agfd .Authors .Author =append (_cef ._agfd .Authors .Author ,_geg );return _gccg ;};func _dfga ()*_ebgb .CT_TwoCellAnchor {_ddeg :=_ebgb .NewCT_TwoCellAnchor ();_ddeg .EditAsAttr =_ebgb .ST_EditAsOneCell ;_ddeg .From .Col =5;_ddeg .From .Row =0;_ddeg .From .ColOff .ST_CoordinateUnqualified =_cbb .Int64 (0);_ddeg .From .RowOff .ST_CoordinateUnqualified =_cbb .Int64 (0);_ddeg .To .Col =10;_ddeg .To .Row =20;_ddeg .To .ColOff .ST_CoordinateUnqualified =_cbb .Int64 (0);_ddeg .To .RowOff .ST_CoordinateUnqualified =_cbb .Int64 (0);return _ddeg ;};

// X returns the inner wrapped XML type.
func (_bbga RichText )X ()*_ecbba .CT_Rst {return _bbga ._face };

// SetRowOffset sets the row offset of the two cell anchor
func (_dad TwoCellAnchor )SetRowOffset (m _gebcd .Distance ){_fecc :=m -_dad .TopLeft ().RowOffset ();_dad .TopLeft ().SetRowOffset (m );_dad .BottomRight ().SetRowOffset (_dad .BottomRight ().RowOffset ()+_fecc );};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_fdafa CellStyle )HasNumberFormat ()bool {return _fdafa ._cbc .NumFmtIdAttr !=nil &&_fdafa ._cbc .ApplyNumberFormatAttr !=nil &&*_fdafa ._cbc .ApplyNumberFormatAttr ;};func (_dgaa Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _cega ,_cca ,_gbf ,_cfee uint32 =1,1,0,0;for _ ,_cfbb :=range _dgaa .Rows (){if _cfbb .RowNumber ()< _cega {_cega =_cfbb .RowNumber ();}else if _cfbb .RowNumber ()> _cca {_cca =_cfbb .RowNumber ();};for _ ,_fcgf :=range _cfbb .Cells (){_afd ,_ccb :=_cddgb .ParseCellReference (_fcgf .Reference ());if _ccb ==nil {if _afd .ColumnIdx < _gbf {_gbf =_afd .ColumnIdx ;}else if _afd .ColumnIdx > _cfee {_cfee =_afd .ColumnIdx ;};};};};return _cddgb .IndexToColumn (_gbf ),_cega ,_cddgb .IndexToColumn (_cfee ),_cca ;};

// X returns the inner wrapped XML type.
func (_bddb SheetView )X ()*_ecbba .CT_SheetView {return _bddb ._fca };func _cefd (_ecgd string ,_gca uint32 ,_eced bool )string {_gdba ,_bfce ,_gagf :=_cddgb .ParseRangeReference (_ecgd );if _gagf ==nil {_egdb ,_ggcg :=_gdba .ColumnIdx ,_bfce .ColumnIdx ;if _gca >=_egdb &&_gca <=_ggcg {if _egdb ==_ggcg {if _eced {return "";}else {return _ecgd ;};}else {_ebc :=_bfce .Update (_cfa .UpdateActionRemoveColumn );return _ddb .Sprintf ("\u0025\u0073\u003a%\u0073",_gdba .String (),_ebc .String ());};}else if _gca < _egdb {_gcb :=_gdba .Update (_cfa .UpdateActionRemoveColumn );_fcba :=_bfce .Update (_cfa .UpdateActionRemoveColumn );return _ddb .Sprintf ("\u0025\u0073\u003a%\u0073",_gcb .String (),_fcba .String ());};}else {_eef ,_aba ,_bfac :=_cddgb .ParseColumnRangeReference (_ecgd );if _bfac !=nil {return "";};_ba ,_afgf :=_eef .ColumnIdx ,_aba .ColumnIdx ;if _gca >=_ba &&_gca <=_afgf {if _ba ==_afgf {if _eced {return "";}else {return _ecgd ;};}else {_gefc :=_aba .Update (_cfa .UpdateActionRemoveColumn );return _ddb .Sprintf ("\u0025\u0073\u003a%\u0073",_eef .String (),_gefc .String ());};}else if _gca < _ba {_cfbbf :=_eef .Update (_cfa .UpdateActionRemoveColumn );_afed :=_aba .Update (_cfa .UpdateActionRemoveColumn );return _ddb .Sprintf ("\u0025\u0073\u003a%\u0073",_cfbbf .String (),_afed .String ());};};return "";};

// SetStyle sets the style to be used for conditional rules
func (_eaf ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_eaf ._gacg .DxfIdAttr =_cbb .Uint32 (d .Index ());};

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_aagb TwoCellAnchor )SetHeightCells (h int32 ){_aagb .SetHeight (0);_beed :=_aagb .TopLeft ();_ggad :=_aagb .BottomRight ();_ggad .SetRow (_beed .Row ()+h );};

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_dafc *Workbook ;_dcff *_ecbba .CT_NumFmt ;};

// SetBold causes the text to be displayed in bold.
func (_gefd RichTextRun )SetBold (b bool ){_gefd .ensureRpr ();_gefd ._gdf .RPr .B =_ecbba .NewCT_BooleanProperty ();_gefd ._gdf .RPr .B .ValAttr =_cbb .Bool (b );};

// X returns the inner wrapped XML type.
func (_ggagc Table )X ()*_ecbba .Table {return _ggagc ._ggd };

// SetType sets the type of the rule.
func (_adga ConditionalFormattingRule )SetType (t _ecbba .ST_CfType ){_adga ._gacg .TypeAttr =t };

// GetFormat returns a cell data format.
func (_faee *evalContext )GetFormat (cellRef string )string {return _faee ._bada .Cell (cellRef ).getFormat ();};

// SetHeightCells is a no-op.
func (_gfceg OneCellAnchor )SetHeightCells (int32 ){};

// Type returns the type of anchor
func (_bdee TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };

// SetSize sets the text size for a rich text run.
func (_adcd RichTextRun )SetSize (m _gebcd .Distance ){_adcd .ensureRpr ();_adcd ._gdf .RPr .Sz =_ecbba .NewCT_FontSize ();_adcd ._gdf .RPr .Sz .ValAttr =float64 (m /_gebcd .Point );};

// SetWidth sets the width of the anchored object.
func (_cdbf AbsoluteAnchor )SetWidth (w _gebcd .Distance ){_cdbf ._cdg .Ext .CxAttr =int64 (w /_gebcd .EMU );};func (_fcd Cell )GetRawValue ()(string ,error ){switch _fcd ._aeb .TAttr {case _ecbba .ST_CellTypeInlineStr :if _fcd ._aeb .Is ==nil ||_fcd ._aeb .Is .T ==nil {return "",nil ;};return *_fcd ._aeb .Is .T ,nil ;case _ecbba .ST_CellTypeS :if _fcd ._aeb .V ==nil {return "",nil ;};_agdc ,_dagd :=_feff .Atoi (*_fcd ._aeb .V );if _dagd !=nil {return "",_dagd ;};return _fcd ._dcd .SharedStrings .GetString (_agdc );case _ecbba .ST_CellTypeStr :if _fcd ._aeb .F !=nil {return _fcd ._aeb .F .Content ,nil ;};};if _fcd ._aeb .V ==nil {return "",nil ;};return *_fcd ._aeb .V ,nil ;};

// RemoveDefinedName removes an existing defined name.
func (_acdd *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _facb .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");};for _efa ,_fgfcd :=range _acdd ._bcf .DefinedNames .DefinedName {if _fgfcd ==dn .X (){copy (_acdd ._bcf .DefinedNames .DefinedName [_efa :],_acdd ._bcf .DefinedNames .DefinedName [_efa +1:]);_acdd ._bcf .DefinedNames .DefinedName [len (_acdd ._bcf .DefinedNames .DefinedName )-1]=nil ;_acdd ._bcf .DefinedNames .DefinedName =_acdd ._bcf .DefinedNames .DefinedName [:len (_acdd ._bcf .DefinedNames .DefinedName )-1];return nil ;};};return _facb .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_eegf *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_fea :=_ecbba .NewCT_ConditionalFormatting ();_eegf ._eba .ConditionalFormatting =append (_eegf ._eba .ConditionalFormatting ,_fea );_bcc :=make (_ecbba .ST_Sqref ,0,0);_fea .SqrefAttr =&_bcc ;for _ ,_dcge :=range cellRanges {*_fea .SqrefAttr =append (*_fea .SqrefAttr ,_dcge );};return ConditionalFormatting {_fea };};

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_ccfa *_ecbba .CT_Col };

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_cbfa TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_cbfa ._bef .From }};

// PasswordHash returns the hash of the workbook password.
func (_gae SheetProtection )PasswordHash ()string {if _gae ._cgfa .PasswordAttr ==nil {return "";};return *_gae ._cgfa .PasswordAttr ;};func (_dde PatternFill )ClearFgColor (){_dde ._afdb .FgColor =nil };const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;);

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_cdc Cell )GetCachedFormulaResult ()string {if _cdc ._aeb .V !=nil {return *_cdc ._aeb .V ;};return "";};var _ab *_gfba .Regexp =_gfba .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// X returns the inner wrapped XML type.
func (_ffee NumberFormat )X ()*_ecbba .CT_NumFmt {return _ffee ._dcff };

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_aae Drawing )AddImage (img _acgc .ImageRef ,at AnchorType )Anchor {_eec :=0;for _aac ,_gecd :=range _aae ._ceg .Images {if _gecd ==img {_eec =_aac +1;break ;};};var _cafd string ;for _edfeb ,_bfd :=range _aae ._ceg ._ecfd {if _bfd ==_aae ._aaba {_ggdg :=_ddb .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_eec ,img .Format ());_cgffg :=_aae ._ceg ._agg [_edfeb ].AddRelationship (_ggdg ,_cbb .ImageType );_cafd =_cgffg .ID ();break ;};};var _fege Anchor ;var _edgb *_ebgb .CT_Picture ;switch at {case AnchorTypeAbsolute :_dgbb :=_ebaf ();_aae ._aaba .EG_Anchor =append (_aae ._aaba .EG_Anchor ,&_ebgb .EG_Anchor {AbsoluteAnchor :_dgbb });_dgbb .Choice =&_ebgb .EG_ObjectChoicesChoice {};_dgbb .Choice .Pic =_ebgb .NewCT_Picture ();_edgb =_dgbb .Choice .Pic ;_fege =AbsoluteAnchor {_dgbb };case AnchorTypeOneCell :_acb :=_bbcd ();_aae ._aaba .EG_Anchor =append (_aae ._aaba .EG_Anchor ,&_ebgb .EG_Anchor {OneCellAnchor :_acb });_acb .Choice =&_ebgb .EG_ObjectChoicesChoice {};_acb .Choice .Pic =_ebgb .NewCT_Picture ();_edgb =_acb .Choice .Pic ;_fege =OneCellAnchor {_acb };case AnchorTypeTwoCell :_cb :=_dfga ();_aae ._aaba .EG_Anchor =append (_aae ._aaba .EG_Anchor ,&_ebgb .EG_Anchor {TwoCellAnchor :_cb });_cb .Choice =&_ebgb .EG_ObjectChoicesChoice {};_cb .Choice .Pic =_ebgb .NewCT_Picture ();_edgb =_cb .Choice .Pic ;_fege =TwoCellAnchor {_cb };};_edgb .NvPicPr .CNvPr .IdAttr =uint32 (len (_aae ._aaba .EG_Anchor ));_edgb .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_edgb .BlipFill .Blip =_cgb .NewCT_Blip ();_edgb .BlipFill .Blip .EmbedAttr =_cbb .String (_cafd );_edgb .BlipFill .Stretch =_cgb .NewCT_StretchInfoProperties ();_edgb .SpPr =_cgb .NewCT_ShapeProperties ();_edgb .SpPr .Xfrm =_cgb .NewCT_Transform2D ();_edgb .SpPr .Xfrm .Off =_cgb .NewCT_Point2D ();_edgb .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_cbb .Int64 (0);_edgb .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_cbb .Int64 (0);_edgb .SpPr .Xfrm .Ext =_cgb .NewCT_PositiveSize2D ();_edgb .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_gebcd .Pixel72 )/_gebcd .EMU );_edgb .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_gebcd .Pixel72 )/_gebcd .EMU );_edgb .SpPr .PrstGeom =_cgb .NewCT_PresetGeometry2D ();_edgb .SpPr .PrstGeom .PrstAttr =_cgb .ST_ShapeTypeRect ;_edgb .SpPr .Ln =_cgb .NewCT_LineProperties ();_edgb .SpPr .Ln .NoFill =_cgb .NewCT_NoFillProperties ();return _fege ;};

// ClearBorder clears any border configuration from the cell style.
func (_bcec CellStyle )ClearBorder (){_bcec ._cbc .BorderIdAttr =nil ;_bcec ._cbc .ApplyBorderAttr =nil };

// SetHeight sets the row height in points.
func (_ffga Row )SetHeight (d _gebcd .Distance ){_ffga ._eaeb .HtAttr =_cbb .Float64 (float64 (d ));_ffga ._eaeb .CustomHeightAttr =_cbb .Bool (true );};

// SetFont applies a font to a cell style.  The font is referenced by its
// index so modifying the font afterward will affect all styles that reference
// it.
func (_efg CellStyle )SetFont (f Font ){_efg ._cbc .FontIdAttr =_cbb .Uint32 (f .Index ());_efg ._cbc .ApplyFontAttr =_cbb .Bool (true );};func (_dace Border )SetLeft (style _ecbba .ST_BorderStyle ,c _gacd .Color ){if _dace ._gcac .Left ==nil {_dace ._gcac .Left =_ecbba .NewCT_BorderPr ();};_dace ._gcac .Left .Color =_ecbba .NewCT_Color ();_dace ._gcac .Left .Color .RgbAttr =c .AsRGBAString ();_dace ._gcac .Left .StyleAttr =style ;};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_bef *_ebgb .CT_TwoCellAnchor };

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_cgcg *Sheet )SetFrozen (firstRow ,firstCol bool ){_cgcg ._eba .SheetViews =nil ;_baf :=_cgcg .AddView ();_baf .SetState (_ecbba .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_baf .SetYSplit (1);_baf .SetXSplit (1);_baf .SetTopLeft ("\u0042\u0032");case firstRow :_baf .SetYSplit (1);_baf .SetTopLeft ("\u0041\u0032");case firstCol :_baf .SetXSplit (1);_baf .SetTopLeft ("\u0042\u0031");};};func (_ede Sheet )validateRowCellNumbers ()error {_bac :=map[uint32 ]struct{}{};for _ ,_beec :=range _ede ._eba .SheetData .Row {if _beec .RAttr !=nil {if _ ,_bgb :=_bac [*_beec .RAttr ];_bgb {return _ddb .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_ede .Name (),*_beec .RAttr );};_bac [*_beec .RAttr ]=struct{}{};};_dgbaf :=map[string ]struct{}{};for _ ,_gaedf :=range _beec .C {if _gaedf .RAttr ==nil {continue ;};if _ ,_agb :=_dgbaf [*_gaedf .RAttr ];_agb {return _ddb .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_ede .Name (),*_gaedf .RAttr );};_dgbaf [*_gaedf .RAttr ]=struct{}{};};};return nil ;};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_egbbf Cell )SetRichTextString ()RichText {_egbbf .clearValue ();_egbbf ._aeb .Is =_ecbba .NewCT_Rst ();_egbbf ._aeb .TAttr =_ecbba .ST_CellTypeInlineStr ;return RichText {_egbbf ._aeb .Is };};

// Comment is a single comment within a sheet.
type Comment struct{_dbef *Workbook ;_fcccd *_ecbba .CT_Comment ;_dgb *_ecbba .Comments ;};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_acbd Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_ffddb :=[]Cell {};for _dgff :=uint32 (0);_dgff <=lastColIdx ;_dgff ++{_ccfg :=_acbd .Cell (_cddgb .IndexToColumn (_dgff ));_ffddb =append (_ffddb ,_ccfg );};return _ffddb ;};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_gfd StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_afg :=range _gfd .CellStyles (){if _afg .HasNumberFormat ()&&_afg .NumberFormat ()==uint32 (f ){return _afg ;};};_afbb :=_gfd .AddCellStyle ();_afbb .SetNumberFormatStandard (f );return _afbb ;};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_ddfg Sheet )ValidateWithPath (path string )error {return _ddfg ._eba .ValidateWithPath (path )};func _bddf (_cgdb *Sheet )*evalContext {return &evalContext {_bada :_cgdb ,_cbd :make (map[string ]struct{})};};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_ageba Comment )CellReference ()string {return _ageba ._fcccd .RefAttr };const (DVCompareOpEqual =DVCompareOp (_ecbba .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_ecbba .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_ecbba .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_ecbba .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_ecbba .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_ecbba .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_ecbba .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_ecbba .ST_DataValidationOperatorLessThanOrEqual ););

// SetPassword sets the password hash to a hash of the input password.
func (_egge SheetProtection )SetPassword (pw string ){_egge .SetPasswordHash (PasswordHash (pw ))};

// Tables returns a slice of all defined tables in the workbook.
func (_cda *Workbook )Tables ()[]Table {if _cda ._dafa ==nil {return nil ;};_cecc :=[]Table {};for _ ,_fggcc :=range _cda ._dafa {_cecc =append (_cecc ,Table {_fggcc });};return _cecc ;};var (_affd =[...]uint8 {0,21,46,61,76,91};_bdeg =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_ef =[...]uint8 {0,16,32,48,64};_fccfe =[...]uint8 {0,16,32,48,64,80};);

// IsHidden returns whether the row is hidden or not.
func (_fcc Row )IsHidden ()bool {return _fcc ._eaeb .HiddenAttr !=nil &&*_fcc ._eaeb .HiddenAttr };

// SetPassword sets the password hash to a hash of the input password.
func (_fgd WorkbookProtection )SetPassword (pw string ){_fgd .SetPasswordHash (PasswordHash (pw ))};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_accbg *_ecbba .CT_DataBar };

// X returns the inner wrapped XML type.
func (_effg Column )X ()*_ecbba .CT_Col {return _effg ._ccfa };func NewPatternFill (fills *_ecbba .CT_Fills )PatternFill {_bedd :=_ecbba .NewCT_Fill ();_bedd .PatternFill =_ecbba .NewCT_PatternFill ();return PatternFill {_bedd .PatternFill ,_bedd };};

// SetBorder applies a border to a cell style.  The border is referenced by its
// index so modifying the border afterward will affect all styles that reference
// it.
func (_cgea CellStyle )SetBorder (b Border ){_cgea ._cbc .BorderIdAttr =_cbb .Uint32 (b .Index ());_cgea ._cbc .ApplyBorderAttr =_cbb .Bool (true );};

// AddFormatValue adds a format value (databars require two).
func (_ffgf DataBarScale )AddFormatValue (t _ecbba .ST_CfvoType ,val string ){_fbb :=_ecbba .NewCT_Cfvo ();_fbb .TypeAttr =t ;_fbb .ValAttr =_cbb .String (val );_ffgf ._accbg .Cfvo =append (_ffgf ._accbg .Cfvo ,_fbb );};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_ebg Sheet )RangeReference (n string )string {_faef :=_eggdf .Split (n ,"\u003a");_afgb ,_ :=_cddgb .ParseCellReference (_faef [0]);_cfe :=_ddb .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_afgb .Column ,_afgb .RowIdx );if len (_faef )==1{return _ddb .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_ebg .Name (),_cfe );};_dbea ,_ :=_cddgb .ParseCellReference (_faef [1]);_gdge :=_ddb .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_dbea .Column ,_dbea .RowIdx );return _ddb .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_ebg .Name (),_cfe ,_gdge );};func NewFills ()Fills {return Fills {_ecbba .NewCT_Fills ()}};type WorkbookProtection struct{_aab *_ecbba .CT_WorkbookProtection };

// SetAllowBlank controls if blank values are accepted.
func (_fg DataValidation )SetAllowBlank (b bool ){if !b {_fg ._dcb .AllowBlankAttr =nil ;}else {_fg ._dcb .AllowBlankAttr =_cbb .Bool (true );};};func (_ggac DataValidation )clear (){_ggac ._dcb .Formula1 =_cbb .String ("\u0030");_ggac ._dcb .Formula2 =_cbb .String ("\u0030");};func (_eee SheetView )ensurePane (){if _eee ._fca .Pane ==nil {_eee ._fca .Pane =_ecbba .NewCT_Pane ();_eee ._fca .Pane .ActivePaneAttr =_ecbba .ST_PaneBottomLeft ;};};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_dga *Workbook )GetFilename ()string {return _dga ._abgff };

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_fge ,_cacd int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_cbfd _gebcd .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_fag int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_gaae _gebcd .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_gbcc int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_dbbg _gebcd .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_ddbe _gebcd .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};func (_eacd Fill )SetPatternFill ()PatternFill {_eacd ._bab .GradientFill =nil ;_eacd ._bab .PatternFill =_ecbba .NewCT_PatternFill ();_eacd ._bab .PatternFill .PatternTypeAttr =_ecbba .ST_PatternTypeSolid ;return PatternFill {_eacd ._bab .PatternFill ,_eacd ._bab };};

// X returns the inner XML entity for a stylesheet.
func (_cg StyleSheet )X ()*_ecbba .StyleSheet {return _cg ._cag };

// AddFont adds a new empty font to the stylesheet.
func (_gbcda StyleSheet )AddFont ()Font {_dbae :=_ecbba .NewCT_Font ();_gbcda ._cag .Fonts .Font =append (_gbcda ._cag .Fonts .Font ,_dbae );_gbcda ._cag .Fonts .CountAttr =_cbb .Uint32 (uint32 (len (_gbcda ._cag .Fonts .Font )));return Font {_dbae ,_gbcda ._cag };};

// AddRule adds and returns a new rule that can be configured.
func (_decc ConditionalFormatting )AddRule ()ConditionalFormattingRule {_bbab :=_ecbba .NewCT_CfRule ();_decc ._ebfd .CfRule =append (_decc ._ebfd .CfRule ,_bbab );_eeg :=ConditionalFormattingRule {_bbab };_eeg .InitializeDefaults ();_eeg .SetPriority (int32 (len (_decc ._ebfd .CfRule )+1));return _eeg ;};

// ColOffset returns the offset from the row cell.
func (_aca CellMarker )ColOffset ()_gebcd .Distance {if _aca ._ecdbe .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _gebcd .Distance (float64 (*_aca ._ecdbe .ColOff .ST_CoordinateUnqualified )*_gebcd .EMU );};

// TopLeft returns the top-left corner of the anchored object.
func (_fdfd OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_fdfd ._egcc .From }};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_dge *Workbook )AddDefinedName (name ,ref string )DefinedName {if _dge ._bcf .DefinedNames ==nil {_dge ._bcf .DefinedNames =_ecbba .NewCT_DefinedNames ();};_dce :=_ecbba .NewCT_DefinedName ();_dce .Content =ref ;_dce .NameAttr =name ;_dge ._bcf .DefinedNames .DefinedName =append (_dge ._bcf .DefinedNames .DefinedName ,_dce );return DefinedName {_dce };};func (_agdg CellStyle )SetNumberFormat (s string ){_ecbb :=_agdg ._gfeb .StyleSheet .AddNumberFormat ();_ecbb .SetFormat (s );_agdg ._cbc .ApplyNumberFormatAttr =_cbb .Bool (true );_agdg ._cbc .NumFmtIdAttr =_cbb .Uint32 (_ecbb .ID ());};const (DVCompareTypeWholeNumber =DVCompareType (_ecbba .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_ecbba .ST_DataValidationTypeDecimal );DVCompareTypeDate =DVCompareType (_ecbba .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_ecbba .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_ecbba .ST_DataValidationTypeTextLength ););

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// SetError sets the cell type to error and the value to the given error message.
func (_bfaad Cell )SetError (msg string ){_bfaad .clearValue ();_bfaad ._aeb .V =_cbb .String (msg );_bfaad ._aeb .TAttr =_ecbba .ST_CellTypeE ;};

// AddGradientStop adds a color gradient stop.
func (_gba ColorScale )AddGradientStop (color _gacd .Color ){_bbc :=_ecbba .NewCT_Color ();_bbc .RgbAttr =color .AsRGBAString ();_gba ._efdfg .Color =append (_gba ._efdfg .Color ,_bbc );};

// X returns the inner wrapped XML type.
func (_accd IconScale )X ()*_ecbba .CT_IconSet {return _accd ._bacg };

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_edf Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_edf .SetNumber (v );_edf .SetStyle (_edf ._dcd .StyleSheet .GetOrCreateStandardNumberFormat (f ));};

// Reference returns the region of cells that are merged.
func (_adee MergedCell )Reference ()string {return _adee ._bb .RefAttr };func (_bfaa Fill )Index ()uint32 {if _bfaa ._bca ==nil {return 0;};for _decb ,_dfc :=range _bfaa ._bca .Fill {if _bfaa ._bab ==_dfc {return uint32 (_decb );};};return 0;};

// Name returns the sheet name
func (_daaa Sheet )Name ()string {return _daaa ._aefde .NameAttr };

// SetUnderline controls if the run is underlined.
func (_dddc RichTextRun )SetUnderline (u _ecbba .ST_UnderlineValues ){_dddc .ensureRpr ();_dddc ._gdf .RPr .U =_ecbba .NewCT_UnderlineProperty ();_dddc ._gdf .RPr .U .ValAttr =u ;};

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_gaeag *Sheet )AddRow ()Row {_cdbdf :=uint32 (0);_dee :=uint32 (len (_gaeag ._eba .SheetData .Row ));if _dee > 0&&_gaeag ._eba .SheetData .Row [_dee -1].RAttr !=nil &&*_gaeag ._eba .SheetData .Row [_dee -1].RAttr ==_dee {return _gaeag .addNumberedRowFast (_dee +1);};for _ ,_aag :=range _gaeag ._eba .SheetData .Row {if _aag .RAttr !=nil &&*_aag .RAttr > _cdbdf {_cdbdf =*_aag .RAttr ;};};return _gaeag .AddNumberedRow (_cdbdf +1);};

// MaxColumnIdx returns the max used column of the sheet.
func (_effc Sheet )MaxColumnIdx ()uint32 {_gdfc :=uint32 (0);for _ ,_ccda :=range _effc .Rows (){_fc :=_ccda ._eaeb .C ;if len (_fc )> 0{_acgg :=_fc [len (_fc )-1];_febg ,_ :=_cddgb .ParseCellReference (*_acgg .RAttr );if _gdfc < _febg .ColumnIdx {_gdfc =_febg .ColumnIdx ;};};};return _gdfc ;};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// SetColor sets the text color.
func (_deg RichTextRun )SetColor (c _gacd .Color ){_deg .ensureRpr ();_deg ._gdf .RPr .Color =_ecbba .NewCT_Color ();_gbfdc :="\u0066\u0066"+*c .AsRGBString ();_deg ._gdf .RPr .Color .RgbAttr =&_gbfdc ;};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_df Row )Cell (col string )Cell {_gdb :=_ddb .Sprintf ("\u0025\u0073\u0025\u0064",col ,_df .RowNumber ());for _ ,_afca :=range _df ._eaeb .C {if _afca .RAttr !=nil &&*_afca .RAttr ==_gdb {return Cell {_df ._ggfg ,_df ._faag ,_df ._eaeb ,_afca };};};return _df .AddNamedCell (col );};

// GetString retrieves a string from the shared strings table by index.
func (_gcfgc SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_ddb .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );};if id > len (_gcfgc ._agfe .Si ){return "",_ddb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_gcfgc ._agfe .Si ));};_adad :=_gcfgc ._agfe .Si [id ];if _adad .T !=nil {return *_adad .T ,nil ;};return "",nil ;};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_ebbf *Workbook )RemoveSheetByName (name string )error {_efggd :=-1;for _fcfc ,_eggd :=range _ebbf .Sheets (){if name ==_eggd .Name (){_efggd =_fcfc ;break ;};};if _efggd ==-1{return ErrorNotFound ;};return _ebbf .RemoveSheet (_efggd );};

// SetHidden marks the defined name as hidden.
func (_db DefinedName )SetLocalSheetID (id uint32 ){_db ._affa .LocalSheetIdAttr =_cbb .Uint32 (id )};

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_efgg *evalContext )LastRow (col string )int {_fggb :=_efgg ._bada ;_abcc :=int (_cddgb .ColumnToIndex (col ));_fded :=1;for _ ,_dcdf :=range _fggb ._eba .SheetData .Row {if _dcdf .RAttr !=nil {_bfc :=Row {_fggb ._dg ,_fggb ,_dcdf };_egd :=len (_bfc .Cells ());if _egd > _abcc {_fded =int (_bfc .RowNumber ());};};};return _fded ;};func (_fbf *Sheet )addNumberedRowFast (_ecbg uint32 )Row {_cfg :=_ecbba .NewCT_Row ();_cfg .RAttr =_cbb .Uint32 (_ecbg );_fbf ._eba .SheetData .Row =append (_fbf ._eba .SheetData .Row ,_cfg );return Row {_fbf ._dg ,_fbf ,_cfg };};

// Row returns the row of the cell marker.
func (_bcdc CellMarker )Row ()int32 {return _bcdc ._ecdbe .Row };

// ClearNumberFormat removes any number formatting from the style.
func (_egf CellStyle )ClearNumberFormat (){_egf ._cbc .NumFmtIdAttr =nil ;_egf ._cbc .ApplyNumberFormatAttr =nil ;};

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_eggc *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_eggdf .Replace (rangeRef ,"\u0024","",-1);_eggc ._eba .AutoFilter =_ecbba .NewCT_AutoFilter ();_eggc ._eba .AutoFilter .RefAttr =_cbb .String (rangeRef );_gccga :="\u0027"+_eggc .Name ()+"\u0027\u0021";var _dbca DefinedName ;for _ ,_bgcbe :=range _eggc ._dg .DefinedNames (){if _bgcbe .Name ()==_dgba {if _eggdf .HasPrefix (_bgcbe .Content (),_gccga ){_dbca =_bgcbe ;_dbca .SetContent (_eggc .RangeReference (rangeRef ));break ;};};};if _dbca .X ()==nil {_dbca =_eggc ._dg .AddDefinedName (_dgba ,_eggc .RangeReference (rangeRef ));};for _f ,_gfcg :=range _eggc ._dg ._fccf {if _gfcg ==_eggc ._eba {_dbca .SetLocalSheetID (uint32 (_f ));};};};

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_bacf PatternFill )SetFgColor (c _gacd .Color ){_bacf ._afdb .FgColor =_ecbba .NewCT_Color ();_bacf ._afdb .FgColor .RgbAttr =c .AsRGBAString ();};func (_aaca *Workbook )onNewRelationship (_bgaf *_ffe .DecodeMap ,_afdf ,_ecdb string ,_ggf []*_caaa .File ,_gbcd *_bcabf .Relationship ,_gcgd _ffe .Target )error {_bdgdf :=_cbb .DocTypeSpreadsheet ;switch _ecdb {case _cbb .OfficeDocumentType :_aaca ._bcf =_ecbba .NewWorkbook ();_bgaf .AddTarget (_afdf ,_aaca ._bcf ,_ecdb ,0);_aaca ._feed =_acgc .NewRelationships ();_bgaf .AddTarget (_ffe .RelationsPathFor (_afdf ),_aaca ._feed .X (),_ecdb ,0);_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,0);case _cbb .CorePropertiesType :_bgaf .AddTarget (_afdf ,_aaca .CoreProperties .X (),_ecdb ,0);_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,0);case _cbb .ExtendedPropertiesType :_bgaf .AddTarget (_afdf ,_aaca .AppProperties .X (),_ecdb ,0);_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,0);case _cbb .WorksheetType :_cadd :=_ecbba .NewWorksheet ();_cgde :=uint32 (len (_aaca ._fccf ));_aaca ._fccf =append (_aaca ._fccf ,_cadd );_bgaf .AddTarget (_afdf ,_cadd ,_ecdb ,_cgde );_dcecb :=_acgc .NewRelationships ();_bgaf .AddTarget (_ffe .RelationsPathFor (_afdf ),_dcecb .X (),_ecdb ,0);_aaca ._ecff =append (_aaca ._ecff ,_dcecb );_aaca ._efb =append (_aaca ._efb ,nil );_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,len (_aaca ._fccf ));case _cbb .StylesType :_aaca .StyleSheet =NewStyleSheet (_aaca );_bgaf .AddTarget (_afdf ,_aaca .StyleSheet .X (),_ecdb ,0);_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,0);case _cbb .ThemeType :_edb :=_cgb .NewTheme ();_aaca ._egeg =append (_aaca ._egeg ,_edb );_bgaf .AddTarget (_afdf ,_edb ,_ecdb ,0);_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,len (_aaca ._egeg ));case _cbb .SharedStringsType :_aaca .SharedStrings =NewSharedStrings ();_bgaf .AddTarget (_afdf ,_aaca .SharedStrings .X (),_ecdb ,0);_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,0);case _cbb .ThumbnailType :for _fbea ,_bbcc :=range _ggf {if _bbcc ==nil {continue ;};if _bbcc .Name ==_afdf {_deae ,_dbeb :=_bbcc .Open ();if _dbeb !=nil {return _ddb .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_dbeb );};_aaca .Thumbnail ,_ ,_dbeb =_bcaa .Decode (_deae );_deae .Close ();if _dbeb !=nil {return _ddb .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_dbeb );};_ggf [_fbea ]=nil ;};};case _cbb .ImageType :for _be ,_cccf :=range _ggf {if _cccf ==nil {continue ;};if _cccf .Name ==_afdf {_d ,_bbgbc :=_ffe .ExtractToDiskTmp (_cccf ,_aaca .TmpPath );if _bbgbc !=nil {return _bbgbc ;};_geb ,_bbgbc :=_acgc .ImageFromFile (_d );if _bbgbc !=nil {return _bbgbc ;};_bebe :=_acgc .MakeImageRef (_geb ,&_aaca .DocBase ,_aaca ._feed );_aaca .Images =append (_aaca .Images ,_bebe );_ggf [_be ]=nil ;};};_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,len (_aaca .Images ));case _cbb .DrawingType :_bedf :=_ebgb .NewWsDr ();_e :=uint32 (len (_aaca ._ecfd ));_bgaf .AddTarget (_afdf ,_bedf ,_ecdb ,_e );_aaca ._ecfd =append (_aaca ._ecfd ,_bedf );_acba :=_acgc .NewRelationships ();_bgaf .AddTarget (_ffe .RelationsPathFor (_afdf ),_acba .X (),_ecdb ,_e );_aaca ._agg =append (_aaca ._agg ,_acba );_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,len (_aaca ._ecfd ));case _cbb .VMLDrawingType :_gc :=_gffd .NewContainer ();_deb :=uint32 (len (_aaca ._cdeg ));_bgaf .AddTarget (_afdf ,_gc ,_ecdb ,_deb );_aaca ._cdeg =append (_aaca ._cdeg ,_gc );case _cbb .CommentsType :_aaca ._efb [_gcgd .Index ]=_ecbba .NewComments ();_bgaf .AddTarget (_afdf ,_aaca ._efb [_gcgd .Index ],_ecdb ,_gcgd .Index );_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,len (_aaca ._efb ));case _cbb .ChartType :_cece :=_acd .NewChartSpace ();_bcae :=uint32 (len (_aaca ._abbff ));_bgaf .AddTarget (_afdf ,_cece ,_ecdb ,_bcae );_aaca ._abbff =append (_aaca ._abbff ,_cece );_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,len (_aaca ._abbff ));case _cbb .TableType :_agc :=_ecbba .NewTable ();_edbd :=uint32 (len (_aaca ._dafa ));_bgaf .AddTarget (_afdf ,_agc ,_ecdb ,_edbd );_aaca ._dafa =append (_aaca ._dafa ,_agc );_gbcd .TargetAttr =_cbb .RelativeFilename (_bdgdf ,_gcgd .Typ ,_ecdb ,len (_aaca ._dafa ));default:_cbb .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_afdf ,_ecdb );};return nil ;};

// SetFont sets the font name for a rich text run.
func (_abf RichTextRun )SetFont (s string ){_abf .ensureRpr ();_abf ._gdf .RPr .RFont =_ecbba .NewCT_FontName ();_abf ._gdf .RPr .RFont .ValAttr =s ;};func (_eed *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _eed .getAllCellsInFormulaArrays (false );};

// HasFormula returns true if the cell has an asoociated formula.
func (_ecf Cell )HasFormula ()bool {return _ecf ._aeb .F !=nil };

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _ddeed .ReaderAt ,size int64 )(*Workbook ,error ){_efe :=New ();_bfffb ,_efdbf :=_fgc .TempDir ("","g\u006f\u006f\u0078\u006d\u006c\u002d\u0078\u006c\u0073\u0078");if _efdbf !=nil {return nil ,_efdbf ;};_efe .TmpPath =_bfffb ;_aecf ,_efdbf :=_caaa .NewReader (r ,size );if _efdbf !=nil {return nil ,_ddb .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_efdbf );};_edfec :=[]*_caaa .File {};_edfec =append (_edfec ,_aecf .File ...);_ec :=_ffe .DecodeMap {};_ec .SetOnNewRelationshipFunc (_efe .onNewRelationship );_ec .AddTarget (_cbb .ContentTypesFilename ,_efe .ContentTypes .X (),"",0);_ec .AddTarget (_cbb .BaseRelsFilename ,_efe .Rels .X (),"",0);if _eega :=_ec .Decode (_edfec );_eega !=nil {return nil ,_eega ;};for _ ,_gb :=range _edfec {if _gb ==nil {continue ;};if _gcdcf :=_efe .AddExtraFileFromZip (_gb );_gcdcf !=nil {return nil ,_gcdcf ;};};return _efe ,nil ;};type Fills struct{_dac *_ecbba .CT_Fills };

// X returns the inner wrapped XML type.
func (_ecg Border )X ()*_ecbba .CT_Border {return _ecg ._gcac };

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_egc Cell )SetBool (v bool ){_egc .clearValue ();_egc ._aeb .V =_cbb .String (_feff .Itoa (_eefa (v )));_egc ._aeb .TAttr =_ecbba .ST_CellTypeB ;};var _gbac =[...]uint8 {0,18,37};

// X returns the inner wrapped XML type.
func (_gebc CellMarker )X ()*_ebgb .CT_Marker {return _gebc ._ecdbe };func (_bbac *Sheet )setList (_agbf string ,_ecd _cfeg .Result )error {_bcab ,_gce :=_cddgb .ParseCellReference (_agbf );if _gce !=nil {return _gce ;};_edga :=_bbac .Row (_bcab .RowIdx );for _gdbbd ,_fdd :=range _ecd .ValueList {_gbgd :=_edga .Cell (_cddgb .IndexToColumn (_bcab .ColumnIdx +uint32 (_gdbbd )));if _fdd .Type !=_cfeg .ResultTypeEmpty {if _fdd .IsBoolean {_gbgd .SetBool (_fdd .ValueNumber !=0);}else {_gbgd .SetCachedFormulaResult (_fdd .String ());};};};return nil ;};func (_gcgf *Sheet )slideCellsLeft (_ecde []*_ecbba .CT_Cell )[]*_ecbba .CT_Cell {for _ ,_eccg :=range _ecde {_cf ,_ae :=_cddgb .ParseCellReference (*_eccg .RAttr );if _ae !=nil {return _ecde ;};_dbb :=_cf .ColumnIdx -1;_dddb :=_cddgb .IndexToColumn (_dbb )+_ddb .Sprintf ("\u0025\u0064",_cf .RowIdx );_eccg .RAttr =&_dddb ;};return _ecde ;};

// Border is a cell border configuraton.
type Border struct{_gcac *_ecbba .CT_Border ;_gcba *_ecbba .CT_Borders ;};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_agec *Sheet )SheetViews ()[]SheetView {if _agec ._eba .SheetViews ==nil {return nil ;};_cfbe :=[]SheetView {};for _ ,_cfgd :=range _agec ._eba .SheetViews .SheetView {_cfbe =append (_cfbe ,SheetView {_cfgd });};return _cfbe ;};

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_daa AbsoluteAnchor )SetColOffset (m _gebcd .Distance ){_daa ._cdg .Pos .XAttr .ST_CoordinateUnqualified =_cbb .Int64 (int64 (m /_gebcd .EMU ));};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_cdee *Sheet )AddHyperlink (url string )_acgc .Hyperlink {for _caa ,_bff :=range _cdee ._dg ._fccf {if _bff ==_cdee ._eba {return _cdee ._dg ._ecff [_caa ].AddHyperlink (url );};};return _acgc .Hyperlink {};};

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_gace Cell )SetFormulaRaw (s string ){_gace .clearValue ();_gace ._aeb .TAttr =_ecbba .ST_CellTypeStr ;_gace ._aeb .F =_ecbba .NewCT_CellFormula ();_gace ._aeb .F .Content =s ;};

// GetEpoch returns a workbook's time epoch.
func (_beee *evalContext )GetEpoch ()_dbf .Time {return _beee ._bada ._dg .Epoch ()};func _eacg (_cgd string )bool {_cgd =_eggdf .Replace (_cgd ,"\u0024","",-1);if _cfde :=_ab .FindStringSubmatch (_eggdf .ToLower (_cgd ));len (_cfde )> 2{_cc :=_cfde [1];_ead ,_bgada :=_feff .Atoi (_cfde [2]);if _bgada !=nil {return false ;};return _ead <=1048576&&_cc <="\u007a\u007a";};return false ;};

// X returns the inner wrapped XML type.
func (_fcfg Font )X ()*_ecbba .CT_Font {return _fcfg ._afdbd };

// SetWidthCells is a no-op.
func (_bgbb OneCellAnchor )SetWidthCells (int32 ){};const (DVOpGreater =_ecbba .ST_DataValidationOperatorGreaterThanOrEqual ;);

// MoveTo moves the top-left of the anchored object.
func (_gbbe OneCellAnchor )MoveTo (col ,row int32 ){_gbbe .TopLeft ().SetCol (col );_gbbe .TopLeft ().SetRow (row );};

// SetItalic causes the text to be displayed in italic.
func (_dcfb RichTextRun )SetItalic (b bool ){_dcfb .ensureRpr ();_dcfb ._gdf .RPr .I =_ecbba .NewCT_BooleanProperty ();_dcfb ._gdf .RPr .I .ValAttr =_cbb .Bool (b );};

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_bfgg Row )AddNamedCell (col string )Cell {_ggcb :=_ecbba .NewCT_Cell ();_ggcb .RAttr =_cbb .Stringf ("\u0025\u0073\u0025\u0064",col ,_bfgg .RowNumber ());_fdfb :=-1;_abbf :=_cddgb .ColumnToIndex (col );for _cfbac ,_cadg :=range _bfgg ._eaeb .C {_ffc ,_bgcb :=_cddgb .ParseCellReference (*_cadg .RAttr );if _bgcb !=nil {return Cell {};};if _abbf < _ffc .ColumnIdx {_fdfb =_cfbac ;break ;};};if _fdfb ==-1{_bfgg ._eaeb .C =append (_bfgg ._eaeb .C ,_ggcb );}else {_bfgg ._eaeb .C =append (_bfgg ._eaeb .C [:_fdfb ],append ([]*_ecbba .CT_Cell {_ggcb },_bfgg ._eaeb .C [_fdfb :]...)...);};return Cell {_bfgg ._ggfg ,_bfgg ._faag ,_bfgg ._eaeb ,_ggcb };};

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_aeda *Workbook )Uses1904Dates ()bool {if _aeda ._bcf .WorkbookPr ==nil ||_aeda ._bcf .WorkbookPr .Date1904Attr ==nil {return false ;};return *_aeda ._bcf .WorkbookPr .Date1904Attr ;};

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_edee Cell )SetCachedFormulaResult (s string ){_edee ._aeb .V =&s };

// Type returns the type of anchor
func (_aga OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// Sheets returns the sheets from the workbook.
func (_dfgf *Workbook )Sheets ()[]Sheet {_acdb :=[]Sheet {};for _abd ,_ffff :=range _dfgf ._fccf {_fdgf :=_dfgf ._bcf .Sheets .Sheet [_abd ];_acbg :=Sheet {_dfgf ,_fdgf ,_ffff };_acdb =append (_acdb ,_acbg );};return _acdb ;};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As gooxml formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_da *Workbook )RecalculateFormulas (){for _ ,_aceb :=range _da .Sheets (){_aceb .RecalculateFormulas ();};};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_acgb CellStyle )SetVerticalAlignment (a _ecbba .ST_VerticalAlignment ){if _acgb ._cbc .Alignment ==nil {_acgb ._cbc .Alignment =_ecbba .NewCT_CellAlignment ();};_acgb ._cbc .ApplyAlignmentAttr =_cbb .Bool (true );_acgb ._cbc .Alignment .VerticalAttr =a ;};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_afdbd *_ecbba .CT_Font ;_gfcf *_ecbba .StyleSheet ;};

// Operator returns the operator for the rule
func (_efcd ConditionalFormattingRule )Operator ()_ecbba .ST_ConditionalFormattingOperator {return _efcd ._gacg .OperatorAttr ;};

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_dgc *Sheet )Row (rowNum uint32 )Row {for _ ,_eacb :=range _dgc ._eba .SheetData .Row {if _eacb .RAttr !=nil &&*_eacb .RAttr ==rowNum {return Row {_dgc ._dg ,_dgc ,_eacb };};};return _dgc .AddNumberedRow (rowNum );};

// AddBorder creates a new empty border that can be applied to a cell style.
func (_fegd StyleSheet )AddBorder ()Border {_afb :=_ecbba .NewCT_Border ();_fegd ._cag .Borders .Border =append (_fegd ._cag .Borders .Border ,_afb );_fegd ._cag .Borders .CountAttr =_cbb .Uint32 (uint32 (len (_fegd ._cag .Borders .Border )));return Border {_afb ,_fegd ._cag .Borders };};func (_ecgb Row )renumberAs (_fcg uint32 ){_ecgb ._eaeb .RAttr =_cbb .Uint32 (_fcg );for _ ,_bbfd :=range _ecgb .Cells (){_edde ,_dgcee :=_cddgb .ParseCellReference (_bbfd .Reference ());if _dgcee ==nil {_cfef :=_ddb .Sprintf ("\u0025\u0073\u0025\u0064",_edde .Column ,_fcg );_bbfd ._aeb .RAttr =_cbb .String (_cfef );};};};

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_bcg StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _bcg ._cag .Dxfs ==nil {_bcg ._cag .Dxfs =_ecbba .NewCT_Dxfs ();};_bagg :=_ecbba .NewCT_Dxf ();_bcg ._cag .Dxfs .Dxf =append (_bcg ._cag .Dxfs .Dxf ,_bagg );_bcg ._cag .Dxfs .CountAttr =_cbb .Uint32 (uint32 (len (_bcg ._cag .Dxfs .Dxf )));return DifferentialStyle {_bagg ,_bcg ._bdf ,_bcg ._cag .Dxfs };};

// SetConditionValue sets the condition value to be used for style applicaton.
func (_fgf ConditionalFormattingRule )SetConditionValue (v string ){_fgf ._gacg .Formula =[]string {v }};

// SetHidden hides or unhides the row
func (_cfdf Row )SetHidden (hidden bool ){if !hidden {_cfdf ._eaeb .HiddenAttr =nil ;}else {_cfdf ._eaeb .HiddenAttr =_cbb .Bool (true );};};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_cgbb Cell )GetString ()string {switch _cgbb ._aeb .TAttr {case _ecbba .ST_CellTypeInlineStr :if _cgbb ._aeb .Is !=nil &&_cgbb ._aeb .Is .T !=nil {return *_cgbb ._aeb .Is .T ;};if _cgbb ._aeb .V !=nil {return *_cgbb ._aeb .V ;};case _ecbba .ST_CellTypeS :if _cgbb ._aeb .V ==nil {return "";};_gcdd ,_daed :=_feff .Atoi (*_cgbb ._aeb .V );if _daed !=nil {return "";};_dcbf ,_daed :=_cgbb ._dcd .SharedStrings .GetString (_gcdd );if _daed !=nil {return "";};return _dcbf ;};if _cgbb ._aeb .V ==nil {return "";};return *_cgbb ._aeb .V ;};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_gdf *_ecbba .CT_RElt };

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_abfd *Sheet )AddNumberedRow (rowNum uint32 )Row {_bbge :=_ecbba .NewCT_Row ();_bbge .RAttr =_cbb .Uint32 (rowNum );_abfd ._eba .SheetData .Row =append (_abfd ._eba .SheetData .Row ,_bbge );_cafdc .Slice (_abfd ._eba .SheetData .Row ,func (_aaaa ,_ag int )bool {_bfg :=_abfd ._eba .SheetData .Row [_aaaa ].RAttr ;_edeg :=_abfd ._eba .SheetData .Row [_ag ].RAttr ;if _bfg ==nil {return true ;};if _edeg ==nil {return true ;};return *_bfg < *_edeg ;});return Row {_abfd ._dg ,_abfd ,_bbge };};func (_fcgg Font )SetColor (c _gacd .Color ){_dfe :=_ecbba .NewCT_Color ();_feae :="\u0066\u0066"+*c .AsRGBString ();_dfe .RgbAttr =&_feae ;_fcgg ._afdbd .Color =[]*_ecbba .CT_Color {_dfe };};

// Protection controls the protection on an individual sheet.
func (_bcb *Sheet )Protection ()SheetProtection {if _bcb ._eba .SheetProtection ==nil {_bcb ._eba .SheetProtection =_ecbba .NewCT_SheetProtection ();};return SheetProtection {_bcb ._eba .SheetProtection };};

// Index returns the index of the differential style.
func (_aefad DifferentialStyle )Index ()uint32 {for _gcfg ,_cded :=range _aefad ._gf .Dxf {if _aefad ._bea ==_cded {return uint32 (_gcfg );};};return 0;};

// Sheet is a single sheet within a workbook.
type Sheet struct{_dg *Workbook ;_aefde *_ecbba .CT_Sheet ;_eba *_ecbba .Worksheet ;};

// SetRowOffset sets the row offset of the top-left anchor.
func (_bgcbb OneCellAnchor )SetRowOffset (m _gebcd .Distance ){_bgcbb .TopLeft ().SetRowOffset (m )};

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_cgdef *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_fgad :=_cgdef ._eba .SheetData .Row ;_fccc :=_cgdef .Rows ();for _gfa ,_geca :=range _fccc {if _geca .RowNumber ()==firstRow {_fgad =_cgdef ._eba .SheetData .Row [_gfa :];break ;};};_agcc :=Comparer {Order :order };_cafdc .Slice (_fgad ,func (_cea ,_gcbc int )bool {return _agcc .LessRows (column ,Row {_cgdef ._dg ,_cgdef ,_fgad [_cea ]},Row {_cgdef ._dg ,_cgdef ,_fgad [_gcbc ]});});for _adbf ,_g :=range _cgdef .Rows (){_dea :=uint32 (_adbf +1);if _g .RowNumber ()!=_dea {_g .renumberAs (_dea );};};};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_dgca *Workbook )AddImage (i _acgc .Image )(_acgc .ImageRef ,error ){_agbd :=_acgc .MakeImageRef (i ,&_dgca .DocBase ,_dgca ._feed );if i .Data ==nil &&i .Path ==""{return _agbd ,_facb .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");};if i .Format ==""{return _agbd ,_facb .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _agbd ,_facb .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");};_dgca .Images =append (_dgca .Images ,_agbd );return _agbd ,nil ;};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_fgdb *evalContext )GetLabelPrefix (cellRef string )string {return _fgdb ._bada .Cell (cellRef ).getLabelPrefix ();};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_dbde *Sheet )SetDrawing (d Drawing ){var _fdaba _acgc .Relationships ;for _ffde ,_fcaba :=range _dbde ._dg ._fccf {if _fcaba ==_dbde ._eba {_fdaba =_dbde ._dg ._ecff [_ffde ];break ;};};var _dbfb string ;for _bfde ,_dbebd :=range d ._ceg ._ecfd {if _dbebd ==d ._aaba {_ada :=_fdaba .AddAutoRelationship (_cbb .DocTypeSpreadsheet ,_cbb .WorksheetType ,_bfde +1,_cbb .DrawingType );_dbfb =_ada .ID ();break ;};};_dbde ._eba .Drawing =_ecbba .NewCT_Drawing ();_dbde ._eba .Drawing .IdAttr =_dbfb ;};func (_ggaca ConditionalFormattingRule )InitializeDefaults (){_ggaca .SetType (_ecbba .ST_CfTypeCellIs );_ggaca .SetOperator (_ecbba .ST_ConditionalFormattingOperatorGreaterThan );_ggaca .SetPriority (1);};var ErrorNotFound =_facb .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_dfgd Cell )SetStringByID (id int ){_dfgd ._dcd .ensureSharedStringsRelationships ();_dfgd .clearValue ();_dfgd ._aeb .V =_cbb .String (_feff .Itoa (id ));_dfgd ._aeb .TAttr =_ecbba .ST_CellTypeS ;};func (_aaad *Sheet )removeColumnFromNamedRanges (_cbef uint32 )error {for _ ,_cec :=range _aaad ._dg .DefinedNames (){_afaf :=_cec .Name ();_cge :=_cec .Content ();_ebfa :=_eggdf .Split (_cge ,"\u0021");if len (_ebfa )!=2{return _facb .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_cge );};_ffad :=_ebfa [0];if _aaad .Name ()==_ffad {_dgae :=_aaad ._dg .RemoveDefinedName (_cec );if _dgae !=nil {return _dgae ;};_aff :=_cefd (_ebfa [1],_cbef ,true );if _aff !=""{_bbgb :=_ffad +"\u0021"+_aff ;_aaad ._dg .AddDefinedName (_afaf ,_bbgb );};};};_dbdg :=0;if _aaad ._eba .TableParts !=nil &&_aaad ._eba .TableParts .TablePart !=nil {_dbdg =len (_aaad ._eba .TableParts .TablePart );};if _dbdg !=0{_efdb :=0;for _ ,_ggbbd :=range _aaad ._dg .Sheets (){if _ggbbd .Name ()==_aaad .Name (){break ;}else {if _ggbbd ._eba .TableParts !=nil &&_ggbbd ._eba .TableParts .TablePart !=nil {_efdb +=len (_ggbbd ._eba .TableParts .TablePart );};};};_caga :=_aaad ._dg ._dafa [_efdb :_efdb +_dbdg ];for _fgbf ,_ddef :=range _caga {_aaga :=_ddef ;_aaga .RefAttr =_cefd (_aaga .RefAttr ,_cbef ,false );_aaad ._dg ._dafa [_efdb +_fgbf ]=_aaga ;};};return nil ;};func (_eafe *evalContext )Cell (ref string ,ev _cfeg .Evaluator )_cfeg .Result {if !_eacg (ref ){return _cfeg .MakeErrorResultType (_cfeg .ErrorTypeName ,"");};_bbaf :=_eafe ._bada .Name ()+"\u0021"+ref ;if _ceb ,_gfg :=ev .GetFromCache (_bbaf );_gfg {return _ceb ;};_gcbf ,_bgbc :=_cddgb .ParseCellReference (ref );if _bgbc !=nil {return _cfeg .MakeErrorResult (_ddb .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_bgbc ));};if _eafe ._ecace !=0&&!_gcbf .AbsoluteColumn {_gcbf .ColumnIdx +=_eafe ._ecace ;_gcbf .Column =_cddgb .IndexToColumn (_gcbf .ColumnIdx );};if _eafe ._beba !=0&&!_gcbf .AbsoluteRow {_gcbf .RowIdx +=_eafe ._beba ;};_defc :=_eafe ._bada .Cell (_gcbf .String ());if _defc .HasFormula (){if _ ,_ebbc :=_eafe ._cbd [ref ];_ebbc {return _cfeg .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );};_eafe ._cbd [ref ]=struct{}{};_fdad :=ev .Eval (_eafe ,_defc .GetFormula ());delete (_eafe ._cbd ,ref );ev .SetCache (_bbaf ,_fdad );return _fdad ;};if _defc .IsEmpty (){_gcgde :=_cfeg .MakeEmptyResult ();ev .SetCache (_bbaf ,_gcgde );return _gcgde ;}else if _defc .IsNumber (){_bfgd ,_ :=_defc .GetValueAsNumber ();_cdb :=_cfeg .MakeNumberResult (_bfgd );ev .SetCache (_bbaf ,_cdb );return _cdb ;}else if _defc .IsBool (){_ecdg ,_ :=_defc .GetValueAsBool ();_dda :=_cfeg .MakeBoolResult (_ecdg );ev .SetCache (_bbaf ,_dda );return _dda ;};_ccce ,_ :=_defc .GetRawValue ();if _defc .IsError (){_dbbd :=_cfeg .MakeErrorResult ("");_dbbd .ValueString =_ccce ;ev .SetCache (_bbaf ,_dbbd );return _dbbd ;};_eac :=_cfeg .MakeStringResult (_ccce );ev .SetCache (_bbaf ,_eac );return _eac ;};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_affa *_ecbba .CT_DefinedName };func (_aefd DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_aefd .clear ();_aefd ._dcb .TypeAttr =_ecbba .ST_DataValidationType (t );_aefd ._dcb .OperatorAttr =_ecbba .ST_DataValidationOperator (op );return DataValidationCompare {_aefd ._dcb };};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_fgb SheetView )SetState (st _ecbba .ST_PaneState ){_fgb .ensurePane ();_fgb ._fca .Pane .StateAttr =st ;};

// ClearFill clears any fill configuration from the cell style.
func (_agfb CellStyle )ClearFill (){_agfb ._cbc .FillIdAttr =nil ;_agfb ._cbc .ApplyFillAttr =nil };

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_acea CellStyle )SetHorizontalAlignment (a _ecbba .ST_HorizontalAlignment ){if _acea ._cbc .Alignment ==nil {_acea ._cbc .Alignment =_ecbba .NewCT_CellAlignment ();};_acea ._cbc .Alignment .HorizontalAttr =a ;_acea ._cbc .ApplyAlignmentAttr =_cbb .Bool (true );};

// SetNumber sets the cell type to number, and the value to the given number
func (_ccgg Cell )SetNumber (v float64 ){_ccgg .clearValue ();if _gaef .IsNaN (v )||_gaef .IsInf (v ,0){_ccgg ._aeb .TAttr =_ecbba .ST_CellTypeE ;_ccgg ._aeb .V =_cbb .String ("\u0023\u004e\u0055M\u0021");return ;};_ccgg ._aeb .TAttr =_ecbba .ST_CellTypeN ;_ccgg ._aeb .V =_cbb .String (_feff .FormatFloat (v ,'f',-1,64));};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_bbcf :=uint16 (0);if len (s )> 0{for _edgg :=len (s )-1;_edgg >=0;_edgg --{_ggc :=s [_edgg ];_bbcf =((_bbcf >>14)&0x01)|((_bbcf <<1)&0x7fff);_bbcf ^=uint16 (_ggc );};_bbcf =((_bbcf >>14)&0x01)|((_bbcf <<1)&0x7fff);_bbcf ^=uint16 (len (s ));_bbcf ^=(0x8000|('N'<<8)|'K');};return _ddb .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_bbcf ));};func _ece (_cgcc _dbf .Time )_dbf .Time {_cgcc =_cgcc .UTC ();return _dbf .Date (_cgcc .Year (),_cgcc .Month (),_cgcc .Day (),_cgcc .Hour (),_cgcc .Minute (),_cgcc .Second (),_cgcc .Nanosecond (),_dbf .Local );};

// LockWindow controls the locking of the workbook windows.
func (_eeac WorkbookProtection )LockWindow (b bool ){if !b {_eeac ._aab .LockWindowsAttr =nil ;}else {_eeac ._aab .LockWindowsAttr =_cbb .Bool (true );};};func (_gfef *evalContext )Sheet (name string )_cfeg .Context {for _ ,_gga :=range _gfef ._bada ._dg .Sheets (){if _gga .Name ()==name {return _gga .FormulaContext ();};};return _cfeg .InvalidReferenceContext ;};type PatternFill struct{_afdb *_ecbba .CT_PatternFill ;_dbafc *_ecbba .CT_Fill ;};func (_ggdgd DifferentialStyle )Fill ()Fill {if _ggdgd ._bea .Fill ==nil {_ggdgd ._bea .Fill =_ecbba .NewCT_Fill ();};return Fill {_ggdgd ._bea .Fill ,nil };};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_eda *Sheet )Cell (cellRef string )Cell {_dcf ,_fe :=_cddgb .ParseCellReference (cellRef );if _fe !=nil {_cbb .Log ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_fe );return _eda .AddRow ().AddCell ();};return _eda .Row (_dcf .RowIdx ).Cell (_dcf .Column );};

// SetXSplit sets the column split point
func (_bacd SheetView )SetXSplit (v float64 ){_bacd .ensurePane ();_bacd ._fca .Pane .XSplitAttr =_cbb .Float64 (v );};func (_dcg Sheet )validateMergedCells ()error {_bdff :=map[uint64 ]struct{}{};for _ ,_ddee :=range _dcg .MergedCells (){_abgd ,_adaf ,_geda :=_cddgb .ParseRangeReference (_ddee .Reference ());if _geda !=nil {return _ddb .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_dcg .Name (),_ddee .Reference ());};for _fadg :=_abgd .RowIdx ;_fadg <=_adaf .RowIdx ;_fadg ++{for _cfgf :=_abgd .ColumnIdx ;_cfgf <=_adaf .ColumnIdx ;_cfgf ++{_bcfd :=uint64 (_fadg )<<32|uint64 (_cfgf );if _ ,_eecg :=_bdff [_bcfd ];_eecg {return _ddb .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_dcg .Name ());};_bdff [_bcfd ]=struct{}{};};};};return nil ;};func (_degc StyleSheet )GetCellStyle (id uint32 )CellStyle {for _bege ,_bga :=range _degc ._cag .CellXfs .Xf {if uint32 (_bege )==id {return CellStyle {_degc ._bdf ,_bga ,_degc ._cag .CellXfs };};};return CellStyle {};};

// SetColOffset sets the column offset of the two cell anchor.
func (_bdgcb TwoCellAnchor )SetColOffset (m _gebcd .Distance ){_dbgb :=m -_bdgcb .TopLeft ().ColOffset ();_bdgcb .TopLeft ().SetColOffset (m );_bdgcb .BottomRight ().SetColOffset (_bdgcb .BottomRight ().ColOffset ()+_dbgb );};

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_acdc Row )Cells ()[]Cell {_cgbc :=[]Cell {};_cdgf :=-1;for _ ,_adb :=range _acdc ._eaeb .C {if _adb .RAttr ==nil {_cbb .Log ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_dag ,_eae :=_cddgb .ParseCellReference (*_adb .RAttr );if _eae !=nil {_cbb .Log ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_adb .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_gadb :=int (_dag .ColumnIdx );if _gadb -_cdgf > 1{for _gcdg :=_cdgf +1;_gcdg < _gadb ;_gcdg ++{_cgbc =append (_cgbc ,_acdc .Cell (_cddgb .IndexToColumn (uint32 (_gcdg ))));};};_cdgf =_gadb ;_cgbc =append (_cgbc ,Cell {_acdc ._ggfg ,_acdc ._faag ,_acdc ._eaeb ,_adb });};return _cgbc ;};

// SetCol set the column of the cell marker.
func (_fadf CellMarker )SetCol (col int32 ){_fadf ._ecdbe .Col =col };func (_feab PatternFill )SetBgColor (c _gacd .Color ){_feab ._afdb .BgColor =_ecbba .NewCT_Color ();_feab ._afdb .BgColor .RgbAttr =c .AsRGBAString ();};type DifferentialStyle struct{_bea *_ecbba .CT_Dxf ;_ecad *Workbook ;_gf *_ecbba .CT_Dxfs ;};func (_bdg Sheet )IsValid ()bool {return _bdg ._eba !=nil };

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_ccg *Sheet )Column (idx uint32 )Column {for _ ,_bfcg :=range _ccg ._eba .Cols {for _ ,_bdcd :=range _bfcg .Col {if idx >=_bdcd .MinAttr &&idx <=_bdcd .MaxAttr {return Column {_bdcd };};};};var _egbg *_ecbba .CT_Cols ;if len (_ccg ._eba .Cols )==0{_egbg =_ecbba .NewCT_Cols ();_ccg ._eba .Cols =append (_ccg ._eba .Cols ,_egbg );}else {_egbg =_ccg ._eba .Cols [0];};_eggf :=_ecbba .NewCT_Col ();_eggf .MinAttr =idx ;_eggf .MaxAttr =idx ;_egbg .Col =append (_egbg .Col ,_eggf );return Column {_eggf };};

// SetOperator sets the operator for the rule.
func (_eab ConditionalFormattingRule )SetOperator (t _ecbba .ST_ConditionalFormattingOperator ){_eab ._gacg .OperatorAttr =t ;};

// Validate attempts to validate the structure of a workbook.
func (_dfce *Workbook )Validate ()error {if _dfce ==nil ||_dfce ._bcf ==nil {return _facb .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");};_dbac :=uint32 (0);for _ ,_daf :=range _dfce ._bcf .Sheets .Sheet {if _daf .SheetIdAttr > _dbac {_dbac =_daf .SheetIdAttr ;};};if _dbac !=uint32 (len (_dfce ._fccf )){return _ddb .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_dbac ,len (_dfce ._fccf ));};_dfec :=map[string ]struct{}{};for _bcff ,_dcgf :=range _dfce ._bcf .Sheets .Sheet {_ebfg :=Sheet {_dfce ,_dcgf ,_dfce ._fccf [_bcff ]};if _ ,_dae :=_dfec [_ebfg .Name ()];_dae {return _ddb .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_bcff ,_ebfg .Name ());};_dfec [_ebfg .Name ()]=struct{}{};if _gccd :=_ebfg .ValidateWithPath (_ddb .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_bcff ));_gccd !=nil {return _gccd ;};if _gbe :=_ebfg .Validate ();_gbe !=nil {return _gbe ;};};return nil ;};

// SetRotation configures the cell to be rotated.
func (_fda CellStyle )SetRotation (deg uint8 ){if _fda ._cbc .Alignment ==nil {_fda ._cbc .Alignment =_ecbba .NewCT_CellAlignment ();};_fda ._cbc .ApplyAlignmentAttr =_cbb .Bool (true );_fda ._cbc .Alignment .TextRotationAttr =_cbb .Uint8 (deg );};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_bgc Cell )GetValueAsTime ()(_dbf .Time ,error ){if _bgc ._aeb .TAttr !=_ecbba .ST_CellTypeUnset {return _dbf .Time {},_facb .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");};if _bgc ._aeb .V ==nil {return _dbf .Time {},_facb .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_edda ,_ ,_cecg :=_facf .ParseFloat (*_bgc ._aeb .V ,10,128,_facf .ToNearestEven );if _cecg !=nil {return _dbf .Time {},_cecg ;};_gbfd :=new (_facf .Float );_gbfd .SetUint64 (uint64 (24*_dbf .Hour ));_edda .Mul (_edda ,_gbfd );_aeed ,_ :=_edda .Uint64 ();_ebgf :=_bgc ._dcd .Epoch ().Add (_dbf .Duration (_aeed ));return _ece (_ebgf ),nil ;};

// Type returns the type of anchor
func (_gg AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_ccff :=NumberFormat {_dcff :_ecbba .NewCT_NumFmt ()};_ccff ._dcff .NumFmtIdAttr =uint32 (id );_ccff ._dcff .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_ccff ._dcff .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_ccff ._dcff .FormatCodeAttr ="\u0030";case StandardFormat2 :_ccff ._dcff .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_ccff ._dcff .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_ccff ._dcff .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_ccff ._dcff .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_ccff ._dcff .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_ccff ._dcff .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";case StandardFormat12 :_ccff ._dcff .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_ccff ._dcff .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_ccff ._dcff .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";case StandardFormat15 :_ccff ._dcff .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_ccff ._dcff .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_ccff ._dcff .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat18 :_ccff ._dcff .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_ccff ._dcff .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_ccff ._dcff .FormatCodeAttr ="\u0068\u003a\u006d\u006d";case StandardFormat21 :_ccff ._dcff .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_ccff ._dcff .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_ccff ._dcff .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";case StandardFormat38 :_ccff ._dcff .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_ccff ._dcff .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat40 :_ccff ._dcff .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_ccff ._dcff .FormatCodeAttr ="\u006d\u006d\u003as\u0073";case StandardFormat46 :_ccff ._dcff .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_ccff ._dcff .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_ccff ._dcff .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";case StandardFormat49 :_ccff ._dcff .FormatCodeAttr ="\u0040";};return _ccff ;};

// X returns the inner wrapped XML type.
func (_beef ColorScale )X ()*_ecbba .CT_ColorScale {return _beef ._efdfg };

// X returns the inner wrapped XML type.
func (_gbcef DefinedName )X ()*_ecbba .CT_DefinedName {return _gbcef ._affa };

// X returns the inner wrapped XML type.
func (_ccf DataBarScale )X ()*_ecbba .CT_DataBar {return _ccf ._accbg };

// GetFormat sets the number format code.
func (_gdbg NumberFormat )GetFormat ()string {return _gdbg ._dcff .FormatCodeAttr };func (_eace *Sheet )setArray (_dfb string ,_gbfb _cfeg .Result )error {_adde ,_agba :=_cddgb .ParseCellReference (_dfb );if _agba !=nil {return _agba ;};for _ddac ,_dbdd :=range _gbfb .ValueArray {_efff :=_eace .Row (_adde .RowIdx +uint32 (_ddac ));for _cgdc ,_eafeb :=range _dbdd {_ebfae :=_efff .Cell (_cddgb .IndexToColumn (_adde .ColumnIdx +uint32 (_cgdc )));if _eafeb .Type !=_cfeg .ResultTypeEmpty {if _eafeb .IsBoolean {_ebfae .SetBool (_eafeb .ValueNumber !=0);}else {_ebfae .SetCachedFormulaResult (_eafeb .String ());};};};};return nil ;};func (_fdf CellStyle )Index ()uint32 {for _efdc ,_fffe :=range _fdf ._b .Xf {if _fdf ._cbc ==_fffe {return uint32 (_efdc );};};return 0;};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_ddgd DataValidation )SetRange (cellRange string ){_ddgd ._dcb .SqrefAttr =_ecbba .ST_Sqref {cellRange };};

// RemoveSheet removes the sheet with the given index from the workbook.
func (_ecb *Workbook )RemoveSheet (ind int )error {if _ecb .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_dgcf :=range _ecb ._feed .Relationships (){if _dgcf .ID ()==_ecb ._bcf .Sheets .Sheet [ind ].IdAttr {_ecb ._feed .Remove (_dgcf );break ;};};_ecb .ContentTypes .RemoveOverride (_cbb .AbsoluteFilename (_cbb .DocTypeSpreadsheet ,_cbb .WorksheetContentType ,ind +1));copy (_ecb ._fccf [ind :],_ecb ._fccf [ind +1:]);_ecb ._fccf =_ecb ._fccf [:len (_ecb ._fccf )-1];_dfcga :=_ecb ._bcf .Sheets .Sheet [ind ];copy (_ecb ._bcf .Sheets .Sheet [ind :],_ecb ._bcf .Sheets .Sheet [ind +1:]);_ecb ._bcf .Sheets .Sheet =_ecb ._bcf .Sheets .Sheet [:len (_ecb ._bcf .Sheets .Sheet )-1];for _edd :=range _ecb ._bcf .Sheets .Sheet {if _ecb ._bcf .Sheets .Sheet [_edd ].SheetIdAttr > _dfcga .SheetIdAttr {_ecb ._bcf .Sheets .Sheet [_edd ].SheetIdAttr --;};};copy (_ecb ._ecff [ind :],_ecb ._ecff [ind +1:]);_ecb ._ecff =_ecb ._ecff [:len (_ecb ._ecff )-1];copy (_ecb ._efb [ind :],_ecb ._efb [ind +1:]);_ecb ._efb =_ecb ._efb [:len (_ecb ._efb )-1];return nil ;};

// SetHeightCells is a no-op.
func (_fbg AbsoluteAnchor )SetHeightCells (int32 ){};func (_dacc Font )SetSize (size float64 ){_dacc ._afdbd .Sz =[]*_ecbba .CT_FontSize {{ValAttr :size }}};

// LockStructure controls the locking of the workbook structure.
func (_ac WorkbookProtection )LockStructure (b bool ){if !b {_ac ._aab .LockStructureAttr =nil ;}else {_ac ._aab .LockStructureAttr =_cbb .Bool (true );};};func (_cdgc Sheet )validateSheetNames ()error {if len (_cdgc .Name ())> 31{return _ddb .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_cdgc .Name (),len (_cdgc .Name ()));};return nil ;};func (_bffb RichTextRun )ensureRpr (){if _bffb ._gdf .RPr ==nil {_bffb ._gdf .RPr =_ecbba .NewCT_RPrElt ();};};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_fca *_ecbba .CT_SheetView };

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_egcc *_ebgb .CT_OneCellAnchor };

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_efee *Sheet )RemoveColumn (column string )error {_fbfd ,_feb :=_efee .getAllCellsInFormulaArraysForColumn ();if _feb !=nil {return _feb ;};_a :=_cddgb .ColumnToIndex (column );for _ ,_cgffc :=range _efee .Rows (){_ddf :=_ddb .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_cgffc .X ().RAttr );if _ ,_ebffd :=_fbfd [_ddf ];_ebffd {return nil ;};};for _ ,_bfff :=range _efee .Rows (){_bceb :=_bfff ._eaeb .C ;for _cebb ,_deeg :=range _bceb {_eaab ,_cffd :=_cddgb .ParseCellReference (*_deeg .RAttr );if _cffd !=nil {return _cffd ;};if _eaab .ColumnIdx ==_a {_bfff ._eaeb .C =append (_bceb [:_cebb ],_efee .slideCellsLeft (_bceb [_cebb +1:])...);break ;}else if _eaab .ColumnIdx > _a {_bfff ._eaeb .C =append (_bceb [:_cebb ],_efee .slideCellsLeft (_bceb [_cebb :])...);break ;};};};_feb =_efee .updateAfterRemove (_a ,_cfa .UpdateActionRemoveColumn );if _feb !=nil {return _feb ;};_feb =_efee .removeColumnFromNamedRanges (_a );if _feb !=nil {return _feb ;};_feb =_efee .removeColumnFromMergedCells (_a );if _feb !=nil {return _feb ;};for _ ,_dadb :=range _efee ._dg .Sheets (){_dadb .RecalculateFormulas ();};return nil ;};const _dbe ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_cgff *Sheet )FormulaContext ()_cfeg .Context {return _bddf (_cgff )};

// Comments is the container for comments for a single sheet.
type Comments struct{_ecgc *Workbook ;_agfd *_ecbba .Comments ;};

// Index returns the index of the border for use with a cell style.
func (_ccd Border )Index ()uint32 {for _bagf ,_cgf :=range _ccd ._gcba .Border {if _cgf ==_ccd ._gcac {return uint32 (_bagf );};};return 0;};

// ClearProtection removes any protections applied to teh sheet.
func (_dcec *Sheet )ClearProtection (){_dcec ._eba .SheetProtection =nil };

// StyleSheet is a document style sheet.
type StyleSheet struct{_bdf *Workbook ;_cag *_ecbba .StyleSheet ;};func (_efcce *Sheet )getAllCellsInFormulaArrays (_fabb bool )(map[string ]bool ,error ){_af :=_cfeg .NewEvaluator ();_cdde :=_efcce .FormulaContext ();_cfcdf :=map[string ]bool {};for _ ,_deca :=range _efcce .Rows (){for _ ,_edea :=range _deca .Cells (){if _edea .X ().F !=nil {_ace :=_edea .X ().F .Content ;if _edea .X ().F .TAttr ==_ecbba .ST_CellFormulaTypeArray {_ded :=_af .Eval (_cdde ,_ace ).AsString ();if _ded .Type ==_cfeg .ResultTypeError {_cbb .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_ace ,_ded .ErrorMessage );_edea .X ().V =nil ;};if _ded .Type ==_cfeg .ResultTypeArray {_abcb ,_fffef :=_cddgb .ParseCellReference (_edea .Reference ());if _fffef !=nil {return map[string ]bool {},_fffef ;};if (_fabb &&len (_ded .ValueArray )==1)||(!_fabb &&len (_ded .ValueArray [0])==1){continue ;};for _ced ,_dcdc :=range _ded .ValueArray {_ccc :=_abcb .RowIdx +uint32 (_ced );for _dbgbb :=range _dcdc {_cee :=_cddgb .IndexToColumn (_abcb .ColumnIdx +uint32 (_dbgbb ));_cfcdf [_ddb .Sprintf ("\u0025\u0073\u0025\u0064",_cee ,_ccc )]=true ;};};}else if _ded .Type ==_cfeg .ResultTypeList {_eg ,_bgad :=_cddgb .ParseCellReference (_edea .Reference ());if _bgad !=nil {return map[string ]bool {},_bgad ;};if _fabb ||len (_ded .ValueList )==1{continue ;};_ffd :=_eg .RowIdx ;for _fdff :=range _ded .ValueList {_dbaf :=_cddgb .IndexToColumn (_eg .ColumnIdx +uint32 (_fdff ));_cfcdf [_ddb .Sprintf ("\u0025\u0073\u0025\u0064",_dbaf ,_ffd )]=true ;};};};};};};return _cfcdf ,nil ;};func (_fbe Font )Index ()uint32 {for _bega ,_gfe :=range _fbe ._gfcf .Fonts .Font {if _fbe ._afdbd ==_gfe {return uint32 (_bega );};};return 0;};

// AddCell adds a cell to a spreadsheet.
func (_cfc Row )AddCell ()Cell {_bde :=uint32 (len (_cfc ._eaeb .C ));var _bba *string ;if _bde > 0{_bdgb :=_cbb .Stringf ("\u0025\u0073\u0025\u0064",_cddgb .IndexToColumn (_bde -1),_cfc .RowNumber ());if _cfc ._eaeb .C [_bde -1].RAttr !=nil &&*_cfc ._eaeb .C [_bde -1].RAttr ==*_bdgb {_bba =_cbb .Stringf ("\u0025\u0073\u0025\u0064",_cddgb .IndexToColumn (_bde ),_cfc .RowNumber ());};};_dfab :=_ecbba .NewCT_Cell ();_cfc ._eaeb .C =append (_cfc ._eaeb .C ,_dfab );if _bba ==nil {_fdaf :=uint32 (0);for _ ,_bdgf :=range _cfc ._eaeb .C {if _bdgf .RAttr !=nil {_bdd ,_ :=_cddgb .ParseCellReference (*_bdgf .RAttr );if _bdd .ColumnIdx >=_fdaf {_fdaf =_bdd .ColumnIdx +1;};};};_bba =_cbb .Stringf ("\u0025\u0073\u0025\u0064",_cddgb .IndexToColumn (_fdaf ),_cfc .RowNumber ());};_dfab .RAttr =_bba ;return Cell {_cfc ._ggfg ,_cfc ._faag ,_cfc ._eaeb ,_dfab };};

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both gooxml and Excel will always set it.
func (_gfcb Cell )Reference ()string {if _gfcb ._aeb .RAttr !=nil {return *_gfcb ._aeb .RAttr ;};return "";};func (_abfe StandardFormat )String ()string {switch {case 0<=_abfe &&_abfe <=4:return _gff [_affd [_abfe ]:_affd [_abfe +1]];case 9<=_abfe &&_abfe <=22:_abfe -=9;return _fcec [_bdeg [_abfe ]:_bdeg [_abfe +1]];case 37<=_abfe &&_abfe <=40:_abfe -=37;return _add [_ef [_abfe ]:_ef [_abfe +1]];case 45<=_abfe &&_abfe <=49:_abfe -=45;return _ebffc [_fccfe [_abfe ]:_fccfe [_abfe +1]];default:return _ddb .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_abfe );};};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_bce TwoCellAnchor )SetWidthCells (w int32 ){_abeb :=_bce .TopLeft ();_adca :=_bce .BottomRight ();_adca .SetCol (_abeb .Col ()+w );};func (_ddae StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));};for _ ,_adg :=range _ddae ._cag .NumFmts .NumFmt {if _adg .NumFmtIdAttr ==id {return NumberFormat {_ddae ._bdf ,_adg };};};return NumberFormat {};};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_gbab SheetView )SetZoom (pct uint32 ){_gbab ._fca .ZoomScaleAttr =&pct };

// X returns the inner wrapped XML type.
func (_ffgb Comment )X ()*_ecbba .CT_Comment {return _ffgb ._fcccd };

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_fff *Workbook )RemoveCalcChain (){var _bcee string ;for _ ,_afdc :=range _fff ._feed .Relationships (){if _afdc .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_bcee ="\u0078\u006c\u002f"+_afdc .Target ();_fff ._feed .Remove (_afdc );break ;};};if _bcee ==""{return ;};_fff .ContentTypes .RemoveOverride (_bcee );for _ggcf ,_fbcea :=range _fff .ExtraFiles {if _fbcea .ZipPath ==_bcee {_fff .ExtraFiles [_ggcf ]=_fff .ExtraFiles [len (_fff .ExtraFiles )-1];_fff .ExtraFiles =_fff .ExtraFiles [:len (_fff .ExtraFiles )-1];return ;};};};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_cacdc *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_ed :=range _cacdc .Sheets (){if _ed .Name ()==name {return _ed ,nil ;};};return Sheet {},ErrorNotFound ;};

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_afdac Cell )SetFormulaShared (formula string ,rows ,cols uint32 )error {_afdac .clearValue ();_afdac ._aeb .TAttr =_ecbba .ST_CellTypeStr ;_afdac ._aeb .F =_ecbba .NewCT_CellFormula ();_afdac ._aeb .F .TAttr =_ecbba .ST_CellFormulaTypeShared ;_afdac ._aeb .F .Content =formula ;_gefe ,_aad :=_cddgb .ParseCellReference (_afdac .Reference ());if _aad !=nil {return _aad ;};_ebaa :=uint32 (0);for _ ,_egbb :=range _afdac ._aefa .Rows (){for _ ,_bfcbc :=range _egbb ._eaeb .C {if _bfcbc .F !=nil &&_bfcbc .F .SiAttr !=nil &&*_bfcbc .F .SiAttr >=_ebaa {_ebaa =*_bfcbc .F .SiAttr ;};};};_ebaa ++;_ddd :=_ddb .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_gefe .Column ,_gefe .RowIdx ,_cddgb .IndexToColumn (_gefe .ColumnIdx +cols ),_gefe .RowIdx +rows );_afdac ._aeb .F .RefAttr =_cbb .String (_ddd );_afdac ._aeb .F .SiAttr =_cbb .Uint32 (_ebaa );_gaea :=Sheet {_afdac ._dcd ,_afdac ._aefa ._aefde ,_afdac ._aefa ._eba };for _ggbb :=_gefe .RowIdx ;_ggbb <=_gefe .RowIdx +rows ;_ggbb ++{for _gbfe :=_gefe .ColumnIdx ;_gbfe <=_gefe .ColumnIdx +cols ;_gbfe ++{if _ggbb ==_gefe .RowIdx &&_gbfe ==_gefe .ColumnIdx {continue ;};_fcdca :=_ddb .Sprintf ("\u0025\u0073\u0025\u0064",_cddgb .IndexToColumn (_gbfe ),_ggbb );_gaea .Cell (_fcdca ).Clear ();_gaea .Cell (_fcdca ).X ().F =_ecbba .NewCT_CellFormula ();_gaea .Cell (_fcdca ).X ().F .TAttr =_ecbba .ST_CellFormulaTypeShared ;_gaea .Cell (_fcdca ).X ().F .SiAttr =_cbb .Uint32 (_ebaa );};};return nil ;};

// Type returns the type of the rule
func (_gcg ConditionalFormattingRule )Type ()_ecbba .ST_CfType {return _gcg ._gacg .TypeAttr };

// GetValueAsNumber retrieves the cell's value as a number
func (_cgfc Cell )GetValueAsNumber ()(float64 ,error ){if _cgfc ._aeb .V ==nil &&_cgfc ._aeb .Is ==nil {return 0,nil ;};if _cgfc ._aeb .TAttr ==_ecbba .ST_CellTypeS ||!_bcecg .IsNumber (*_cgfc ._aeb .V ){return _gaef .NaN (),_facb .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");};return _feff .ParseFloat (*_cgfc ._aeb .V ,64);};

// BottomRight is a no-op.
func (_gaf OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_dddg CellStyle )NumberFormat ()uint32 {if _dddg ._cbc .NumFmtIdAttr ==nil {return 0;};return *_dddg ._cbc .NumFmtIdAttr ;};

// X returns the inner wrapped XML type.
func (_cfcd *Workbook )X ()*_ecbba .Workbook {return _cfcd ._bcf };

// Rows returns all of the rows in a sheet.
func (_abg *Sheet )Rows ()[]Row {_afda :=[]Row {};for _ ,_cccea :=range _abg ._eba .SheetData .Row {_afda =append (_afda ,Row {_abg ._dg ,_abg ,_cccea });};return _afda ;};

// Protection allows control over the workbook protections.
func (_ca *Workbook )Protection ()WorkbookProtection {if _ca ._bcf .WorkbookProtection ==nil {_ca ._bcf .WorkbookProtection =_ecbba .NewCT_WorkbookProtection ();};return WorkbookProtection {_ca ._bcf .WorkbookProtection };};

// MergedCells returns the merged cell regions within the sheet.
func (_cfdgf *Sheet )MergedCells ()[]MergedCell {if _cfdgf ._eba .MergeCells ==nil {return nil ;};_fcbf :=[]MergedCell {};for _ ,_gcff :=range _cfdgf ._eba .MergeCells .MergeCell {_fcbf =append (_fcbf ,MergedCell {_cfdgf ._dg ,_cfdgf ,_gcff });};return _fcbf ;};

// SortOrder is a column sort order.
//go:generate stringer -type=SortOrder
type SortOrder byte ;

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_dfbb *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _dfbb .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _edfa _acgc .Relationship ;for _ ,_ffec :=range _dfbb ._feed .Relationships (){if _ffec .ID ()==_dfbb ._bcf .Sheets .Sheet [ind ].IdAttr {var _abfgb bool ;if _edfa ,_abfgb =_dfbb ._feed .CopyRelationship (_ffec .ID ());!_abfgb {return Sheet {},ErrorNotFound ;};break ;};};_dfbb .ContentTypes .CopyOverride (_cbb .AbsoluteFilename (_cbb .DocTypeSpreadsheet ,_cbb .WorksheetContentType ,ind +1),_cbb .AbsoluteFilename (_cbb .DocTypeSpreadsheet ,_cbb .WorksheetContentType ,len (_dfbb .ContentTypes .X ().Override )));_dafe :=*_dfbb ._fccf [ind ];_dfbb ._fccf =append (_dfbb ._fccf ,&_dafe );var _eff uint32 =0;for _ ,_bbcbe :=range _dfbb ._bcf .Sheets .Sheet {if _bbcbe .SheetIdAttr > _eff {_eff =_bbcbe .SheetIdAttr ;};};_eff ++;_caag :=*_dfbb ._bcf .Sheets .Sheet [ind ];_caag .IdAttr =_edfa .ID ();_caag .NameAttr =copiedSheetName ;_caag .SheetIdAttr =_eff ;_dfbb ._bcf .Sheets .Sheet =append (_dfbb ._bcf .Sheets .Sheet ,&_caag );_abfg :=_acgc .NewRelationshipsCopy (_dfbb ._ecff [ind ]);_dfbb ._ecff =append (_dfbb ._ecff ,_abfg );_ege :=_dfbb ._efb [ind ];if _ege ==nil {_dfbb ._efb =append (_dfbb ._efb ,nil );}else {_aagda :=*_ege ;_dfbb ._efb =append (_dfbb ._efb ,&_aagda );};_egb :=Sheet {_dfbb ,&_caag ,&_dafe };return _egb ,nil ;};func _ebaf ()*_ebgb .CT_AbsoluteAnchor {_gacge :=_ebgb .NewCT_AbsoluteAnchor ();return _gacge };type MergedCell struct{_fgae *Workbook ;_ddg *Sheet ;_bb *_ecbba .CT_MergeCell ;};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_acgf *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_aggg :=-1;for _edab ,_bdae :=range _acgf .Sheets (){if name ==_bdae .Name (){_aggg =_edab ;break ;};};if _aggg ==-1{return Sheet {},ErrorNotFound ;};return _acgf .CopySheet (_aggg ,copiedSheetName );};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_bbda *Sheet )RemoveMergedCell (mc MergedCell ){for _c ,_dada :=range _bbda ._eba .MergeCells .MergeCell {if _dada ==mc .X (){copy (_bbda ._eba .MergeCells .MergeCell [_c :],_bbda ._eba .MergeCells .MergeCell [_c +1:]);_bbda ._eba .MergeCells .MergeCell [len (_bbda ._eba .MergeCells .MergeCell )-1]=nil ;_bbda ._eba .MergeCells .MergeCell =_bbda ._eba .MergeCells .MergeCell [:len (_bbda ._eba .MergeCells .MergeCell )-1];};};};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_eddf Comment )SetCellReference (cellRef string ){_eddf ._fcccd .RefAttr =cellRef };

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;var _egcd []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};

// SetTopLeft sets the top left visible cell after the split.
func (_ccbc SheetView )SetTopLeft (cellRef string ){_ccbc .ensurePane ();_ccbc ._fca .Pane .TopLeftCellAttr =&cellRef ;};

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_aagd DataValidationList )SetRange (cellRange string ){_aagd ._bdbc .Formula1 =_cbb .String (cellRange );_aagd ._bdbc .Formula2 =_cbb .String ("\u0030");};func (_dcbc Border )SetRight (style _ecbba .ST_BorderStyle ,c _gacd .Color ){if _dcbc ._gcac .Right ==nil {_dcbc ._gcac .Right =_ecbba .NewCT_BorderPr ();};_dcbc ._gcac .Right .Color =_ecbba .NewCT_Color ();_dcbc ._gcac .Right .Color .RgbAttr =c .AsRGBAString ();_dcbc ._gcac .Right .StyleAttr =style ;};

// SetMinLength sets the minimum bar length in percent.
func (_defd DataBarScale )SetMinLength (l uint32 ){_defd ._accbg .MinLengthAttr =_cbb .Uint32 (l )};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_abbe *Sheet )ClearSheetViews (){_abbe ._eba .SheetViews =nil };

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_fbff DataValidationCompare )SetValue (v string ){_fbff ._fffc .Formula1 =&v };

// SetShowValue controls if the cell value is displayed.
func (_dfdb DataBarScale )SetShowValue (b bool ){_dfdb ._accbg .ShowValueAttr =_cbb .Bool (b )};

// SetMaxLength sets the maximum bar length in percent.
func (_bgag DataBarScale )SetMaxLength (l uint32 ){_bgag ._accbg .MaxLengthAttr =_cbb .Uint32 (l )};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As gooxml formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_cfd *Sheet )RecalculateFormulas (){_ffddf :=_cfeg .NewEvaluator ();_efcc :=_cfd .FormulaContext ();for _ ,_abfb :=range _cfd .Rows (){for _ ,_gebg :=range _abfb .Cells (){if _gebg .X ().F !=nil {_eeff :=_gebg .X ().F .Content ;if _gebg .X ().F .TAttr ==_ecbba .ST_CellFormulaTypeShared &&len (_eeff )==0{continue ;};_fgcg :=_ffddf .Eval (_efcc ,_eeff ).AsString ();if _fgcg .Type ==_cfeg .ResultTypeError {_cbb .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_eeff ,_fgcg .ErrorMessage );_gebg .X ().V =nil ;}else {if _fgcg .Type ==_cfeg .ResultTypeNumber {_gebg .X ().TAttr =_ecbba .ST_CellTypeN ;}else {_gebg .X ().TAttr =_ecbba .ST_CellTypeInlineStr ;};_gebg .X ().V =_cbb .String (_fgcg .Value ());if _gebg .X ().F .TAttr ==_ecbba .ST_CellFormulaTypeArray {if _fgcg .Type ==_cfeg .ResultTypeArray {_cfd .setArray (_gebg .Reference (),_fgcg );}else if _fgcg .Type ==_cfeg .ResultTypeList {_cfd .setList (_gebg .Reference (),_fgcg );};}else if _gebg .X ().F .TAttr ==_ecbba .ST_CellFormulaTypeShared &&_gebg .X ().F .RefAttr !=nil {_aea ,_bdgd ,_ffed :=_cddgb .ParseRangeReference (*_gebg .X ().F .RefAttr );if _ffed !=nil {_febd .Printf ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_ffed );continue ;};_cfd .setShared (_gebg .Reference (),_aea ,_bdgd ,_eeff );};};};};};};

// Content returns the content of the defined range (the range in most cases)/
func (_efdf DefinedName )Content ()string {return _efdf ._affa .Content };

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_bbcb *Workbook )SetActiveSheetIndex (idx uint32 ){if _bbcb ._bcf .BookViews ==nil {_bbcb ._bcf .BookViews =_ecbba .NewCT_BookViews ();};if len (_bbcb ._bcf .BookViews .WorkbookView )==0{_bbcb ._bcf .BookViews .WorkbookView =append (_bbcb ._bcf .BookViews .WorkbookView ,_ecbba .NewCT_BookView ());};_bbcb ._bcf .BookViews .WorkbookView [0].ActiveTabAttr =_cbb .Uint32 (idx );};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_efdfg *_ecbba .CT_ColorScale };type evalContext struct{_bada *Sheet ;_ecace ,_beba uint32 ;_cbd map[string ]struct{};};

// X returns the inner wrapped XML type.
func (_dafb SharedStrings )X ()*_ecbba .Sst {return _dafb ._agfe };

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_afcd Cell )SetString (s string )int {_afcd ._dcd .ensureSharedStringsRelationships ();_afcd .clearValue ();_ffa :=_afcd ._dcd .SharedStrings .AddString (s );_afcd ._aeb .V =_cbb .String (_feff .Itoa (_ffa ));_afcd ._aeb .TAttr =_ecbba .ST_CellTypeS ;return _ffa ;};

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_agga *Sheet )InitialView ()SheetView {if _agga ._eba .SheetViews ==nil ||len (_agga ._eba .SheetViews .SheetView )==0{return _agga .AddView ();};return SheetView {_agga ._eba .SheetViews .SheetView [0]};};

// CellStyles returns the list of defined cell styles
func (_gdc StyleSheet )CellStyles ()[]CellStyle {_aef :=[]CellStyle {};for _ ,_abgee :=range _gdc ._cag .CellXfs .Xf {_aef =append (_aef ,CellStyle {_gdc ._bdf ,_abgee ,_gdc ._cag .CellXfs });};return _aef ;};

// SetColor sets teh color of the databar.
func (_egfc DataBarScale )SetColor (c _gacd .Color ){_egfc ._accbg .Color =_ecbba .NewCT_Color ();_egfc ._accbg .Color .RgbAttr =c .AsRGBAString ();};type Table struct{_ggd *_ecbba .Table };

// SetColOffset sets a column offset in absolute distance.
func (_eag CellMarker )SetColOffset (m _gebcd .Distance ){_eag ._ecdbe .ColOff .ST_CoordinateUnqualified =_cbb .Int64 (int64 (m /_gebcd .EMU ));};

// SetHyperlink sets a hyperlink on a cell.
func (_acae Cell )SetHyperlink (hl _acgc .Hyperlink ){_addg :=_acae ._aefa ._eba ;if _addg .Hyperlinks ==nil {_addg .Hyperlinks =_ecbba .NewCT_Hyperlinks ();};_gecb :=_acgc .Relationship (hl );_fcbe :=_ecbba .NewCT_Hyperlink ();_fcbe .RefAttr =_acae .Reference ();_fcbe .IdAttr =_cbb .String (_gecb .ID ());_addg .Hyperlinks .Hyperlink =append (_addg .Hyperlinks .Hyperlink ,_fcbe );};

// AddSheet adds a new sheet to a workbook.
func (_baa *Workbook )AddSheet ()Sheet {_gfgc :=_ecbba .NewCT_Sheet ();_gfgc .SheetIdAttr =1;for _ ,_dfcg :=range _baa ._bcf .Sheets .Sheet {if _gfgc .SheetIdAttr <=_dfcg .SheetIdAttr {_gfgc .SheetIdAttr =_dfcg .SheetIdAttr +1;};};_baa ._bcf .Sheets .Sheet =append (_baa ._bcf .Sheets .Sheet ,_gfgc );_gfgc .NameAttr =_ddb .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_gfgc .SheetIdAttr );_bdb :=_ecbba .NewWorksheet ();_bdb .Dimension =_ecbba .NewCT_SheetDimension ();_bdb .Dimension .RefAttr ="\u0041\u0031";_baa ._fccf =append (_baa ._fccf ,_bdb );_gbee :=_acgc .NewRelationships ();_baa ._ecff =append (_baa ._ecff ,_gbee );_bdb .SheetData =_ecbba .NewCT_SheetData ();_baa ._efb =append (_baa ._efb ,nil );_cdd :=_cbb .DocTypeSpreadsheet ;_gcc :=_baa ._feed .AddAutoRelationship (_cdd ,_cbb .OfficeDocumentType ,len (_baa ._bcf .Sheets .Sheet ),_cbb .WorksheetType );_gfgc .IdAttr =_gcc .ID ();_baa .ContentTypes .AddOverride (_cbb .AbsoluteFilename (_cdd ,_cbb .WorksheetContentType ,len (_baa ._bcf .Sheets .Sheet )),_cbb .WorksheetContentType );return Sheet {_baa ,_gfgc ,_bdb };};

// SetYSplit sets the row split point
func (_ccaf SheetView )SetYSplit (v float64 ){_ccaf .ensurePane ();_ccaf ._fca .Pane .YSplitAttr =_cbb .Float64 (v );};

// Priority returns the rule priority
func (_dbg ConditionalFormattingRule )Priority ()int32 {return _dbg ._gacg .PriorityAttr };

// X returns the inner wrapped XML type.
func (_abbb RichTextRun )X ()*_ecbba .CT_RElt {return _abbb ._gdf };

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_ecfc AbsoluteAnchor )SetRowOffset (m _gebcd .Distance ){_ecfc ._cdg .Pos .YAttr .ST_CoordinateUnqualified =_cbb .Int64 (int64 (m /_gebcd .EMU ));};

// ClearProtection clears all workbook protections.
func (_caab *Workbook )ClearProtection (){_caab ._bcf .WorkbookProtection =nil };func (_ea Font )SetItalic (b bool ){if b {_ea ._afdbd .I =[]*_ecbba .CT_BooleanProperty {{}};}else {_ea ._afdbd .I =nil ;};};func (_bec Border )SetDiagonal (style _ecbba .ST_BorderStyle ,c _gacd .Color ,up ,down bool ){if _bec ._gcac .Diagonal ==nil {_bec ._gcac .Diagonal =_ecbba .NewCT_BorderPr ();};_bec ._gcac .Diagonal .Color =_ecbba .NewCT_Color ();_bec ._gcac .Diagonal .Color .RgbAttr =c .AsRGBAString ();_bec ._gcac .Diagonal .StyleAttr =style ;if up {_bec ._gcac .DiagonalUpAttr =_cbb .Bool (true );};if down {_bec ._gcac .DiagonalDownAttr =_cbb .Bool (true );};};

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_age NumberFormat )ID ()uint32 {return _age ._dcff .NumFmtIdAttr };

// IconScale maps values to icons.
type IconScale struct{_bacg *_ecbba .CT_IconSet };

// Comments returns the comments for a sheet.
func (_gaad *Sheet )Comments ()Comments {for _afc ,_fga :=range _gaad ._dg ._fccf {if _fga ==_gaad ._eba {if _gaad ._dg ._efb [_afc ]==nil {_gaad ._dg ._efb [_afc ]=_ecbba .NewComments ();_gaad ._dg ._ecff [_afc ].AddAutoRelationship (_cbb .DocTypeSpreadsheet ,_cbb .WorksheetType ,_afc +1,_cbb .CommentsType );_gaad ._dg .ContentTypes .AddOverride (_cbb .AbsoluteFilename (_cbb .DocTypeSpreadsheet ,_cbb .CommentsType ,_afc +1),_cbb .CommentsContentType );};if len (_gaad ._dg ._cdeg )==0{_gaad ._dg ._cdeg =append (_gaad ._dg ._cdeg ,_gffd .NewCommentDrawing ());_fage :=_gaad ._dg ._ecff [_afc ].AddAutoRelationship (_cbb .DocTypeSpreadsheet ,_cbb .WorksheetType ,1,_cbb .VMLDrawingType );if _gaad ._eba .LegacyDrawing ==nil {_gaad ._eba .LegacyDrawing =_ecbba .NewCT_LegacyDrawing ();};_gaad ._eba .LegacyDrawing .IdAttr =_fage .ID ();};return Comments {_gaad ._dg ,_gaad ._dg ._efb [_afc ]};};};_cbb .Log ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");return Comments {};};

// SetStyle sets the cell style for an entire column.
func (_fccd Column )SetStyle (cs CellStyle ){_fccd ._ccfa .StyleAttr =_cbb .Uint32 (cs .Index ())};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_cgc *Workbook )ClearCachedFormulaResults (){for _ ,_affad :=range _cgc .Sheets (){_affad .ClearCachedFormulaResults ();};};func (_beg Font )SetName (name string ){_beg ._afdbd .Name =[]*_ecbba .CT_FontName {{ValAttr :name }}};

// SetPasswordHash sets the password hash to the input.
func (_aagc WorkbookProtection )SetPasswordHash (pwHash string ){_aagc ._aab .WorkbookPasswordAttr =_cbb .String (pwHash );};

// SetWidth is a no-op.
func (_efbe TwoCellAnchor )SetWidth (w _gebcd .Distance ){};

// Col returns the column of the cell marker.
func (_cbda CellMarker )Col ()int32 {return _cbda ._ecdbe .Col };

// SetDateWithStyle sets a date with the default date style applied.
func (_gdea Cell )SetDateWithStyle (d _dbf .Time ){_gdea .SetDate (d );for _ ,_gfag :=range _gdea ._dcd .StyleSheet .CellStyles (){if _gfag .HasNumberFormat ()&&_gfag .NumberFormat ()==uint32 (StandardFormatDate ){_gdea .SetStyle (_gfag );return ;};};_bdbg :=_gdea ._dcd .StyleSheet .AddCellStyle ();_bdbg .SetNumberFormatStandard (StandardFormatDate );_gdea .SetStyle (_bdbg );};

// AnchorType is the type of anchor.
type AnchorType byte ;

// IsStructureLocked returns whether the workbook structure is locked.
func (_dgdf WorkbookProtection )IsStructureLocked ()bool {return _dgdf ._aab .LockStructureAttr !=nil &&*_dgdf ._aab .LockStructureAttr ;};

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_dcc ConditionalFormattingRule )SetIcons ()IconScale {_dcc .clear ();_dcc .SetType (_ecbba .ST_CfTypeIconSet );_dcc ._gacg .IconSet =_ecbba .NewCT_IconSet ();_gcdb :=IconScale {_dcc ._gacg .IconSet };_gcdb .SetIcons (_ecbba .ST_IconSetType3TrafficLights1 );return _gcdb ;};

// IsEmpty returns true if the cell is empty.
func (_eegd Cell )IsEmpty ()bool {return _eegd ._aeb .TAttr ==_ecbba .ST_CellTypeUnset &&_eegd ._aeb .V ==nil &&_eegd ._aeb .F ==nil ;};

// SetIcons sets the icon set to use for display.
func (_babc IconScale )SetIcons (t _ecbba .ST_IconSetType ){_babc ._bacg .IconSetAttr =t };

// IsBool returns true if the cell is a boolean type cell.
func (_febc Cell )IsBool ()bool {return _febc ._aeb .TAttr ==_ecbba .ST_CellTypeB };

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_agfe :_ecbba .NewSst (),_acg :make (map[string ]int )};};

// SetWidthCells is a no-op.
func (_bfb AbsoluteAnchor )SetWidthCells (int32 ){};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_acgc .DocBase ;_bcf *_ecbba .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_efb []*_ecbba .Comments ;_fccf []*_ecbba .Worksheet ;_ecff []_acgc .Relationships ;_feed _acgc .Relationships ;_egeg []*_cgb .Theme ;_ecfd []*_ebgb .WsDr ;_agg []_acgc .Relationships ;_cdeg []*_gffd .Container ;_abbff []*_acd .ChartSpace ;_dafa []*_ecbba .Table ;_abgff string ;};

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_dgce Cell )GetFormattedValue ()string {_bda :=_dgce .getFormat ();switch _dgce ._aeb .TAttr {case _ecbba .ST_CellTypeB :_dcaf ,_ :=_dgce .GetValueAsBool ();if _dcaf {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _ecbba .ST_CellTypeN :_decg ,_ :=_dgce .GetValueAsNumber ();return _bcecg .Number (_decg ,_bda );case _ecbba .ST_CellTypeE :if _dgce ._aeb .V !=nil {return *_dgce ._aeb .V ;};return "";case _ecbba .ST_CellTypeS ,_ecbba .ST_CellTypeInlineStr :return _bcecg .String (_dgce .GetString (),_bda );case _ecbba .ST_CellTypeStr :_gdcb :=_dgce .GetString ();if _bcecg .IsNumber (_gdcb ){_eacbe ,_ :=_feff .ParseFloat (_gdcb ,64);return _bcecg .Number (_eacbe ,_bda );};return _bcecg .String (_gdcb ,_bda );case _ecbba .ST_CellTypeUnset :fallthrough;default:_gfca ,_ :=_dgce .GetRawValue ();if len (_gfca )==0{return "";};_bead ,_gbd :=_dgce .GetValueAsNumber ();if _gbd ==nil {return _bcecg .Number (_bead ,_bda );};return _bcecg .String (_gfca ,_bda );};};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_ffaf :=_ecbba .NewStyleSheet ();_ffaf .CellStyleXfs =_ecbba .NewCT_CellStyleXfs ();_ffaf .CellXfs =_ecbba .NewCT_CellXfs ();_ffaf .CellStyles =_ecbba .NewCT_CellStyles ();_fdg :=_ecbba .NewCT_CellStyle ();_fdg .NameAttr =_cbb .String ("\u004e\u006f\u0072\u006d\u0061\u006c");_fdg .XfIdAttr =0;_fdg .BuiltinIdAttr =_cbb .Uint32 (0);_ffaf .CellStyles .CellStyle =append (_ffaf .CellStyles .CellStyle ,_fdg );_ffaf .CellStyles .CountAttr =_cbb .Uint32 (uint32 (len (_ffaf .CellStyles .CellStyle )));_eedd :=_ecbba .NewCT_Xf ();_eedd .NumFmtIdAttr =_cbb .Uint32 (0);_eedd .FontIdAttr =_cbb .Uint32 (0);_eedd .FillIdAttr =_cbb .Uint32 (0);_eedd .BorderIdAttr =_cbb .Uint32 (0);_ffaf .CellStyleXfs .Xf =append (_ffaf .CellStyleXfs .Xf ,_eedd );_ffaf .CellStyleXfs .CountAttr =_cbb .Uint32 (uint32 (len (_ffaf .CellStyleXfs .Xf )));_cgagd :=NewFills ();_ffaf .Fills =_cgagd .X ();_ccbg :=_cgagd .AddFill ().SetPatternFill ();_ccbg .SetPattern (_ecbba .ST_PatternTypeNone );_ccbg =_cgagd .AddFill ().SetPatternFill ();_ccbg .SetPattern (_ecbba .ST_PatternTypeGray125 );_ffaf .Fonts =_ecbba .NewCT_Fonts ();_ffaf .Borders =_ecbba .NewCT_Borders ();_cffg :=StyleSheet {wb ,_ffaf };_cffg .AddBorder ().InitializeDefaults ();_fefa :=_cffg .AddFont ();_fefa .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_fefa .SetSize (11);_bdgc :=_ecbba .NewCT_Xf ();*_bdgc =*_eedd ;_bdgc .XfIdAttr =_cbb .Uint32 (0);_ffaf .CellXfs .Xf =append (_ffaf .CellXfs .Xf ,_bdgc );_ffaf .CellXfs .CountAttr =_cbb .Uint32 (uint32 (len (_ffaf .CellXfs .Xf )));return _cffg ;};func (_cdf Border )SetBottom (style _ecbba .ST_BorderStyle ,c _gacd .Color ){if _cdf ._gcac .Bottom ==nil {_cdf ._gcac .Bottom =_ecbba .NewCT_BorderPr ();};_cdf ._gcac .Bottom .Color =_ecbba .NewCT_Color ();_cdf ._gcac .Bottom .Color .RgbAttr =c .AsRGBAString ();_cdf ._gcac .Bottom .StyleAttr =style ;};

// RowOffset returns the offset from the row cell.
func (_aee CellMarker )RowOffset ()_gebcd .Distance {if _aee ._ecdbe .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _gebcd .Distance (float64 (*_aee ._ecdbe .RowOff .ST_CoordinateUnqualified )*_gebcd .EMU );};

// SetWrapped configures the cell to wrap text.
func (_gec CellStyle )SetWrapped (b bool ){if _gec ._cbc .Alignment ==nil {_gec ._cbc .Alignment =_ecbba .NewCT_CellAlignment ();};if !b {_gec ._cbc .Alignment .WrapTextAttr =nil ;}else {_gec ._cbc .Alignment .WrapTextAttr =_cbb .Bool (true );_gec ._cbc .ApplyAlignmentAttr =_cbb .Bool (true );};};

// SetLocked sets cell locked or not.
func (_ged *evalContext )SetLocked (cellRef string ,locked bool ){_ged ._bada .Cell (cellRef ).setLocked (locked );};

// Clear clears the cell's value and type.
func (_fgff Cell )Clear (){_fgff .clearValue ();_fgff ._aeb .TAttr =_ecbba .ST_CellTypeUnset };

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_bdcg StyleSheet )Fills ()Fills {return Fills {_bdcg ._cag .Fills }};

// X returns the inner wrapped XML type.
func (_bfag Sheet )X ()*_ecbba .Worksheet {return _bfag ._eba };

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_gbc *evalContext )LastColumn (rowFrom ,rowTo int )string {_abc :=_gbc ._bada ;_fac :=1;for _cde :=rowFrom ;_cde <=rowTo ;_cde ++{_eeb :=len (_abc .Row (uint32 (_cde )).Cells ());if _eeb > _fac {_fac =_eeb ;};};return _cddgb .IndexToColumn (uint32 (_fac -1));};var _fae =_cbb .AbsoluteFilename (_cbb .DocTypeSpreadsheet ,_cbb .SharedStringsType ,0);type Fill struct{_bab *_ecbba .CT_Fill ;_bca *_ecbba .CT_Fills ;};

// SetFill applies a fill to a cell style.  The fill is referenced by its index
// so modifying the fill afterward will affect all styles that reference it.
func (_ffdd CellStyle )SetFill (f Fill ){_ffdd ._cbc .FillIdAttr =_cbb .Uint32 (f .Index ());_ffdd ._cbc .ApplyFillAttr =_cbb .Bool (true );};

// SetPasswordHash sets the password hash to the input.
func (_dec SheetProtection )SetPasswordHash (pwHash string ){_dec ._cgfa .PasswordAttr =_cbb .String (pwHash );};

// X returns the inner wrapped XML type.
func (_bag MergedCell )X ()*_ecbba .CT_MergeCell {return _bag ._bb };

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_accf Sheet )Extents ()string {_ggde ,_bdc ,_cggb ,_egad :=_accf .ExtentsIndex ();return _ddb .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_ggde ,_bdc ,_cggb ,_egad );};

// SetPriority sets the rule priority
func (_ccec ConditionalFormattingRule )SetPriority (p int32 ){_ccec ._gacg .PriorityAttr =p };const (_gff ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";_fcec ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";_add ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";_ebffc ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";);

// SetInlineString adds a string inline instead of in the shared strings table.
func (_edeb Cell )SetInlineString (s string ){_edeb .clearValue ();_edeb ._aeb .Is =_ecbba .NewCT_Rst ();_edeb ._aeb .Is .T =_cbb .String (s );_edeb ._aeb .TAttr =_ecbba .ST_CellTypeInlineStr ;};

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_bgge IconScale )AddFormatValue (t _ecbba .ST_CfvoType ,val string ){_bdgg :=_ecbba .NewCT_Cfvo ();_bdgg .TypeAttr =t ;_bdgg .ValAttr =_cbb .String (val );_bgge ._bacg .Cfvo =append (_bgge ._bacg .Cfvo ,_bdgg );};

// AddRun adds a new run of text to the cell.
func (_badd RichText )AddRun ()RichTextRun {_bggf :=_ecbba .NewCT_RElt ();_badd ._face .R =append (_badd ._face .R ,_bggf );return RichTextRun {_bggf };};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_gcae Comment )SetAuthor (author string ){_gcae ._fcccd .AuthorIdAttr =Comments {_gcae ._dbef ,_gcae ._dgb }.getOrCreateAuthor (author );};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_fbbg StyleSheet )AddNumberFormat ()NumberFormat {if _fbbg ._cag .NumFmts ==nil {_fbbg ._cag .NumFmts =_ecbba .NewCT_NumFmts ();};_bfcbf :=_ecbba .NewCT_NumFmt ();_bfcbf .NumFmtIdAttr =uint32 (200+len (_fbbg ._cag .NumFmts .NumFmt ));_fbbg ._cag .NumFmts .NumFmt =append (_fbbg ._cag .NumFmts .NumFmt ,_bfcbf );_fbbg ._cag .NumFmts .CountAttr =_cbb .Uint32 (uint32 (len (_fbbg ._cag .NumFmts .NumFmt )));return NumberFormat {_fbbg ._bdf ,_bfcbf };};

// AddCommentWithStyle adds a new comment styled in a default way
func (_ggbag Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_faae :=_ggbag .AddComment (cellRef ,author );_cafda :=_faae .AddRun ();_cafda .SetBold (true );_cafda .SetSize (10);_cafda .SetColor (_gacd .Black );_cafda .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_cafda .SetText (author +"\u003a");_cafda =_faae .AddRun ();_cafda .SetSize (10);_cafda .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_cafda .SetColor (_gacd .Black );_cafda .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_dfdg ,_affde :=_cddgb .ParseCellReference (cellRef );if _affde !=nil {return _affde ;};_ggbag ._ecgc ._cdeg [0].Shape =append (_ggbag ._ecgc ._cdeg [0].Shape ,_gffd .NewCommentShape (int64 (_dfdg .ColumnIdx ),int64 (_dfdg .RowIdx -1)));return nil ;};

// GetValueAsBool retrieves the cell's value as a boolean
func (_bed Cell )GetValueAsBool ()(bool ,error ){if _bed ._aeb .TAttr !=_ecbba .ST_CellTypeB {return false ,_facb .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");};if _bed ._aeb .V ==nil {return false ,_facb .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _feff .ParseBool (*_bed ._aeb .V );};

// SetHidden controls the visibility of a column.
func (_dcgc Column )SetHidden (b bool ){if !b {_dcgc ._ccfa .HiddenAttr =nil ;}else {_dcgc ._ccfa .HiddenAttr =_cbb .Bool (true );};};

// ClearFont clears any font configuration from the cell style.
func (_dcef CellStyle )ClearFont (){_dcef ._cbc .FontIdAttr =nil ;_dcef ._cbc .ApplyFontAttr =nil };func (_ddfe Cell )getLocked ()bool {if _ddfe ._aeb .SAttr ==nil {return false ;};_afede :=*_ddfe ._aeb .SAttr ;_aagf :=_ddfe ._dcd .StyleSheet .GetCellStyle (_afede );return *_aagf ._cbc .Protection .LockedAttr ;};const _dgba ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_egag Cell )SetDate (d _dbf .Time ){_egag .clearValue ();d =_befb (d );_dbc :=_egag ._dcd .Epoch ();if d .Before (_dbc ){_cbb .Log ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_aaea :=d .Sub (_dbc );_ggbea :=new (_facf .Float );_cabd :=new (_facf .Float );_cabd .SetPrec (128);_cabd .SetUint64 (uint64 (_aaea ));_efge :=new (_facf .Float );_efge .SetUint64 (24*60*60*1e9);_ggbea .Quo (_cabd ,_efge );_dbcc ,_ :=_ggbea .Uint64 ();_egag ._aeb .V =_cbb .Stringf ("\u0025\u0064",_dbcc );};

// AddFormatValue adds a format value to be used to determine the cell background.
func (_aced ColorScale )AddFormatValue (t _ecbba .ST_CfvoType ,val string ){_feaa :=_ecbba .NewCT_Cfvo ();_feaa .TypeAttr =t ;_feaa .ValAttr =_cbb .String (val );_aced ._efdfg .Cfvo =append (_aced ._efdfg .Cfvo ,_feaa );};

// IsSheetLocked returns whether the sheet objects are locked.
func (_gbce SheetProtection )IsObjectLocked ()bool {return _gbce ._cgfa .ObjectsAttr !=nil &&*_gbce ._cgfa .ObjectsAttr ;};func (_egda Fills )X ()*_ecbba .CT_Fills {return _egda ._dac };func (_ceab Cell )getRawSortValue ()(string ,bool ){if _ceab .HasFormula (){_cegd :=_ceab .GetCachedFormulaResult ();return _cegd ,_bcecg .IsNumber (_cegd );};_bcga ,_ :=_ceab .GetRawValue ();return _bcga ,_bcecg .IsNumber (_bcga );};func _befb (_ad _dbf .Time )_dbf .Time {_ad =_ad .Local ();return _dbf .Date (_ad .Year (),_ad .Month (),_ad .Day (),_ad .Hour (),_ad .Minute (),_ad .Second (),_ad .Nanosecond (),_dbf .UTC );};const _def ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// X returns the inner wrapped XML type.
func (_adc DataValidation )X ()*_ecbba .CT_DataValidation {return _adc ._dcb };

// AddCellStyle adds a new empty cell style to the stylesheet.
func (_dbacc StyleSheet )AddCellStyle ()CellStyle {_ge :=_ecbba .NewCT_Xf ();_dbacc ._cag .CellXfs .Xf =append (_dbacc ._cag .CellXfs .Xf ,_ge );_dbacc ._cag .CellXfs .CountAttr =_cbb .Uint32 (uint32 (len (_dbacc ._cag .CellXfs .Xf )));return CellStyle {_dbacc ._bdf ,_ge ,_dbacc ._cag .CellXfs };};

// X returns the inner wrapped XML type.
func (_dgd WorkbookProtection )X ()*_ecbba .CT_WorkbookProtection {return _dgd ._aab };

// SetContent sets the defined name content.
func (_bge DefinedName )SetContent (s string ){_bge ._affa .Content =s };

// SetHeight sets the height of the anchored object.
func (_fbde OneCellAnchor )SetHeight (h _gebcd .Distance ){_fbde ._egcc .Ext .CyAttr =int64 (h /_gebcd .EMU );};

// SetHeight sets the height of the anchored object.
func (_dgf AbsoluteAnchor )SetHeight (h _gebcd .Distance ){_dgf ._cdg .Ext .CyAttr =int64 (h /_gebcd .EMU )};

// X returns the inner wrapped XML type.
func (_cgbcb ConditionalFormattingRule )X ()*_ecbba .CT_CfRule {return _cgbcb ._gacg };

// SetHeight is a nop-op.
func (_fdgg TwoCellAnchor )SetHeight (h _gebcd .Distance ){};func (_fbce DataValidation )SetList ()DataValidationList {_fbce .clear ();_fbce ._dcb .TypeAttr =_ecbba .ST_DataValidationTypeList ;_fbce ._dcb .OperatorAttr =_ecbba .ST_DataValidationOperatorEqual ;return DataValidationList {_fbce ._dcb };};

// TopLeft is a no-op.
func (_bafg AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};

// SaveToFile writes the workbook out to a file.
func (_effb *Workbook )SaveToFile (path string )error {_bgg ,_fdac :=_abe .Create (path );if _fdac !=nil {return _fdac ;};defer _bgg .Close ();return _effb .Save (_bgg );};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_ebbd DataValidationList )SetValues (values []string ){_ebbd ._bdbc .Formula1 =_cbb .String ("\u0022"+_eggdf .Join (values ,"\u002c")+"\u0022");_ebbd ._bdbc .Formula2 =_cbb .String ("\u0030");};func (_bbgc *Workbook )ensureSharedStringsRelationships (){_bfcb :=false ;for _ ,_ddbf :=range _bbgc .ContentTypes .X ().Override {if _ddbf .ContentTypeAttr ==_cbb .SharedStringsContentType {_bfcb =true ;break ;};};if !_bfcb {_bbgc .ContentTypes .AddOverride (_fae ,_cbb .SharedStringsContentType );};_abfc :=false ;for _ ,_bgfe :=range _bbgc ._feed .Relationships (){if _bgfe .X ().TargetAttr ==_egg {_abfc =true ;break ;};};if !_abfc {_bbgc ._feed .AddRelationship (_egg ,_cbb .SharedStringsType );};};

// GetWidth returns a worksheet's column width.
func (_cfac *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_dfeg :=range _cfac ._bada .X ().Cols [0].Col {if int (_dfeg .MinAttr )<=colIdx &&colIdx <=int (_dfeg .MaxAttr ){return float64 (int (*_dfeg .WidthAttr ));};};return 0;};

// X returns the inner wrapped XML type.
func (_cgfd Row )X ()*_ecbba .CT_Row {return _cgfd ._eaeb };

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_ceg *Workbook ;_aaba *_ebgb .WsDr ;};

// Cell returns the actual cell behind the merged region
func (_gdg MergedCell )Cell ()Cell {_cecd :=_gdg .Reference ();if _bbfe :=_eggdf .Index (_gdg .Reference (),"\u003a");_bbfe !=-1{_cecd =_cecd [0:_bbfe ];return _gdg ._ddg .Cell (_cecd );};return Cell {};};

// SetHidden marks the defined name as hidden.
func (_bfe DefinedName )SetHidden (b bool ){_bfe ._affa .HiddenAttr =_cbb .Bool (b )};

// SheetCount returns the number of sheets in the workbook.
func (_ee Workbook )SheetCount ()int {return len (_ee ._fccf )};type SheetProtection struct{_cgfa *_ecbba .CT_SheetProtection };

// DataValidation controls cell validation
type DataValidation struct{_dcb *_ecbba .CT_DataValidation };