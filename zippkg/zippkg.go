//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_c "archive/zip";_be "bytes";_bc "encoding/xml";_a "fmt";_cg "github.com/unidoc/unioffice";_fd "github.com/unidoc/unioffice/algo";_cf "github.com/unidoc/unioffice/common/tempstorage";_gd "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_b "io";_ef "path";_fb "sort";_f "strings";_g "time";);

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_edc :=_f .Split (path ,"\u002f");_aa :=_f .Join (_edc [0:len (_edc )-1],"\u002f");_bdc :=_edc [len (_edc )-1];_aa +="\u002f_\u0072\u0065\u006c\u0073\u002f";_bdc +="\u002e\u0072\u0065l\u0073";return _aa +_bdc ;};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_c .File ,path string )(string ,error ){_ab ,_fbd :=_cf .TempFile (path ,"\u007a\u007a");if _fbd !=nil {return "",_fbd ;};defer _ab .Close ();_bgf ,_fbd :=f .Open ();if _fbd !=nil {return "",_fbd ;};defer _bgf .Close ();_ ,_fbd =_b .Copy (_ab ,_bgf );if _fbd !=nil {return "",_fbd ;};return _ab .Name (),nil ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_bg *DecodeMap )Decode (files []*_c .File )error {_ag :=1;for _ag > 0{for len (_bg ._ff )> 0{_ffg :=_bg ._ff [len (_bg ._ff )-1];_bg ._ff =_bg ._ff [0:len (_bg ._ff )-1];_ebf :=_ffg .Ifc .(*_gd .Relationships );for _ ,_bfa :=range _ebf .Relationship {_ffa ,_ :=_bg ._ee [_ebf ];_bg ._eed (_bg ,_ffa +_bfa .TargetAttr ,_bfa .TypeAttr ,files ,_bfa ,_ffg );};};for _ac ,_cfg :=range files {if _cfg ==nil {continue ;};if _bcc ,_dce :=_bg ._ea [_cfg .Name ];_dce {delete (_bg ._ea ,_cfg .Name );if _adg :=Decode (_cfg ,_bcc .Ifc );_adg !=nil {return _adg ;};files [_ac ]=nil ;if _bgd ,_fcf :=_bcc .Ifc .(*_gd .Relationships );_fcf {_bg ._ff =append (_bg ._ff ,_bcc );_dd ,_ :=_ef .Split (_ef .Clean (_cfg .Name +"\u002f\u002e\u002e\u002f"));_bg ._ee [_bgd ]=_dd ;_ag ++;};};};_ag --;};return nil ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _b .Writer ;};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_c .Writer ,zipPath string ,data []byte )error {_fba ,_cc :=z .Create (zipPath );if _cc !=nil {return _a .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_cc );};_ ,_cc =_b .Copy (_fba ,_be .NewReader (data ));return _cc ;};var _dag =[]byte {'\r','\n'};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_ea map[string ]Target ;_ee map[*_gd .Relationships ]string ;_ff []Target ;_eed OnNewRelationshipFunc ;_ad map[string ]struct{};_ed map[string ]int ;};func (_ebg *DecodeMap )IndexFor (path string )int {return _ebg ._ed [path ]};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_c .File ,dest interface{})error {_fe ,_edd :=f .Open ();if _edd !=nil {return _a .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_edd );};defer _fe .Close ();_af :=_bc .NewDecoder (_fe );if _ba :=_af .Decode (dest );_ba !=nil {return _a .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_ba );};if _ge ,_fff :=dest .(*_gd .Relationships );_fff {for _fcg ,_da :=range _ge .Relationship {switch _da .TypeAttr {case _cg .OfficeDocumentTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .OfficeDocumentType ;case _cg .StylesTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .StylesType ;case _cg .ThemeTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .ThemeType ;case _cg .ControlTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .ControlType ;case _cg .SettingsTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .SettingsType ;case _cg .ImageTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .ImageType ;case _cg .CommentsTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .CommentsType ;case _cg .ThumbnailTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .ThumbnailType ;case _cg .DrawingTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .DrawingType ;case _cg .ChartTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .ChartType ;case _cg .ExtendedPropertiesTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .ExtendedPropertiesType ;case _cg .CustomXMLTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .CustomXMLType ;case _cg .WorksheetTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .WorksheetType ;case _cg .SharedStringsTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .SharedStringsType ;case _cg .TableTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .TableType ;case _cg .HeaderTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .HeaderType ;case _cg .FooterTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .FooterType ;case _cg .NumberingTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .NumberingType ;case _cg .FontTableTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .FontTableType ;case _cg .WebSettingsTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .WebSettingsType ;case _cg .FootNotesTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .FootNotesType ;case _cg .EndNotesTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .EndNotesType ;case _cg .SlideTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .SlideType ;case _cg .VMLDrawingTypeStrict :_ge .Relationship [_fcg ].TypeAttr =_cg .VMLDrawingType ;};};_fb .Slice (_ge .Relationship ,func (_cd ,_fa int )bool {_db :=_ge .Relationship [_cd ];_bb :=_ge .Relationship [_fa ];return _fd .NaturalLess (_db .IdAttr ,_bb .IdAttr );});};return nil ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_gc *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_gc ._eed =fn };func MarshalXMLByType (z *_c .Writer ,dt _cg .DocType ,typ string ,v interface{})error {_bca :=_cg .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_bca ,v );};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_cb *DecodeMap ,_d ,_bd string ,_dc []*_c .File ,_eb *_gd .Relationship ,_fdd Target )error ;func (_gff *DecodeMap )RecordIndex (path string ,idx int ){_gff ._ed [path ]=idx };func MarshalXMLByTypeIndex (z *_c .Writer ,dt _cg .DocType ,typ string ,idx int ,v interface{})error {_ga :=_cg .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_ga ,v );};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_gcc *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _gcc ._ea ==nil {_gcc ._ea =make (map[string ]Target );_gcc ._ee =make (map[*_gd .Relationships ]string );_gcc ._ad =make (map[string ]struct{});_gcc ._ed =make (map[string ]int );};_fc :=_ef .Clean (filePath );if _ ,_bf :=_gcc ._ad [_fc ];_bf {return false ;};_gcc ._ad [_fc ]=struct{}{};_gcc ._ea [_fc ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};var _afd =[]byte {'/','>'};func (_ffff SelfClosingWriter )Write (b []byte )(int ,error ){_dg :=0;_bcf :=0;for _bdd :=0;_bdd < len (b )-2;_bdd ++{if b [_bdd ]=='>'&&b [_bdd +1]=='<'&&b [_bdd +2]=='/'{_cff :=[]byte {};_bag :=_bdd ;for _eg :=_bdd ;_eg >=0;_eg --{if b [_eg ]==' '{_bag =_eg ;}else if b [_eg ]=='<'{_cff =b [_eg +1:_bag ];break ;};};_dga :=[]byte {};for _egb :=_bdd +3;_egb < len (b );_egb ++{if b [_egb ]=='>'{_dga =b [_bdd +3:_egb ];break ;};};if !_be .Equal (_cff ,_dga ){continue ;};_dbb ,_acc :=_ffff .W .Write (b [_dg :_bdd ]);if _acc !=nil {return _bcf +_dbb ,_acc ;};_bcf +=_dbb ;_ ,_acc =_ffff .W .Write (_afd );if _acc !=nil {return _bcf ,_acc ;};_bcf +=3;for _bba :=_bdd +2;_bba < len (b )&&b [_bba ]!='>';_bba ++{_bcf ++;_dg =_bba +2;_bdd =_dg ;};};};_gb ,_gecc :=_ffff .W .Write (b [_dg :]);return _gb +_bcf ,_gecc ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_c .Writer ,filename string ,v interface{})error {_bea :=&_c .FileHeader {};_bea .Method =_c .Deflate ;_bea .Name =filename ;_bea .SetModTime (_g .Now ());_edff ,_gfe :=z .CreateHeader (_bea );if _gfe !=nil {return _a .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_gfe );};_ ,_gfe =_edff .Write ([]byte (XMLHeader ));if _gfe !=nil {return _a .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_gfe );};if _gfe =_bc .NewEncoder (SelfClosingWriter {_edff }).Encode (v );_gfe !=nil {return _a .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_gfe );};_ ,_gfe =_edff .Write (_dag );return _gfe ;};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_c .Writer ,zipPath ,storagePath string )error {_gec ,_cbg :=z .Create (zipPath );if _cbg !=nil {return _a .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_cbg );};_edf ,_cbg :=_cf .Open (storagePath );if _cbg !=nil {return _a .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_cbg );};defer _edf .Close ();_ ,_cbg =_b .Copy (_gec ,_edf );return _cbg ;};