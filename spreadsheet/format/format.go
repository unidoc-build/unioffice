//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_eceb "bytes";_fe "fmt";_daa "github.com/unidoc/unioffice";_gaf "io";_efg "math";_dgff "strconv";_fga "strings";_gcc "time";);type Lexer struct{_bga Format ;_ece []Format ;};const _cbd int =-1;func _edab (_bcb int64 ,_cgc Format )[]byte {if !_cgc .IsExponential ||len (_cgc .Exponent )==0{return nil ;};_cdff :=_dgff .AppendInt (nil ,_gaa (_bcb ),10);_fbg :=make ([]byte ,0,len (_cdff )+2);_fbg =append (_fbg ,'E');if _bcb >=0{_fbg =append (_fbg ,'+');}else {_fbg =append (_fbg ,'-');_bcb *=-1;};_cgd :=0;_ddb :for _gfce :=len (_cgc .Exponent )-1;_gfce >=0;_gfce --{_gaeb :=len (_cdff )-1-_cgd ;_ddgab :=_cgc .Exponent [_gfce ];switch _ddgab .Type {case FmtTypeDigit :if _gaeb >=0{_fbg =append (_fbg ,_cdff [_gaeb ]);_cgd ++;}else {_fbg =append (_fbg ,'0');};case FmtTypeDigitOpt :if _gaeb >=0{_fbg =append (_fbg ,_cdff [_gaeb ]);_cgd ++;}else {for _cde :=_gfce ;_cde >=0;_cde --{_cdfb :=_cgc .Exponent [_cde ];if _cdfb .Type ==FmtTypeLiteral {_fbg =append (_fbg ,_cdfb .Literal );};};break _ddb ;};case FmtTypeLiteral :_fbg =append (_fbg ,_ddgab .Literal );default:_daa .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_ddgab );};};if _cgd < len (_cdff ){_fbg =append (_fbg ,_cdff [len (_cdff )-_cgd -1:_cgd -1]...);};_gbc (_fbg [2:]);return _fbg ;};

// AddToken adds a format token to the format.
func (_cea *Format )AddToken (t FmtType ,l []byte ){if _cea ._dfb {_cea ._dfb =false ;return ;};switch t {case FmtTypeDecimal :_cea ._dgc =true ;case FmtTypeUnderscore :_cea ._dfb =true ;case FmtTypeText :_cea .Whole =append (_cea .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_cea .Whole =append (_cea .Whole ,Token {Type :t ,DateTime :string (l )});case FmtTypePercent :_cea ._edca =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_acda :=range l {if _cea .IsExponential {_cea .Exponent =append (_cea .Exponent ,Token {Type :t ,Literal :_acda });}else if !_cea ._dgc {_cea .Whole =append (_cea .Whole ,Token {Type :t ,Literal :_acda });}else {_cea .Fractional =append (_cea .Fractional ,Token {Type :t ,Literal :_acda });};};case FmtTypeDigitOptThousands :_cea ._fea =true ;case FmtTypeFraction :_fd :=_fga .Split (string (l ),"\u002f");if len (_fd )==2{_cea ._c =true ;_cea ._dce ,_ =_dgff .ParseInt (_fd [1],10,64);for _ ,_cdc :=range _fd [1]{if _cdc =='?'||_cdc =='0'{_cea ._gcbc ++;};};};default:_daa .Log ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );};};var _add =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};const _ea ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";func _afcg (_adg float64 ,_fbfa Format ,_bcdf bool )string {if _fbfa ._aebfd {return NumberGeneric (_adg );};_caba :=make ([]byte ,0,20);_babf :=_efg .Signbit (_adg );_egc :=_efg .Abs (_adg );_bag :=int64 (0);_abfe :=int64 (0);if _fbfa .IsExponential {for _egc >=10{_abfe ++;_egc /=10;};for _egc < 1{_abfe --;_egc *=10;};}else if _fbfa ._edca {_egc *=100;}else if _fbfa ._c {if _fbfa ._dce ==0{_abf :=_efg .Pow (10,float64 (_fbfa ._gcbc ));_afc ,_afe :=1.0,1.0;_ =_afc ;for _bgc :=1.0;_bgc < _abf ;_bgc ++{_ ,_cec :=_efg .Modf (_egc *float64 (_bgc ));if _cec < _afe {_afe =_cec ;_afc =_bgc ;if _cec ==0{break ;};};};_fbfa ._dce =int64 (_afc );};_bag =int64 (_egc *float64 (_fbfa ._dce )+0.5);if len (_fbfa .Whole )> 0&&_bag > _fbfa ._dce {_bag =int64 (_egc *float64 (_fbfa ._dce ))%_fbfa ._dce ;_egc -=float64 (_bag )/float64 (_fbfa ._dce );}else {_egc -=float64 (_bag )/float64 (_fbfa ._dce );if _efg .Abs (_egc )< 1{_adca :=true ;for _ ,_ffe :=range _fbfa .Whole {if _ffe .Type ==FmtTypeDigitOpt {continue ;};if _ffe .Type ==FmtTypeLiteral &&_ffe .Literal ==' '{continue ;};_adca =false ;};if _adca {_fbfa .Whole =nil ;};};};};_bcge :=1;for _ ,_bcee :=range _fbfa .Fractional {if _bcee .Type ==FmtTypeDigit ||_bcee .Type ==FmtTypeDigitOpt {_bcge ++;};};_egc +=5*_efg .Pow10 (-_bcge );_efa ,_cga :=_efg .Modf (_egc );_caba =append (_caba ,_dcgd (_efa ,_adg ,_fbfa )...);_caba =append (_caba ,_eacf (_cga ,_adg ,_fbfa )...);_caba =append (_caba ,_edab (_abfe ,_fbfa )...);if _fbfa ._c {_caba =_dgff .AppendInt (_caba ,_bag ,10);_caba =append (_caba ,'/');_caba =_dgff .AppendInt (_caba ,_fbfa ._dce ,10);};if !_bcdf &&_babf {return "\u002d"+string (_caba );};return string (_caba );};const _ccd int =0;const _gfd =1e11;const _ada int =0;func _abbf (_ggc []byte )[]byte {for _gcf :=len (_ggc )-1;_gcf > 0;_gcf --{if _ggc [_gcf ]=='9'+1{_ggc [_gcf ]='0';if _ggc [_gcf -1]=='.'{_gcf --;};_ggc [_gcf -1]++;};};if _ggc [0]=='9'+1{_ggc [0]='0';copy (_ggc [1:],_ggc [0:]);_ggc [0]='1';};return _ggc ;};const _ccfb =1e-10;func _aec (_db float64 )string {_caf :=_dgff .FormatFloat (_db ,'E',-1,64);_fdb :=_dgff .FormatFloat (_db ,'E',5,64);if len (_caf )< len (_fdb ){return _dgff .FormatFloat (_db ,'E',2,64);};return _fdb ;};const _ffd int =34;func _dcgd (_eba ,_gbbf float64 ,_abbb Format )[]byte {if len (_abbb .Whole )==0{return nil ;};_ccc :=_gcc .Date (1899,12,30,0,0,0,0,_gcc .UTC );_adc :=_ccc .Add (_gcc .Duration (_gbbf *float64 (24*_gcc .Hour )));_adc =_faf (_adc );_aebea :=_dgff .AppendFloat (nil ,_eba ,'f',-1,64);_ebeg :=make ([]byte ,0,len (_aebea ));_acfg :=0;_dgcd :=1;_aa :for _cacb :=len (_abbb .Whole )-1;_cacb >=0;_cacb --{_edfc :=len (_aebea )-1-_acfg ;_edf :=_abbb .Whole [_cacb ];switch _edf .Type {case FmtTypeDigit :if _edfc >=0{_ebeg =append (_ebeg ,_aebea [_edfc ]);_acfg ++;_dgcd =_cacb ;}else {_ebeg =append (_ebeg ,'0');};case FmtTypeDigitOpt :if _edfc >=0{_ebeg =append (_ebeg ,_aebea [_edfc ]);_acfg ++;_dgcd =_cacb ;}else {for _acef :=_cacb ;_acef >=0;_acef --{_bc :=_abbb .Whole [_acef ];if _bc .Type ==FmtTypeLiteral {_ebeg =append (_ebeg ,_bc .Literal );};};break _aa ;};case FmtTypeDollar :for _dcgdg :=_acfg ;_dcgdg < len (_aebea );_dcgdg ++{_ebeg =append (_ebeg ,_aebea [len (_aebea )-1-_dcgdg ]);_acfg ++;};_ebeg =append (_ebeg ,'$');case FmtTypeComma :if !_abbb ._fea {_ebeg =append (_ebeg ,',');};case FmtTypeLiteral :_ebeg =append (_ebeg ,_edf .Literal );case FmtTypeDate :_ebeg =append (_ebeg ,_gbc (_aded (_adc ,_edf .DateTime ))...);case FmtTypeTime :_ebeg =append (_ebeg ,_gbc (_dag (_adc ,_gbbf ,_edf .DateTime ))...);default:_daa .Log ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_edf );};};_dae :=_gbc (_ebeg );if _acfg < len (_aebea )&&(_acfg !=0||_abbb ._dgc ){_aae :=len (_aebea )-_acfg ;_acea :=make ([]byte ,len (_dae )+_aae );copy (_acea ,_dae [0:_dgcd ]);copy (_acea [_dgcd :],_aebea [0:]);copy (_acea [_dgcd +_aae :],_dae [_dgcd :]);_dae =_acea ;};if _abbb ._fea {_dd :=_eceb .Buffer {};_eeb :=0;for _egce :=len (_dae )-1;_egce >=0;_egce --{if !(_dae [_egce ]>='0'&&_dae [_egce ]<='9'){_eeb ++;}else {break ;};};for _aebe :=0;_aebe < len (_dae );_aebe ++{_abea :=(len (_dae )-_aebe -_eeb );if _abea %3==0&&_abea !=0&&_aebe !=0{_dd .WriteByte (',');};_dd .WriteByte (_dae [_aebe ]);};_dae =_dd .Bytes ();};return _dae ;};const _aca int =0;

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _efg .Abs (v )>=_gfd ||_efg .Abs (v )<=_ccfb &&v !=0{return _aec (v );};_gf :=make ([]byte ,0,15);_gf =_dgff .AppendFloat (_gf ,v ,'f',-1,64);if len (_gf )> 11{_dbe :=_gf [11]-'0';if _dbe >=5&&_dbe <=9{_gf [10]++;_gf =_gf [0:11];_gf =_abbf (_gf );};_gf =_gf [0:11];}else if len (_gf )==11{if _gf [len (_gf )-1]=='9'{_gf [len (_gf )-1]++;_gf =_abbf (_gf );};};_gf =_fbbc (_gf );return string (_gf );};func (_ecc *Lexer )nextFmt (){_ecc ._ece =append (_ecc ._ece ,_ecc ._bga );_ecc ._bga =Format {}};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_fgb :=Parse (f );if len (_fgb )==1{return _afcg (v ,_fgb [0],false );}else if len (_fgb )> 1&&v < 0{return _afcg (v ,_fgb [1],true );}else if len (_fgb )> 2&&v ==0{return _afcg (v ,_fgb [2],false );};return _afcg (v ,_fgb [0],false );};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);func _gaa (_de int64 )int64 {if _de < 0{return -_de ;};return _de ;};func _dag (_ddga _gcc .Time ,_gec float64 ,_gecg string )[]byte {_cfc :=[]byte {};_bce :=0;for _dfe :=0;_dfe < len (_gecg );_dfe ++{var _aaaca string ;if _gecg [_dfe ]==':'{_aaaca =string (_gecg [_bce :_dfe ]);_bce =_dfe +1;}else if _dfe ==len (_gecg )-1{_aaaca =string (_gecg [_bce :_dfe +1]);}else {continue ;};switch _aaaca {case "\u0064":_cfc =_ddga .AppendFormat (_cfc ,"\u0032");case "\u0068":_cfc =_ddga .AppendFormat (_cfc ,"\u0033");case "\u0068\u0068":_cfc =_ddga .AppendFormat (_cfc ,"\u0031\u0035");case "\u006d":_cfc =_ddga .AppendFormat (_cfc ,"\u0034");case "\u006d\u006d":_cfc =_ddga .AppendFormat (_cfc ,"\u0030\u0034");case "\u0073":_cfc =_ddga .Round (_gcc .Second ).AppendFormat (_cfc ,"\u0035");case "\u0073\u002e\u0030":_cfc =_ddga .Round (_gcc .Second /10).AppendFormat (_cfc ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_cfc =_ddga .Round (_gcc .Second /100).AppendFormat (_cfc ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_cfc =_ddga .Round (_gcc .Second /1000).AppendFormat (_cfc ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_cfc =_ddga .Round (_gcc .Second ).AppendFormat (_cfc ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_cfc =_ddga .Round (_gcc .Second /10).AppendFormat (_cfc ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_cfc =_ddga .Round (_gcc .Second /100).AppendFormat (_cfc ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_cfc =_ddga .Round (_gcc .Second /1000).AppendFormat (_cfc ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_cfc =_ddga .AppendFormat (_cfc ,"\u0050\u004d");case "\u005b\u0068\u005d":_cfc =_dgff .AppendInt (_cfc ,int64 (_gec *24),10);case "\u005b\u006d\u005d":_cfc =_dgff .AppendInt (_cfc ,int64 (_gec *24*60),10);case "\u005b\u0073\u005d":_cfc =_dgff .AppendInt (_cfc ,int64 (_gec *24*60*60),10);case "":default:_daa .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_aaaca );};if _gecg [_dfe ]==':'{_cfc =append (_cfc ,':');};};return _cfc ;};func _aded (_bebb _gcc .Time ,_gff string )[]byte {_edac :=[]byte {};_deaf :=0;for _dgg :=0;_dgg < len (_gff );_dgg ++{var _efe string ;if _gff [_dgg ]=='/'{_efe =string (_gff [_deaf :_dgg ]);_deaf =_dgg +1;}else if _dgg ==len (_gff )-1{_efe =string (_gff [_deaf :_dgg +1]);}else {continue ;};switch _efe {case "\u0079\u0079":_edac =_bebb .AppendFormat (_edac ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_edac =_bebb .AppendFormat (_edac ,"\u0032\u0030\u0030\u0036");case "\u006d":_edac =_bebb .AppendFormat (_edac ,"\u0031");case "\u006d\u006d":_edac =_bebb .AppendFormat (_edac ,"\u0030\u0031");case "\u006d\u006d\u006d":_edac =_bebb .AppendFormat (_edac ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_edac =_bebb .AppendFormat (_edac ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _bebb .Month (){case _gcc .January ,_gcc .July ,_gcc .June :_edac =append (_edac ,'J');case _gcc .February :_edac =append (_edac ,'M');case _gcc .March ,_gcc .May :_edac =append (_edac ,'M');case _gcc .April ,_gcc .August :_edac =append (_edac ,'A');case _gcc .September :_edac =append (_edac ,'S');case _gcc .October :_edac =append (_edac ,'O');case _gcc .November :_edac =append (_edac ,'N');case _gcc .December :_edac =append (_edac ,'D');};case "\u0064":_edac =_bebb .AppendFormat (_edac ,"\u0032");case "\u0064\u0064":_edac =_bebb .AppendFormat (_edac ,"\u0030\u0032");case "\u0064\u0064\u0064":_edac =_bebb .AppendFormat (_edac ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_edac =_bebb .AppendFormat (_edac ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_daa .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_efe );};if _gff [_dgg ]=='/'{_edac =append (_edac ,'/');};};return _edac ;};func IsNumber (data string )(_dfff bool ){_cba ,_fcc ,_cdg :=0,0,len (data );_ecbd :=len (data );_eg ,_ad ,_gb :=0,0,0;_ =_ad ;_ =_gb ;_ =_eg ;{_cba =_ccd ;_eg =0;_ad =0;_gb =0;};{if _fcc ==_cdg {goto _fead ;};switch _cba {case 0:goto _agb ;case 1:goto _afd ;case 2:goto _bfgc ;case 3:goto _acd ;case 4:goto _fdf ;case 5:goto _bbf ;case 6:goto _gae ;case 7:goto _cdb ;};goto _bbcd ;_daeg :_ad =_fcc ;_fcc --;{_dfff =false ;};goto _ffbae ;_efga :_ad =_fcc ;_fcc --;{_dfff =_ad ==len (data );};goto _ffbae ;_ca :_ad =_fcc ;_fcc --;{_dfff =_ad ==len (data );};goto _ffbae ;_fde :switch _gb {case 2:{_fcc =(_ad )-1;_dfff =_ad ==len (data );};case 3:{_fcc =(_ad )-1;_dfff =false ;};};goto _ffbae ;_ffbae :_eg =0;if _fcc ++;_fcc ==_cdg {goto _aacc ;};_agb :_eg =_fcc ;switch data [_fcc ]{case 43:goto _affd ;case 45:goto _affd ;};if 48<=data [_fcc ]&&data [_fcc ]<=57{goto _acf ;};goto _bbcc ;_bbcc :if _fcc ++;_fcc ==_cdg {goto _acfe ;};_afd :goto _bbcc ;_affd :if _fcc ++;_fcc ==_cdg {goto _gbd ;};_bfgc :if 48<=data [_fcc ]&&data [_fcc ]<=57{goto _acf ;};goto _bbcc ;_acf :if _fcc ++;_fcc ==_cdg {goto _gea ;};_acd :if data [_fcc ]==46{goto _fbb ;};if 48<=data [_fcc ]&&data [_fcc ]<=57{goto _acf ;};goto _bbcc ;_fbb :if _fcc ++;_fcc ==_cdg {goto _dbdd ;};_fdf :if 48<=data [_fcc ]&&data [_fcc ]<=57{goto _aebc ;};goto _bbcc ;_aebc :if _fcc ++;_fcc ==_cdg {goto _abe ;};_bbf :if data [_fcc ]==69{goto _aag ;};if 48<=data [_fcc ]&&data [_fcc ]<=57{goto _aebc ;};goto _bbcc ;_aag :if _fcc ++;_fcc ==_cdg {goto _b ;};_gae :switch data [_fcc ]{case 43:goto _aff ;case 45:goto _aff ;};goto _bbcc ;_aff :_ad =_fcc +1;_gb =3;goto _geg ;_da :_ad =_fcc +1;_gb =2;goto _geg ;_geg :if _fcc ++;_fcc ==_cdg {goto _f ;};_cdb :if 48<=data [_fcc ]&&data [_fcc ]<=57{goto _da ;};goto _bbcc ;_bbcd :_aacc :_cba =0;goto _fead ;_acfe :_cba =1;goto _fead ;_gbd :_cba =2;goto _fead ;_gea :_cba =3;goto _fead ;_dbdd :_cba =4;goto _fead ;_abe :_cba =5;goto _fead ;_b :_cba =6;goto _fead ;_f :_cba =7;goto _fead ;_fead :{};if _fcc ==_ecbd {switch _cba {case 1:goto _daeg ;case 2:goto _daeg ;case 3:goto _efga ;case 4:goto _daeg ;case 5:goto _ca ;case 6:goto _daeg ;case 7:goto _fde ;};};};if _cba ==_dgga {return false ;};return ;};func (_fae *Lexer )Lex (r _gaf .Reader ){_bdfg ,_ede ,_bfg :=0,0,0;_gfc :=-1;_ccf ,_acaa ,_fad :=0,0,0;_ =_acaa ;_ =_fad ;_ac :=1;_ =_ac ;_aac :=make ([]byte ,4096);_bbb :=false ;for !_bbb {_dc :=0;if _ccf > 0{_dc =_ede -_ccf ;};_ede =0;_gfea ,_bege :=r .Read (_aac [_dc :]);if _gfea ==0||_bege !=nil {_bbb =true ;};_bfg =_gfea +_dc ;if _bfg < len (_aac ){_gfc =_bfg ;};{_bdfg =_ffd ;_ccf =0;_acaa =0;_fad =0;};{if _ede ==_bfg {goto _dbd ;};switch _bdfg {case 34:goto _ceag ;case 35:goto _ccca ;case 0:goto _gaaa ;case 36:goto _dca ;case 37:goto _gg ;case 1:goto _bfgg ;case 2:goto _agdg ;case 38:goto _ebf ;case 3:goto _dg ;case 4:goto _eac ;case 39:goto _e ;case 5:goto _gfb ;case 6:goto _dfa ;case 7:goto _bfc ;case 8:goto _bbeg ;case 40:goto _efd ;case 9:goto _dccf ;case 41:goto _gd ;case 10:goto _ec ;case 42:goto _aaf ;case 11:goto _fgab ;case 43:goto _ccce ;case 44:goto _gda ;case 45:goto _ffdb ;case 12:goto _aed ;case 46:goto _baf ;case 13:goto _ace ;case 14:goto _gdf ;case 15:goto _dcg ;case 16:goto _cac ;case 47:goto _gcb ;case 17:goto _agf ;case 48:goto _ddba ;case 18:goto _a ;case 19:goto _agga ;case 20:goto _cbf ;case 49:goto _dfea ;case 50:goto _dad ;case 21:goto _fdc ;case 22:goto _dfba ;case 23:goto _abee ;case 24:goto _ffb ;case 25:goto _gad ;case 51:goto _gfg ;case 26:goto _gaaf ;case 52:goto _gafe ;case 53:goto _cgg ;case 54:goto _ag ;case 55:goto _bbc ;case 56:goto _eed ;case 57:goto _dfc ;case 27:goto _ccb ;case 28:goto _cbac ;case 29:goto _fbd ;case 30:goto _gedd ;case 31:goto _bdf ;case 58:goto _ggd ;case 32:goto _abeg ;case 59:goto _fdd ;case 33:goto _ga ;case 60:goto _efad ;case 61:goto _begd ;case 62:goto _edad ;};goto _fdba ;_gcbg :switch _fad {case 2:{_ede =(_acaa )-1;_fae ._bga .AddToken (FmtTypeDigit ,nil );};case 3:{_ede =(_acaa )-1;_fae ._bga .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_ede =(_acaa )-1;};case 8:{_ede =(_acaa )-1;_fae ._bga .AddToken (FmtTypePercent ,nil );};case 13:{_ede =(_acaa )-1;_fae ._bga .AddToken (FmtTypeFraction ,_aac [_ccf :_acaa ]);};case 14:{_ede =(_acaa )-1;_fae ._bga .AddToken (FmtTypeDate ,_aac [_ccf :_acaa ]);};case 15:{_ede =(_acaa )-1;_fae ._bga .AddToken (FmtTypeTime ,_aac [_ccf :_acaa ]);};case 16:{_ede =(_acaa )-1;_fae ._bga .AddToken (FmtTypeTime ,_aac [_ccf :_acaa ]);};case 18:{_ede =(_acaa )-1;};case 20:{_ede =(_acaa )-1;_fae ._bga .AddToken (FmtTypeLiteral ,_aac [_ccf :_acaa ]);};case 21:{_ede =(_acaa )-1;_fae ._bga .AddToken (FmtTypeLiteral ,_aac [_ccf +1:_acaa -1]);};};goto _bcg ;_fbf :_ede =(_acaa )-1;{_fae ._bga .AddToken (FmtTypeFraction ,_aac [_ccf :_acaa ]);};goto _bcg ;_edec :_ede =(_acaa )-1;{_fae ._bga .AddToken (FmtTypeDigitOpt ,nil );};goto _bcg ;_fdab :_acaa =_ede +1;{_fae ._bga .AddToken (FmtTypeDigitOptThousands ,nil );};goto _bcg ;_bagb :_ede =(_acaa )-1;{_fae ._bga .AddToken (FmtTypePercent ,nil );};goto _bcg ;_abd :_ede =(_acaa )-1;{_fae ._bga .AddToken (FmtTypeDate ,_aac [_ccf :_acaa ]);};goto _bcg ;_bbg :_ede =(_acaa )-1;{_fae ._bga .AddToken (FmtTypeDigit ,nil );};goto _bcg ;_df :_ede =(_acaa )-1;{_fae ._bga .AddToken (FmtTypeTime ,_aac [_ccf :_acaa ]);};goto _bcg ;_gbe :_ede =(_acaa )-1;{_fae ._bga .AddToken (FmtTypeLiteral ,_aac [_ccf :_acaa ]);};goto _bcg ;_fbe :_acaa =_ede +1;{_fae ._bga ._aebfd =true ;};goto _bcg ;_fcf :_acaa =_ede +1;{_fae ._bga .AddToken (FmtTypeLiteral ,_aac [_ccf :_acaa ]);};goto _bcg ;_cggc :_acaa =_ede +1;{_fae ._bga .AddToken (FmtTypeDollar ,nil );};goto _bcg ;_fdbf :_acaa =_ede +1;{_fae ._bga .AddToken (FmtTypeComma ,nil );};goto _bcg ;_ffba :_acaa =_ede +1;{_fae ._bga .AddToken (FmtTypeDecimal ,nil );};goto _bcg ;_bg :_acaa =_ede +1;{_fae .nextFmt ();};goto _bcg ;_age :_acaa =_ede +1;{_fae ._bga .AddToken (FmtTypeText ,nil );};goto _bcg ;_cb :_acaa =_ede +1;{_fae ._bga .AddToken (FmtTypeUnderscore ,nil );};goto _bcg ;_dgb :_acaa =_ede ;_ede --;{_fae ._bga .AddToken (FmtTypeLiteral ,_aac [_ccf :_acaa ]);};goto _bcg ;_deafg :_acaa =_ede ;_ede --;{_fae ._bga .AddToken (FmtTypeLiteral ,_aac [_ccf +1:_acaa -1]);};goto _bcg ;_ebb :_acaa =_ede ;_ede --;{_fae ._bga .AddToken (FmtTypeDigitOpt ,nil );};goto _bcg ;_cdf :_acaa =_ede ;_ede --;{_fae ._bga .AddToken (FmtTypeFraction ,_aac [_ccf :_acaa ]);};goto _bcg ;_beb :_acaa =_ede ;_ede --;{_fae ._bga .AddToken (FmtTypePercent ,nil );};goto _bcg ;_eee :_acaa =_ede ;_ede --;{_fae ._bga .AddToken (FmtTypeDate ,_aac [_ccf :_acaa ]);};goto _bcg ;_ecb :_acaa =_ede ;_ede --;{_fae ._bga .AddToken (FmtTypeDigit ,nil );};goto _bcg ;_ffa :_acaa =_ede ;_ede --;{_fae ._bga .AddToken (FmtTypeTime ,_aac [_ccf :_acaa ]);};goto _bcg ;_bcgae :_acaa =_ede ;_ede --;{};goto _bcg ;_bae :_acaa =_ede +1;{_fae ._bga .IsExponential =true ;};goto _bcg ;_cc :_acaa =_ede +1;{_fae ._bga .AddToken (FmtTypeLiteral ,_aac [_ccf +1:_acaa ]);};goto _bcg ;_bcg :_ccf =0;if _ede ++;_ede ==_bfg {goto _efeg ;};_ceag :_ccf =_ede ;switch _aac [_ede ]{case 34:goto _cf ;case 35:goto _bdff ;case 36:goto _cggc ;case 37:goto _cegf ;case 44:goto _fdbf ;case 46:goto _ffba ;case 47:goto _cdcb ;case 48:goto _ed ;case 58:goto _dac ;case 59:goto _bg ;case 63:goto _eaa ;case 64:goto _age ;case 65:goto _cecd ;case 69:goto _eefa ;case 71:goto _dcc ;case 91:goto _bdd ;case 92:goto _dfee ;case 95:goto _cb ;case 100:goto _cdcb ;case 104:goto _dac ;case 109:goto _cd ;case 115:goto _eddd ;case 121:goto _abg ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _egb ;};goto _fcf ;_cf :_acaa =_ede +1;_fad =20;goto _agg ;_agg :if _ede ++;_ede ==_bfg {goto _ged ;};_ccca :if _aac [_ede ]==34{goto _agfac ;};goto _gebd ;_gebd :if _ede ++;_ede ==_bfg {goto _cecf ;};_gaaa :if _aac [_ede ]==34{goto _agfac ;};goto _gebd ;_agfac :_acaa =_ede +1;_fad =21;goto _cge ;_cge :if _ede ++;_ede ==_bfg {goto _d ;};_dca :if _aac [_ede ]==34{goto _gebd ;};goto _deafg ;_bdff :_acaa =_ede +1;_fad =3;goto _dge ;_dge :if _ede ++;_ede ==_bfg {goto _fa ;};_gg :switch _aac [_ede ]{case 35:goto _adbg ;case 37:goto _adbg ;case 44:goto _ccfc ;case 47:goto _gge ;case 48:goto _adbg ;case 63:goto _adbg ;};goto _ebb ;_adbg :if _ede ++;_ede ==_bfg {goto _fge ;};_bfgg :switch _aac [_ede ]{case 35:goto _adbg ;case 37:goto _adbg ;case 47:goto _gge ;case 48:goto _adbg ;case 63:goto _adbg ;};goto _gcbg ;_gge :if _ede ++;_ede ==_bfg {goto _beg ;};_agdg :switch _aac [_ede ]{case 35:goto _dff ;case 37:goto _cab ;case 48:goto _afgb ;case 63:goto _dff ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _efgf ;};goto _gcbg ;_dff :_acaa =_ede +1;goto _dea ;_dea :if _ede ++;_ede ==_bfg {goto _ae ;};_ebf :switch _aac [_ede ]{case 35:goto _dff ;case 37:goto _dff ;case 44:goto _dff ;case 46:goto _dff ;case 48:goto _dff ;case 63:goto _dff ;case 65:goto _dbb ;};goto _cdf ;_dbb :if _ede ++;_ede ==_bfg {goto _ggdf ;};_dg :switch _aac [_ede ]{case 47:goto _g ;case 77:goto _aeb ;};goto _fbf ;_g :if _ede ++;_ede ==_bfg {goto _dab ;};_eac :if _aac [_ede ]==80{goto _cdbe ;};goto _fbf ;_cdbe :_acaa =_ede +1;goto _aad ;_aad :if _ede ++;_ede ==_bfg {goto _feaa ;};_e :if _aac [_ede ]==65{goto _dbb ;};goto _cdf ;_aeb :if _ede ++;_ede ==_bfg {goto _aba ;};_gfb :if _aac [_ede ]==47{goto _agffd ;};goto _fbf ;_agffd :if _ede ++;_ede ==_bfg {goto _cad ;};_dfa :if _aac [_ede ]==80{goto _cbgb ;};goto _fbf ;_cbgb :if _ede ++;_ede ==_bfg {goto _afgd ;};_bfc :if _aac [_ede ]==77{goto _cdbe ;};goto _fbf ;_cab :if _ede ++;_ede ==_bfg {goto _ebd ;};_bbeg :switch _aac [_ede ]{case 35:goto _agd ;case 37:goto _adec ;case 63:goto _agd ;};if 48<=_aac [_ede ]&&_aac [_ede ]<=57{goto _gbb ;};goto _gcbg ;_agd :_acaa =_ede +1;goto _abb ;_abb :if _ede ++;_ede ==_bfg {goto _cg ;};_efd :switch _aac [_ede ]{case 35:goto _dff ;case 37:goto _bded ;case 44:goto _dff ;case 46:goto _dff ;case 48:goto _dff ;case 63:goto _dff ;case 65:goto _dbb ;};goto _cdf ;_bded :if _ede ++;_ede ==_bfg {goto _edg ;};_dccf :switch _aac [_ede ]{case 35:goto _agff ;case 44:goto _agff ;case 46:goto _agff ;case 48:goto _agff ;case 63:goto _agff ;};goto _fbf ;_agff :_acaa =_ede +1;goto _ceac ;_ceac :if _ede ++;_ede ==_bfg {goto _gfe ;};_gd :switch _aac [_ede ]{case 35:goto _agff ;case 44:goto _agff ;case 46:goto _agff ;case 48:goto _agff ;case 63:goto _agff ;case 65:goto _dbb ;};goto _cdf ;_adec :if _ede ++;_ede ==_bfg {goto _feac ;};_ec :if _aac [_ede ]==37{goto _adec ;};if 48<=_aac [_ede ]&&_aac [_ede ]<=57{goto _gbb ;};goto _gcbg ;_gbb :_acaa =_ede +1;_fad =13;goto _af ;_af :if _ede ++;_ede ==_bfg {goto _edea ;};_aaf :switch _aac [_ede ]{case 35:goto _dff ;case 37:goto _adb ;case 44:goto _dff ;case 46:goto _dff ;case 48:goto _eef ;case 63:goto _dff ;case 65:goto _dbb ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _gbb ;};goto _cdf ;_adb :if _ede ++;_ede ==_bfg {goto _bcc ;};_fgab :switch _aac [_ede ]{case 35:goto _agff ;case 37:goto _adec ;case 44:goto _agff ;case 46:goto _agff ;case 63:goto _agff ;};if 48<=_aac [_ede ]&&_aac [_ede ]<=57{goto _gbb ;};goto _fbf ;_eef :_acaa =_ede +1;goto _eaf ;_eaf :if _ede ++;_ede ==_bfg {goto _ggdfe ;};_ccce :switch _aac [_ede ]{case 35:goto _dff ;case 37:goto _eef ;case 44:goto _dff ;case 46:goto _dff ;case 48:goto _eef ;case 63:goto _dff ;case 65:goto _dbb ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _gbb ;};goto _cdf ;_afgb :_acaa =_ede +1;goto _cbdf ;_cbdf :if _ede ++;_ede ==_bfg {goto _aaa ;};_gda :switch _aac [_ede ]{case 35:goto _dff ;case 37:goto _eef ;case 44:goto _dff ;case 46:goto _dff ;case 48:goto _afgb ;case 63:goto _dff ;case 65:goto _dbb ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _efgf ;};goto _cdf ;_efgf :_acaa =_ede +1;goto _aebf ;_aebf :if _ede ++;_ede ==_bfg {goto _ab ;};_ffdb :switch _aac [_ede ]{case 35:goto _dff ;case 37:goto _gbb ;case 44:goto _dff ;case 46:goto _dff ;case 48:goto _afgb ;case 63:goto _dff ;case 65:goto _dbb ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _efgf ;};goto _cdf ;_ccfc :if _ede ++;_ede ==_bfg {goto _bdg ;};_aed :if _aac [_ede ]==35{goto _fdab ;};goto _edec ;_cegf :_acaa =_ede +1;_fad =8;goto _bcd ;_bcd :if _ede ++;_ede ==_bfg {goto _aaea ;};_baf :switch _aac [_ede ]{case 35:goto _ade ;case 37:goto _fade ;case 48:goto _aeg ;case 63:goto _ade ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _bbgg ;};goto _beb ;_ade :if _ede ++;_ede ==_bfg {goto _bff ;};_ace :switch _aac [_ede ]{case 35:goto _ade ;case 47:goto _gge ;case 48:goto _ade ;case 63:goto _ade ;};goto _bagb ;_fade :if _ede ++;_ede ==_bfg {goto _ggdg ;};_gdf :if _aac [_ede ]==37{goto _fade ;};if 48<=_aac [_ede ]&&_aac [_ede ]<=57{goto _bbgg ;};goto _gcbg ;_bbgg :if _ede ++;_ede ==_bfg {goto _fda ;};_dcg :switch _aac [_ede ]{case 37:goto _fade ;case 47:goto _gge ;};if 48<=_aac [_ede ]&&_aac [_ede ]<=57{goto _bbgg ;};goto _gcbg ;_aeg :if _ede ++;_ede ==_bfg {goto _cegg ;};_cac :switch _aac [_ede ]{case 35:goto _ade ;case 37:goto _fade ;case 47:goto _gge ;case 48:goto _aeg ;case 63:goto _ade ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _bbgg ;};goto _bagb ;_cdcb :_acaa =_ede +1;goto _acc ;_acc :if _ede ++;_ede ==_bfg {goto _ceg ;};_gcb :switch _aac [_ede ]{case 47:goto _cdcb ;case 100:goto _cdcb ;case 109:goto _cdcb ;case 121:goto _bedd ;};goto _eee ;_bedd :if _ede ++;_ede ==_bfg {goto _cdde ;};_agf :if _aac [_ede ]==121{goto _cdcb ;};goto _abd ;_ed :_acaa =_ede +1;_fad =2;goto _dgd ;_dgd :if _ede ++;_ede ==_bfg {goto _fc ;};_ddba :switch _aac [_ede ]{case 35:goto _adbg ;case 37:goto _fbbb ;case 47:goto _gge ;case 48:goto _eea ;case 63:goto _adbg ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _agee ;};goto _ecb ;_fbbb :if _ede ++;_ede ==_bfg {goto _gcgg ;};_a :switch _aac [_ede ]{case 35:goto _adbg ;case 37:goto _fbbb ;case 47:goto _gge ;case 48:goto _fbbb ;case 63:goto _adbg ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _bbgg ;};goto _bbg ;_eea :if _ede ++;_ede ==_bfg {goto _ba ;};_agga :switch _aac [_ede ]{case 35:goto _adbg ;case 37:goto _fbbb ;case 47:goto _gge ;case 48:goto _eea ;case 63:goto _adbg ;};if 49<=_aac [_ede ]&&_aac [_ede ]<=57{goto _agee ;};goto _bbg ;_agee :if _ede ++;_ede ==_bfg {goto _aaac ;};_cbf :switch _aac [_ede ]{case 37:goto _bbgg ;case 47:goto _gge ;};if 48<=_aac [_ede ]&&_aac [_ede ]<=57{goto _agee ;};goto _gcbg ;_egb :_acaa =_ede +1;_fad =20;goto _dgf ;_dgf :if _ede ++;_ede ==_bfg {goto _dfed ;};_dfea :switch _aac [_ede ]{case 37:goto _bbgg ;case 47:goto _gge ;};if 48<=_aac [_ede ]&&_aac [_ede ]<=57{goto _agee ;};goto _dgb ;_dac :_acaa =_ede +1;_fad =15;goto _eda ;_eda :if _ede ++;_ede ==_bfg {goto _bcbc ;};_dad :switch _aac [_ede ]{case 58:goto _dac ;case 65:goto _cdd ;case 104:goto _dac ;case 109:goto _dac ;case 115:goto _eddd ;};goto _ffa ;_cdd :if _ede ++;_ede ==_bfg {goto _edcd ;};_fdc :switch _aac [_ede ]{case 47:goto _cfe ;case 77:goto _fdce ;};goto _gcbg ;_cfe :if _ede ++;_ede ==_bfg {goto _cae ;};_dfba :if _aac [_ede ]==80{goto _dac ;};goto _gcbg ;_fdce :if _ede ++;_ede ==_bfg {goto _cbb ;};_abee :if _aac [_ede ]==47{goto _eegc ;};goto _gcbg ;_eegc :if _ede ++;_ede ==_bfg {goto _agfa ;};_ffb :if _aac [_ede ]==80{goto _cbg ;};goto _gcbg ;_cbg :if _ede ++;_ede ==_bfg {goto _egg ;};_gad :if _aac [_ede ]==77{goto _dac ;};goto _gcbg ;_eddd :_acaa =_ede +1;_fad =15;goto _edd ;_edd :if _ede ++;_ede ==_bfg {goto _bab ;};_gfg :switch _aac [_ede ]{case 46:goto _cgdf ;case 58:goto _dac ;case 65:goto _cdd ;case 104:goto _dac ;case 109:goto _dac ;case 115:goto _eddd ;};goto _ffa ;_cgdf :if _ede ++;_ede ==_bfg {goto _fgd ;};_gaaf :if _aac [_ede ]==48{goto _cfb ;};goto _df ;_cfb :_acaa =_ede +1;_fad =15;goto _dcea ;_dcea :if _ede ++;_ede ==_bfg {goto _bfga ;};_gafe :switch _aac [_ede ]{case 48:goto _edabg ;case 58:goto _dac ;case 65:goto _cdd ;case 104:goto _dac ;case 109:goto _dac ;case 115:goto _eddd ;};goto _ffa ;_edabg :_acaa =_ede +1;_fad =15;goto _bcea ;_bcea :if _ede ++;_ede ==_bfg {goto _fg ;};_cgg :switch _aac [_ede ]{case 48:goto _dac ;case 58:goto _dac ;case 65:goto _cdd ;case 104:goto _dac ;case 109:goto _dac ;case 115:goto _eddd ;};goto _ffa ;_eaa :_acaa =_ede +1;_fad =5;goto _bde ;_bde :if _ede ++;_ede ==_bfg {goto _gac ;};_ag :switch _aac [_ede ]{case 35:goto _adbg ;case 37:goto _adbg ;case 47:goto _gge ;case 48:goto _adbg ;case 63:goto _adbg ;};goto _bcgae ;_cecd :_acaa =_ede +1;_fad =20;goto _eeac ;_eeac :if _ede ++;_ede ==_bfg {goto _edc ;};_bbc :switch _aac [_ede ]{case 47:goto _cfe ;case 77:goto _fdce ;};goto _dgb ;_eefa :if _ede ++;_ede ==_bfg {goto _bb ;};_eed :switch _aac [_ede ]{case 43:goto _bae ;case 45:goto _bae ;};goto _dgb ;_dcc :_acaa =_ede +1;goto _gcbe ;_gcbe :if _ede ++;_ede ==_bfg {goto _bec ;};_dfc :if _aac [_ede ]==101{goto _dda ;};goto _dgb ;_dda :if _ede ++;_ede ==_bfg {goto _eeg ;};_ccb :if _aac [_ede ]==110{goto _ebe ;};goto _gbe ;_ebe :if _ede ++;_ede ==_bfg {goto _bed ;};_cbac :if _aac [_ede ]==101{goto _gdb ;};goto _gbe ;_gdb :if _ede ++;_ede ==_bfg {goto _afcc ;};_fbd :if _aac [_ede ]==114{goto _gcg ;};goto _gbe ;_gcg :if _ede ++;_ede ==_bfg {goto _ggf ;};_gedd :if _aac [_ede ]==97{goto _bdge ;};goto _gbe ;_bdge :if _ede ++;_ede ==_bfg {goto _edb ;};_bdf :if _aac [_ede ]==108{goto _fbe ;};goto _gbe ;_bdd :_acaa =_ede +1;_fad =20;goto _aceg ;_aceg :if _ede ++;_ede ==_bfg {goto _ebc ;};_ggd :switch _aac [_ede ]{case 104:goto _cce ;case 109:goto _cce ;case 115:goto _cce ;};goto _feg ;_feg :if _ede ++;_ede ==_bfg {goto _dga ;};_abeg :if _aac [_ede ]==93{goto _ddg ;};goto _feg ;_ddg :_acaa =_ede +1;_fad =18;goto _geb ;_efc :_acaa =_ede +1;_fad =16;goto _geb ;_geb :if _ede ++;_ede ==_bfg {goto _bfd ;};_fdd :if _aac [_ede ]==93{goto _ddg ;};goto _feg ;_cce :if _ede ++;_ede ==_bfg {goto _edae ;};_ga :if _aac [_ede ]==93{goto _efc ;};goto _feg ;_dfee :if _ede ++;_ede ==_bfg {goto _fba ;};_efad :goto _cc ;_cd :_acaa =_ede +1;_fad =14;goto _eag ;_eag :if _ede ++;_ede ==_bfg {goto _ce ;};_begd :switch _aac [_ede ]{case 47:goto _cdcb ;case 58:goto _dac ;case 65:goto _cdd ;case 100:goto _cdcb ;case 104:goto _dac ;case 109:goto _cd ;case 115:goto _eddd ;case 121:goto _bedd ;};goto _eee ;_abg :if _ede ++;_ede ==_bfg {goto _bfea ;};_edad :if _aac [_ede ]==121{goto _cdcb ;};goto _dgb ;_fdba :_efeg :_bdfg =34;goto _dbd ;_ged :_bdfg =35;goto _dbd ;_cecf :_bdfg =0;goto _dbd ;_d :_bdfg =36;goto _dbd ;_fa :_bdfg =37;goto _dbd ;_fge :_bdfg =1;goto _dbd ;_beg :_bdfg =2;goto _dbd ;_ae :_bdfg =38;goto _dbd ;_ggdf :_bdfg =3;goto _dbd ;_dab :_bdfg =4;goto _dbd ;_feaa :_bdfg =39;goto _dbd ;_aba :_bdfg =5;goto _dbd ;_cad :_bdfg =6;goto _dbd ;_afgd :_bdfg =7;goto _dbd ;_ebd :_bdfg =8;goto _dbd ;_cg :_bdfg =40;goto _dbd ;_edg :_bdfg =9;goto _dbd ;_gfe :_bdfg =41;goto _dbd ;_feac :_bdfg =10;goto _dbd ;_edea :_bdfg =42;goto _dbd ;_bcc :_bdfg =11;goto _dbd ;_ggdfe :_bdfg =43;goto _dbd ;_aaa :_bdfg =44;goto _dbd ;_ab :_bdfg =45;goto _dbd ;_bdg :_bdfg =12;goto _dbd ;_aaea :_bdfg =46;goto _dbd ;_bff :_bdfg =13;goto _dbd ;_ggdg :_bdfg =14;goto _dbd ;_fda :_bdfg =15;goto _dbd ;_cegg :_bdfg =16;goto _dbd ;_ceg :_bdfg =47;goto _dbd ;_cdde :_bdfg =17;goto _dbd ;_fc :_bdfg =48;goto _dbd ;_gcgg :_bdfg =18;goto _dbd ;_ba :_bdfg =19;goto _dbd ;_aaac :_bdfg =20;goto _dbd ;_dfed :_bdfg =49;goto _dbd ;_bcbc :_bdfg =50;goto _dbd ;_edcd :_bdfg =21;goto _dbd ;_cae :_bdfg =22;goto _dbd ;_cbb :_bdfg =23;goto _dbd ;_agfa :_bdfg =24;goto _dbd ;_egg :_bdfg =25;goto _dbd ;_bab :_bdfg =51;goto _dbd ;_fgd :_bdfg =26;goto _dbd ;_bfga :_bdfg =52;goto _dbd ;_fg :_bdfg =53;goto _dbd ;_gac :_bdfg =54;goto _dbd ;_edc :_bdfg =55;goto _dbd ;_bb :_bdfg =56;goto _dbd ;_bec :_bdfg =57;goto _dbd ;_eeg :_bdfg =27;goto _dbd ;_bed :_bdfg =28;goto _dbd ;_afcc :_bdfg =29;goto _dbd ;_ggf :_bdfg =30;goto _dbd ;_edb :_bdfg =31;goto _dbd ;_ebc :_bdfg =58;goto _dbd ;_dga :_bdfg =32;goto _dbd ;_bfd :_bdfg =59;goto _dbd ;_edae :_bdfg =33;goto _dbd ;_fba :_bdfg =60;goto _dbd ;_ce :_bdfg =61;goto _dbd ;_bfea :_bdfg =62;goto _dbd ;_dbd :{};if _ede ==_gfc {switch _bdfg {case 35:goto _dgb ;case 0:goto _gcbg ;case 36:goto _deafg ;case 37:goto _ebb ;case 1:goto _gcbg ;case 2:goto _gcbg ;case 38:goto _cdf ;case 3:goto _fbf ;case 4:goto _fbf ;case 39:goto _cdf ;case 5:goto _fbf ;case 6:goto _fbf ;case 7:goto _fbf ;case 8:goto _gcbg ;case 40:goto _cdf ;case 9:goto _fbf ;case 41:goto _cdf ;case 10:goto _gcbg ;case 42:goto _cdf ;case 11:goto _fbf ;case 43:goto _cdf ;case 44:goto _cdf ;case 45:goto _cdf ;case 12:goto _edec ;case 46:goto _beb ;case 13:goto _bagb ;case 14:goto _gcbg ;case 15:goto _gcbg ;case 16:goto _bagb ;case 47:goto _eee ;case 17:goto _abd ;case 48:goto _ecb ;case 18:goto _bbg ;case 19:goto _bbg ;case 20:goto _gcbg ;case 49:goto _dgb ;case 50:goto _ffa ;case 21:goto _gcbg ;case 22:goto _gcbg ;case 23:goto _gcbg ;case 24:goto _gcbg ;case 25:goto _gcbg ;case 51:goto _ffa ;case 26:goto _df ;case 52:goto _ffa ;case 53:goto _ffa ;case 54:goto _bcgae ;case 55:goto _dgb ;case 56:goto _dgb ;case 57:goto _dgb ;case 27:goto _gbe ;case 28:goto _gbe ;case 29:goto _gbe ;case 30:goto _gbe ;case 31:goto _gbe ;case 58:goto _dgb ;case 32:goto _gcbg ;case 59:goto _gcbg ;case 33:goto _gbe ;case 60:goto _dgb ;case 61:goto _eee ;case 62:goto _dgb ;};};};if _ccf > 0{copy (_aac [0:],_aac [_ccf :]);};};_ =_gfc ;if _bdfg ==_dgga {_daa .Log ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};const _dgga int =-1;func (_fff FmtType )String ()string {if _fff >=FmtType (len (_add )-1){return _fe .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_fff );};return _ea [_add [_fff ]:_add [_fff +1]];};func _eacf (_be ,_affc float64 ,_cggd Format )[]byte {if len (_cggd .Fractional )==0{return nil ;};_caeff :=_dgff .AppendFloat (nil ,_be ,'f',-1,64);if len (_caeff )> 2{_caeff =_caeff [2:];}else {_caeff =nil ;};_bfe :=make ([]byte ,0,len (_caeff ));_bfe =append (_bfe ,'.');_aea :=0;_cda :for _abfd :=0;_abfd < len (_cggd .Fractional );_abfd ++{_cccb :=_abfd ;_bf :=_cggd .Fractional [_abfd ];switch _bf .Type {case FmtTypeDigit :if _cccb < len (_caeff ){_bfe =append (_bfe ,_caeff [_cccb ]);_aea ++;}else {_bfe =append (_bfe ,'0');};case FmtTypeDigitOpt :if _cccb >=0{_bfe =append (_bfe ,_caeff [_cccb ]);_aea ++;}else {break _cda ;};case FmtTypeLiteral :_bfe =append (_bfe ,_bf .Literal );default:_daa .Log ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_bf );};};return _bfe ;};const _bcga int =34;func _fbbc (_eb []byte )[]byte {_cef :=len (_eb );_ee :=false ;_ffc :=false ;for _bedb :=len (_eb )-1;_bedb >=0;_bedb --{if _eb [_bedb ]=='0'&&!_ffc &&!_ee {_cef =_bedb ;}else if _eb [_bedb ]=='.'{_ee =true ;}else {_ffc =true ;};};if _ee &&_ffc {if _eb [_cef -1]=='.'{_cef --;};return _eb [0:_cef ];};return _eb ;};const _dgfb int =34;func _faf (_eafa _gcc .Time )_gcc .Time {_eafa =_eafa .UTC ();return _gcc .Date (_eafa .Year (),_eafa .Month (),_eafa .Day (),_eafa .Hour (),_eafa .Minute (),_eafa .Second (),_eafa .Nanosecond (),_gcc .Local );};func _gbc (_edbg []byte )[]byte {for _fb :=0;_fb < len (_edbg )/2;_fb ++{_edgc :=len (_edbg )-1-_fb ;_edbg [_fb ],_edbg [_edgc ]=_edbg [_edgc ],_edbg [_fb ];};return _edbg ;};func Parse (s string )[]Format {_cdaf :=Lexer {};_cdaf .Lex (_fga .NewReader (s ));_cdaf ._ece =append (_cdaf ._ece ,_cdaf ._bga );return _cdaf ._ece ;};

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte ;

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_gca ,_ :=_dgff .ParseFloat (v ,64);return Number (_gca ,f );};return String (v ,f );};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_deg :=Parse (f );var _dcb Format ;if len (_deg )==1{_dcb =_deg [0];}else if len (_deg )==4{_dcb =_deg [3];};_bage :=false ;for _ ,_bd :=range _dcb .Whole {if _bd .Type ==FmtTypeText {_bage =true ;};};if !_bage {return v ;};_baa :=_eceb .Buffer {};for _ ,_gga :=range _dcb .Whole {switch _gga .Type {case FmtTypeLiteral :_baa .WriteByte (_gga .Literal );case FmtTypeText :_baa .WriteString (v );};};return _baa .String ();};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_c bool ;_edca bool ;_aebfd bool ;_fea bool ;_dfb bool ;_dgc bool ;_dce int64 ;_gcbc int ;};