//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_fccde "archive/zip";_edc "errors";_beba "fmt";_fcgc "github.com/unidoc/unioffice";_bfde "github.com/unidoc/unioffice/chart";_gbda "github.com/unidoc/unioffice/color";_gfdb "github.com/unidoc/unioffice/common";_dgab "github.com/unidoc/unioffice/common/license";_aag "github.com/unidoc/unioffice/measurement";_eada "github.com/unidoc/unioffice/schema/soo/dml";_aegbf "github.com/unidoc/unioffice/schema/soo/dml/chart";_gcge "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_cdcd "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_efed "github.com/unidoc/unioffice/schema/soo/sml";_eagd "github.com/unidoc/unioffice/spreadsheet/format";_acdfa "github.com/unidoc/unioffice/spreadsheet/formula";_cgebb "github.com/unidoc/unioffice/spreadsheet/reference";_caa "github.com/unidoc/unioffice/spreadsheet/update";_cdbe "github.com/unidoc/unioffice/vmldrawing";_fgc "github.com/unidoc/unioffice/zippkg";_ffe "image";_fccd "image/jpeg";_afdf "io";_gfbac "io/ioutil";_bfa "log";_aggf "math";_dfb "math/big";_gccb "os";_bcfb "path/filepath";_beg "regexp";_gcg "runtime";_bae "runtime/debug";_efac "sort";_ggfd "strconv";_babc "strings";_dfga "time";);type Table struct{_eg *_efed .Table };const (_faf ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";_fccbb ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";_bgfc ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";_dbae ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";);

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_gca *_efed .CT_Font ;_acefe *_efed .StyleSheet ;};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_fbba SheetView )SetState (st _efed .ST_PaneState ){_fbba .ensurePane ();_fbba ._cbbc .Pane .StateAttr =st ;};

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_egcd *_efed .CT_Rst };func (_efc *Sheet )setArray (_dffg string ,_fcaa _acdfa .Result )error {_cbg ,_fcacg :=_cgebb .ParseCellReference (_dffg );if _fcacg !=nil {return _fcacg ;};for _cggdc ,_deeda :=range _fcaa .ValueArray {_gaead :=_efc .Row (_cbg .RowIdx +uint32 (_cggdc ));for _dbd ,_fdag :=range _deeda {_aggg :=_gaead .Cell (_cgebb .IndexToColumn (_cbg .ColumnIdx +uint32 (_dbd )));if _fdag .Type !=_acdfa .ResultTypeEmpty {if _fdag .IsBoolean {_aggg .SetBool (_fdag .ValueNumber !=0);}else {_aggg .SetCachedFormulaResult (_fdag .String ());};};};};return nil ;};

// IsBool returns true if the cell boolean value.
func (_eced *evalContext )IsBool (cellRef string )bool {return _eced ._eee .Cell (cellRef ).IsBool ()};

// SetStyle sets the style to be used for conditional rules
func (_daaa ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_daaa ._defb .DxfIdAttr =_fcgc .Uint32 (d .Index ());};

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_cdd *evalContext )LastColumn (rowFrom ,rowTo int )string {_geag :=_cdd ._eee ;_cbba :=1;for _dbcg :=rowFrom ;_dbcg <=rowTo ;_dbcg ++{_eggc :=len (_geag .Row (uint32 (_dbcg )).Cells ());if _eggc > _cbba {_cbba =_eggc ;};};return _cgebb .IndexToColumn (uint32 (_cbba -1));};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_gbege CellStyle )SetNumberFormatStandard (s StandardFormat ){_gbege ._ddbb .NumFmtIdAttr =_fcgc .Uint32 (uint32 (s ));_gbege ._ddbb .ApplyNumberFormatAttr =_fcgc .Bool (true );};func _agc (_acbc *Sheet )*evalContext {return &evalContext {_eee :_acbc ,_dbda :make (map[string ]struct{})};};

// AddBorder creates a new empty border that can be applied to a cell style.
func (_efcf StyleSheet )AddBorder ()Border {_bcgg :=_efed .NewCT_Border ();_efcf ._deb .Borders .Border =append (_efcf ._deb .Borders .Border ,_bcgg );_efcf ._deb .Borders .CountAttr =_fcgc .Uint32 (uint32 (len (_efcf ._deb .Borders .Border )));return Border {_bcgg ,_efcf ._deb .Borders };};const (DVCompareOpEqual =DVCompareOp (_efed .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_efed .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_efed .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_efed .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_efed .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_efed .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_efed .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_efed .ST_DataValidationOperatorLessThanOrEqual ););func NewFills ()Fills {return Fills {_efed .NewCT_Fills ()}};

// SetFont sets the font name for a rich text run.
func (_bafe RichTextRun )SetFont (s string ){_bafe .ensureRpr ();_bafe ._efec .RPr .RFont =_efed .NewCT_FontName ();_bafe ._efec .RPr .RFont .ValAttr =s ;};

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_cgcd Row )Cells ()[]Cell {_fca :=[]Cell {};_bgd :=-1;for _ ,_cba :=range _cgcd ._dcaa .C {if _cba .RAttr ==nil {_fcgc .Log ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_fcd ,_fbgf :=_cgebb .ParseCellReference (*_cba .RAttr );if _fbgf !=nil {_fcgc .Log ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_cba .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_gbd :=int (_fcd .ColumnIdx );if _gbd -_bgd > 1{for _bcgag :=_bgd +1;_bcgag < _gbd ;_bcgag ++{_fca =append (_fca ,_cgcd .Cell (_cgebb .IndexToColumn (uint32 (_bcgag ))));};};_bgd =_gbd ;_fca =append (_fca ,Cell {_cgcd ._gcbf ,_cgcd ._bcdf ,_cgcd ._dcaa ,_cba });};return _fca ;};

// SetStyle applies a style to the cell.  This style is referenced in the
// generated XML via CellStyle.Index().
func (_gcf Cell )SetStyle (cs CellStyle ){_gcf .SetStyleIndex (cs .Index ())};

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_bbaf Cell )SetStringByID (id int ){_bbaf ._dcbg .ensureSharedStringsRelationships ();_bbaf .clearValue ();_bbaf ._ecbe .V =_fcgc .String (_ggfd .Itoa (id ));_bbaf ._ecbe .TAttr =_efed .ST_CellTypeS ;};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_bcce *evalContext )GetLabelPrefix (cellRef string )string {return _bcce ._eee .Cell (cellRef ).getLabelPrefix ();};var (_def =[...]uint8 {0,21,46,61,76,91};_agf =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_fagae =[...]uint8 {0,16,32,48,64};_abfcc =[...]uint8 {0,16,32,48,64,80};);func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_egc :=NumberFormat {_ceea :_efed .NewCT_NumFmt ()};_egc ._ceea .NumFmtIdAttr =uint32 (id );_egc ._ceea .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_egc ._ceea .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_egc ._ceea .FormatCodeAttr ="\u0030";case StandardFormat2 :_egc ._ceea .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_egc ._ceea .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_egc ._ceea .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_egc ._ceea .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_egc ._ceea .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_egc ._ceea .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";case StandardFormat12 :_egc ._ceea .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_egc ._ceea .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_egc ._ceea .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";case StandardFormat15 :_egc ._ceea .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_egc ._ceea .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_egc ._ceea .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat18 :_egc ._ceea .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_egc ._ceea .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_egc ._ceea .FormatCodeAttr ="\u0068\u003a\u006d\u006d";case StandardFormat21 :_egc ._ceea .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_egc ._ceea .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_egc ._ceea .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";case StandardFormat38 :_egc ._ceea .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_egc ._ceea .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat40 :_egc ._ceea .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_egc ._ceea .FormatCodeAttr ="\u006d\u006d\u003as\u0073";case StandardFormat46 :_egc ._ceea .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_egc ._ceea .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_egc ._ceea .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";case StandardFormat49 :_egc ._ceea .FormatCodeAttr ="\u0040";};return _egc ;};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_efec *_efed .CT_RElt };

// IsBool returns true if the cell is a boolean type cell.
func (_fagcb Cell )IsBool ()bool {return _fagcb ._ecbe .TAttr ==_efed .ST_CellTypeB };

// Protection allows control over the workbook protections.
func (_daee *Workbook )Protection ()WorkbookProtection {if _daee ._fbc .WorkbookProtection ==nil {_daee ._fbc .WorkbookProtection =_efed .NewCT_WorkbookProtection ();};return WorkbookProtection {_daee ._fbc .WorkbookProtection };};func (_eec ConditionalFormattingRule )InitializeDefaults (){_eec .SetType (_efed .ST_CfTypeCellIs );_eec .SetOperator (_efed .ST_ConditionalFormattingOperatorGreaterThan );_eec .SetPriority (1);};

// SetItalic causes the text to be displayed in italic.
func (_baf RichTextRun )SetItalic (b bool ){_baf .ensureRpr ();_baf ._efec .RPr .I =_efed .NewCT_BooleanProperty ();_baf ._efec .RPr .I .ValAttr =_fcgc .Bool (b );};

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_fcee *Workbook )SetActiveSheet (s Sheet ){for _cefg ,_dfge :=range _fcee ._cbef {if s ._ed ==_dfge {_fcee .SetActiveSheetIndex (uint32 (_cefg ));};};};func (_eae Fill )SetPatternFill ()PatternFill {_eae ._fagab .GradientFill =nil ;_eae ._fagab .PatternFill =_efed .NewCT_PatternFill ();_eae ._fagab .PatternFill .PatternTypeAttr =_efed .ST_PatternTypeSolid ;return PatternFill {_eae ._fagab .PatternFill ,_eae ._fagab };};

// GetWidth returns a worksheet's column width.
func (_abgb *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_aceg :=range _abgb ._eee .X ().Cols [0].Col {if int (_aceg .MinAttr )<=colIdx &&colIdx <=int (_aceg .MaxAttr ){return float64 (int (*_aceg .WidthAttr ));};};return 0;};const (DVCompareTypeWholeNumber =DVCompareType (_efed .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_efed .ST_DataValidationTypeDecimal );DVCompareTypeDate =DVCompareType (_efed .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_efed .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_efed .ST_DataValidationTypeTextLength ););

// BottomRight is a no-op.
func (_fg OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};func (_gec Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _cgb ,_bddg ,_gdg ,_eadeg uint32 =1,1,0,0;for _ ,_fde :=range _gec .Rows (){if _fde .RowNumber ()< _cgb {_cgb =_fde .RowNumber ();}else if _fde .RowNumber ()> _bddg {_bddg =_fde .RowNumber ();};for _ ,_dfg :=range _fde .Cells (){_bac ,_eceg :=_cgebb .ParseCellReference (_dfg .Reference ());if _eceg ==nil {if _bac .ColumnIdx < _gdg {_gdg =_bac .ColumnIdx ;}else if _bac .ColumnIdx > _eadeg {_eadeg =_bac .ColumnIdx ;};};};};return _cgebb .IndexToColumn (_gdg ),_cgb ,_cgebb .IndexToColumn (_eadeg ),_bddg ;};

// X returns the inner wrapped XML type.
func (_dgdca Cell )X ()*_efed .CT_Cell {return _dgdca ._ecbe };type SheetProtection struct{_dgdf *_efed .CT_SheetProtection };

// GetValueAsNumber retrieves the cell's value as a number
func (_ae Cell )GetValueAsNumber ()(float64 ,error ){if _ae ._ecbe .V ==nil &&_ae ._ecbe .Is ==nil {return 0,nil ;};if _ae ._ecbe .TAttr ==_efed .ST_CellTypeS ||!_eagd .IsNumber (*_ae ._ecbe .V ){return _aggf .NaN (),_edc .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");};return _ggfd .ParseFloat (*_ae ._ecbe .V ,64);};

// SetRowOffset sets the row offset of the two cell anchor
func (_ebfa TwoCellAnchor )SetRowOffset (m _aag .Distance ){_baed :=m -_ebfa .TopLeft ().RowOffset ();_ebfa .TopLeft ().SetRowOffset (m );_ebfa .BottomRight ().SetRowOffset (_ebfa .BottomRight ().RowOffset ()+_baed );};

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_efed .Comments )Comments {return Comments {w ,x }};

// X returns the inner wrapped XML type.
func (_eafc SheetProtection )X ()*_efed .CT_SheetProtection {return _eafc ._dgdf };

// PasswordHash returns the hash of the workbook password.
func (_abf SheetProtection )PasswordHash ()string {if _abf ._dgdf .PasswordAttr ==nil {return "";};return *_abf ._dgdf .PasswordAttr ;};

// SetWidthCells is a no-op.
func (_cdag OneCellAnchor )SetWidthCells (int32 ){};func (_gada *evalContext )Sheet (name string )_acdfa .Context {for _ ,_aggc :=range _gada ._eee ._bdgb .Sheets (){if _aggc .Name ()==name {return _aggc .FormulaContext ();};};return _acdfa .InvalidReferenceContext ;};

// Operator returns the operator for the rule
func (_dfff ConditionalFormattingRule )Operator ()_efed .ST_ConditionalFormattingOperator {return _dfff ._defb .OperatorAttr ;};

// GetFormat returns a cell data format.
func (_eed *evalContext )GetFormat (cellRef string )string {return _eed ._eee .Cell (cellRef ).getFormat ()};func (_cfbf *Sheet )getAllCellsInFormulaArrays (_cgge bool )(map[string ]bool ,error ){_bbg :=_acdfa .NewEvaluator ();_eafg :=_cfbf .FormulaContext ();_aabbe :=map[string ]bool {};for _ ,_eggd :=range _cfbf .Rows (){for _ ,_gbfd :=range _eggd .Cells (){if _gbfd .X ().F !=nil {_gaea :=_gbfd .X ().F .Content ;if _gbfd .X ().F .TAttr ==_efed .ST_CellFormulaTypeArray {_gebbe :=_bbg .Eval (_eafg ,_gaea ).AsString ();if _gebbe .Type ==_acdfa .ResultTypeError {_fcgc .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_gaea ,_gebbe .ErrorMessage );_gbfd .X ().V =nil ;};if _gebbe .Type ==_acdfa .ResultTypeArray {_befeb ,_dccc :=_cgebb .ParseCellReference (_gbfd .Reference ());if _dccc !=nil {return map[string ]bool {},_dccc ;};if (_cgge &&len (_gebbe .ValueArray )==1)||(!_cgge &&len (_gebbe .ValueArray [0])==1){continue ;};for _dffgg ,_eafff :=range _gebbe .ValueArray {_ffab :=_befeb .RowIdx +uint32 (_dffgg );for _bdbd :=range _eafff {_aagb :=_cgebb .IndexToColumn (_befeb .ColumnIdx +uint32 (_bdbd ));_aabbe [_beba .Sprintf ("\u0025\u0073\u0025\u0064",_aagb ,_ffab )]=true ;};};}else if _gebbe .Type ==_acdfa .ResultTypeList {_ebbg ,_eadd :=_cgebb .ParseCellReference (_gbfd .Reference ());if _eadd !=nil {return map[string ]bool {},_eadd ;};if _cgge ||len (_gebbe .ValueList )==1{continue ;};_ccbc :=_ebbg .RowIdx ;for _cfd :=range _gebbe .ValueList {_age :=_cgebb .IndexToColumn (_ebbg .ColumnIdx +uint32 (_cfd ));_aabbe [_beba .Sprintf ("\u0025\u0073\u0025\u0064",_age ,_ccbc )]=true ;};};};};};};return _aabbe ,nil ;};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);func (_dgd *Workbook )onNewRelationship (_fefe *_fgc .DecodeMap ,_beefb ,_dcdf string ,_ddf []*_fccde .File ,_bgge *_cdcd .Relationship ,_bbf _fgc .Target )error {_bgda :=_fcgc .DocTypeSpreadsheet ;switch _dcdf {case _fcgc .OfficeDocumentType :_dgd ._fbc =_efed .NewWorkbook ();_fefe .AddTarget (_beefb ,_dgd ._fbc ,_dcdf ,0);_dgd ._fgga =_gfdb .NewRelationships ();_fefe .AddTarget (_fgc .RelationsPathFor (_beefb ),_dgd ._fgga .X (),_dcdf ,0);_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,0);case _fcgc .CorePropertiesType :_fefe .AddTarget (_beefb ,_dgd .CoreProperties .X (),_dcdf ,0);_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,0);case _fcgc .ExtendedPropertiesType :_fefe .AddTarget (_beefb ,_dgd .AppProperties .X (),_dcdf ,0);_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,0);case _fcgc .WorksheetType :_cg :=_efed .NewWorksheet ();_eead :=uint32 (len (_dgd ._cbef ));_dgd ._cbef =append (_dgd ._cbef ,_cg );_fefe .AddTarget (_beefb ,_cg ,_dcdf ,_eead );_cdga :=_gfdb .NewRelationships ();_fefe .AddTarget (_fgc .RelationsPathFor (_beefb ),_cdga .X (),_dcdf ,0);_dgd ._adec =append (_dgd ._adec ,_cdga );_dgd ._fbea =append (_dgd ._fbea ,nil );_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,len (_dgd ._cbef ));case _fcgc .StylesType :_dgd .StyleSheet =NewStyleSheet (_dgd );_fefe .AddTarget (_beefb ,_dgd .StyleSheet .X (),_dcdf ,0);_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,0);case _fcgc .ThemeType :_dg :=_eada .NewTheme ();_dgd ._aff =append (_dgd ._aff ,_dg );_fefe .AddTarget (_beefb ,_dg ,_dcdf ,0);_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,len (_dgd ._aff ));case _fcgc .SharedStringsType :_dgd .SharedStrings =NewSharedStrings ();_fefe .AddTarget (_beefb ,_dgd .SharedStrings .X (),_dcdf ,0);_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,0);case _fcgc .ThumbnailType :for _facd ,_cggd :=range _ddf {if _cggd ==nil {continue ;};if _cggd .Name ==_beefb {_cgebf ,_ggdf :=_cggd .Open ();if _ggdf !=nil {return _beba .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_ggdf );};_dgd .Thumbnail ,_ ,_ggdf =_ffe .Decode (_cgebf );_cgebf .Close ();if _ggdf !=nil {return _beba .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_ggdf );};_ddf [_facd ]=nil ;};};case _fcgc .ImageType :for _daf ,_adda :=range _ddf {if _adda ==nil {continue ;};if _adda .Name ==_beefb {_fdeb ,_dbf :=_fgc .ExtractToDiskTmp (_adda ,_dgd .TmpPath );if _dbf !=nil {return _dbf ;};_abeb ,_dbf :=_gfdb .ImageFromFile (_fdeb );if _dbf !=nil {return _dbf ;};_edab :=_gfdb .MakeImageRef (_abeb ,&_dgd .DocBase ,_dgd ._fgga );_dgd .Images =append (_dgd .Images ,_edab );_ddf [_daf ]=nil ;};};_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,len (_dgd .Images ));case _fcgc .DrawingType :_ecee :=_gcge .NewWsDr ();_aagc :=uint32 (len (_dgd ._gde ));_fefe .AddTarget (_beefb ,_ecee ,_dcdf ,_aagc );_dgd ._gde =append (_dgd ._gde ,_ecee );_ggcc :=_gfdb .NewRelationships ();_fefe .AddTarget (_fgc .RelationsPathFor (_beefb ),_ggcc .X (),_dcdf ,_aagc );_dgd ._fee =append (_dgd ._fee ,_ggcc );_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,len (_dgd ._gde ));case _fcgc .VMLDrawingType :_gafg :=_cdbe .NewContainer ();_cef :=uint32 (len (_dgd ._bgce ));_fefe .AddTarget (_beefb ,_gafg ,_dcdf ,_cef );_dgd ._bgce =append (_dgd ._bgce ,_gafg );case _fcgc .CommentsType :_dgd ._fbea [_bbf .Index ]=_efed .NewComments ();_fefe .AddTarget (_beefb ,_dgd ._fbea [_bbf .Index ],_dcdf ,_bbf .Index );_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,len (_dgd ._fbea ));case _fcgc .ChartType :_bccdc :=_aegbf .NewChartSpace ();_eaa :=uint32 (len (_dgd ._aeef ));_fefe .AddTarget (_beefb ,_bccdc ,_dcdf ,_eaa );_dgd ._aeef =append (_dgd ._aeef ,_bccdc );_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,len (_dgd ._aeef ));case _fcgc .TableType :_fafg :=_efed .NewTable ();_eaad :=uint32 (len (_dgd ._cefb ));_fefe .AddTarget (_beefb ,_fafg ,_dcdf ,_eaad );_dgd ._cefb =append (_dgd ._cefb ,_fafg );_bgge .TargetAttr =_fcgc .RelativeFilename (_bgda ,_bbf .Typ ,_dcdf ,len (_dgd ._cefb ));default:_fcgc .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_beefb ,_dcdf );};return nil ;};

// SetHeight is a nop-op.
func (_dbef TwoCellAnchor )SetHeight (h _aag .Distance ){};

// SetRow set the row of the cell marker.
func (_edbc CellMarker )SetRow (row int32 ){_edbc ._bbd .Row =row };func (_baec Font )SetBold (b bool ){if b {_baec ._gca .B =[]*_efed .CT_BooleanProperty {{}};}else {_baec ._gca .B =nil ;};};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_fgbf *evalContext )IsDBCS ()bool {_ccbb :=_fgbf ._eee ._bdgb .CoreProperties .X ().Language ;if _ccbb ==nil {return false ;};_dga :=string (_ccbb .Data );for _ ,_bcc :=range _afg {if _dga ==_bcc {return true ;};};return false ;};

// SaveToFile writes the workbook out to a file.
func (_ggeb *Workbook )SaveToFile (path string )error {_dgegb ,_agb :=_gccb .Create (path );if _agb !=nil {return _agb ;};defer _dgegb .Close ();return _ggeb .Save (_dgegb );};func (_ebce Fill )Index ()uint32 {if _ebce ._dgfd ==nil {return 0;};for _bgc ,_gagd :=range _ebce ._dgfd .Fill {if _ebce ._fagab ==_gagd {return uint32 (_bgc );};};return 0;};

// ClearNumberFormat removes any number formatting from the style.
func (_bbe CellStyle )ClearNumberFormat (){_bbe ._ddbb .NumFmtIdAttr =nil ;_bbe ._ddbb .ApplyNumberFormatAttr =nil ;};func (_adea *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _adea .getAllCellsInFormulaArrays (false );};

// GetValueAsBool retrieves the cell's value as a boolean
func (_cfee Cell )GetValueAsBool ()(bool ,error ){if _cfee ._ecbe .TAttr !=_efed .ST_CellTypeB {return false ,_edc .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");};if _cfee ._ecbe .V ==nil {return false ,_edc .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _ggfd .ParseBool (*_cfee ._ecbe .V );};func (_adeb Font )SetColor (c _gbda .Color ){_fedc :=_efed .NewCT_Color ();_dacf :="\u0066\u0066"+*c .AsRGBString ();_fedc .RgbAttr =&_dacf ;_adeb ._gca .Color =[]*_efed .CT_Color {_fedc };};func (_feg Cell )clearValue (){_feg ._ecbe .F =nil ;_feg ._ecbe .Is =nil ;_feg ._ecbe .V =nil ;_feg ._ecbe .TAttr =_efed .ST_CellTypeUnset ;};type DifferentialStyle struct{_efd *_efed .CT_Dxf ;_affg *Workbook ;_deed *_efed .CT_Dxfs ;};func (_fddfa StandardFormat )String ()string {switch {case 0<=_fddfa &&_fddfa <=4:return _faf [_def [_fddfa ]:_def [_fddfa +1]];case 9<=_fddfa &&_fddfa <=22:_fddfa -=9;return _fccbb [_agf [_fddfa ]:_agf [_fddfa +1]];case 37<=_fddfa &&_fddfa <=40:_fddfa -=37;return _bgfc [_fagae [_fddfa ]:_fagae [_fddfa +1]];case 45<=_fddfa &&_fddfa <=49:_fddfa -=45;return _dbae [_abfcc [_fddfa ]:_abfcc [_fddfa +1]];default:return _beba .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_fddfa );};};func _cfca (_dbaf _dfga .Time )_dfga .Time {_dbaf =_dbaf .UTC ();return _dfga .Date (_dbaf .Year (),_dbaf .Month (),_dbaf .Day (),_dbaf .Hour (),_dbaf .Minute (),_dbaf .Second (),_dbaf .Nanosecond (),_dfga .Local );};

// X returns the inner wrapped XML type.
func (_ebeeg ColorScale )X ()*_efed .CT_ColorScale {return _ebeeg ._gabec };

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_gfda *evalContext )LastRow (col string )int {_acb :=_gfda ._eee ;_b :=int (_cgebb .ColumnToIndex (col ));_fgbe :=1;for _ ,_gega :=range _acb ._ed .SheetData .Row {if _gega .RAttr !=nil {_fabfd :=Row {_acb ._bdgb ,_acb ,_gega };_ddcf :=len (_fabfd .Cells ());if _ddcf > _b {_fgbe =int (_fabfd .RowNumber ());};};};return _fgbe ;};

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_cad ConditionalFormattingRule )SetDataBar ()DataBarScale {_cad .clear ();_cad .SetType (_efed .ST_CfTypeDataBar );_cad ._defb .DataBar =_efed .NewCT_DataBar ();_cfec :=DataBarScale {_cad ._defb .DataBar };_cfec .SetShowValue (true );_cfec .SetMinLength (10);_cfec .SetMaxLength (90);return _cfec ;};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_ab Comment )SetAuthor (author string ){_ab ._gcd .AuthorIdAttr =Comments {_ab ._gfeb ,_ab ._egg }.getOrCreateAuthor (author );};

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_gbgd CellStyle )SetHorizontalAlignment (a _efed .ST_HorizontalAlignment ){if _gbgd ._ddbb .Alignment ==nil {_gbgd ._ddbb .Alignment =_efed .NewCT_CellAlignment ();};_gbgd ._ddbb .Alignment .HorizontalAttr =a ;_gbgd ._ddbb .ApplyAlignmentAttr =_fcgc .Bool (true );};

// CellMarker represents a cell position
type CellMarker struct{_bbd *_gcge .CT_Marker };

// Validate attempts to validate the structure of a workbook.
func (_gabbbc *Workbook )Validate ()error {if _gabbbc ==nil ||_gabbbc ._fbc ==nil {return _edc .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");};_adfa :=uint32 (0);for _ ,_cac :=range _gabbbc ._fbc .Sheets .Sheet {if _cac .SheetIdAttr > _adfa {_adfa =_cac .SheetIdAttr ;};};if _adfa !=uint32 (len (_gabbbc ._cbef )){return _beba .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_adfa ,len (_gabbbc ._cbef ));};_debf :=map[string ]struct{}{};for _bdg ,_cea :=range _gabbbc ._fbc .Sheets .Sheet {_ccff :=Sheet {_gabbbc ,_cea ,_gabbbc ._cbef [_bdg ]};if _ ,_bdaf :=_debf [_ccff .Name ()];_bdaf {return _beba .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_bdg ,_ccff .Name ());};_debf [_ccff .Name ()]=struct{}{};if _ggac :=_ccff .ValidateWithPath (_beba .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_bdg ));_ggac !=nil {return _ggac ;};if _ffg :=_ccff .Validate ();_ffg !=nil {return _ffg ;};};return nil ;};

// ClearAutoFilter removes the autofilters from the sheet.
func (_fdbe *Sheet )ClearAutoFilter (){_fdbe ._ed .AutoFilter =nil ;_abde :="\u0027"+_fdbe .Name ()+"\u0027\u0021";for _ ,_abgf :=range _fdbe ._bdgb .DefinedNames (){if _abgf .Name ()==_abgbd {if _babc .HasPrefix (_abgf .Content (),_abde ){_fdbe ._bdgb .RemoveDefinedName (_abgf );break ;};};};};

// X returns the inner wrapped XML type.
func (_ece IconScale )X ()*_efed .CT_IconSet {return _ece ._dba };

// RemoveDefinedName removes an existing defined name.
func (_gddcbc *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _edc .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");};for _ceb ,_ac :=range _gddcbc ._fbc .DefinedNames .DefinedName {if _ac ==dn .X (){copy (_gddcbc ._fbc .DefinedNames .DefinedName [_ceb :],_gddcbc ._fbc .DefinedNames .DefinedName [_ceb +1:]);_gddcbc ._fbc .DefinedNames .DefinedName [len (_gddcbc ._fbc .DefinedNames .DefinedName )-1]=nil ;_gddcbc ._fbc .DefinedNames .DefinedName =_gddcbc ._fbc .DefinedNames .DefinedName [:len (_gddcbc ._fbc .DefinedNames .DefinedName )-1];return nil ;};};return _edc .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};

// SetPriority sets the rule priority
func (_ceebg ConditionalFormattingRule )SetPriority (p int32 ){_ceebg ._defb .PriorityAttr =p };

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_gabec *_efed .CT_ColorScale };

// X returns the inner wrapped XML type.
func (_ddg Comments )X ()*_efed .Comments {return _ddg ._gcdc };

// ClearProtection clears all workbook protections.
func (_ade *Workbook )ClearProtection (){_ade ._fbc .WorkbookProtection =nil };func (_acg SheetView )ensurePane (){if _acg ._cbbc .Pane ==nil {_acg ._cbbc .Pane =_efed .NewCT_Pane ();_acg ._cbbc .Pane .ActivePaneAttr =_efed .ST_PaneBottomLeft ;};};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_dabb Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _fgea ,_dgff Cell ;for _ ,_aaec :=range lhs .Cells (){_bbaaf ,_ :=_cgebb .ParseCellReference (_aaec .Reference ());if _bbaaf .Column ==column {_fgea =_aaec ;break ;};};for _ ,_cfgb :=range rhs .Cells (){_babag ,_ :=_cgebb .ParseCellReference (_cfgb .Reference ());if _babag .Column ==column {_dgff =_cfgb ;break ;};};return _dabb .LessCells (_fgea ,_dgff );};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_gbce *Workbook )Save (w _afdf .Writer )error {if !_dgab .GetLicenseKey ().IsLicensed ()&&!_dad {_beba .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_beba .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return _edc .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_aadf :=_fccde .NewWriter (w );defer _aadf .Close ();_gg :=_fcgc .DocTypeSpreadsheet ;if _bbdg :=_fgc .MarshalXML (_aadf ,_fcgc .BaseRelsFilename ,_gbce .Rels .X ());_bbdg !=nil {return _bbdg ;};if _egdg :=_fgc .MarshalXMLByType (_aadf ,_gg ,_fcgc .ExtendedPropertiesType ,_gbce .AppProperties .X ());_egdg !=nil {return _egdg ;};if _fce :=_fgc .MarshalXMLByType (_aadf ,_gg ,_fcgc .CorePropertiesType ,_gbce .CoreProperties .X ());_fce !=nil {return _fce ;};_bbc :=_fcgc .AbsoluteFilename (_gg ,_fcgc .OfficeDocumentType ,0);if _fgcf :=_fgc .MarshalXML (_aadf ,_bbc ,_gbce ._fbc );_fgcf !=nil {return _fgcf ;};if _befe :=_fgc .MarshalXML (_aadf ,_fgc .RelationsPathFor (_bbc ),_gbce ._fgga .X ());_befe !=nil {return _befe ;};if _fbg :=_fgc .MarshalXMLByType (_aadf ,_gg ,_fcgc .StylesType ,_gbce .StyleSheet .X ());_fbg !=nil {return _fbg ;};for _fcg ,_gabbb :=range _gbce ._aff {if _fea :=_fgc .MarshalXMLByTypeIndex (_aadf ,_gg ,_fcgc .ThemeType ,_fcg +1,_gabbb );_fea !=nil {return _fea ;};};for _cefca ,_faeg :=range _gbce ._cbef {_faeg .Dimension .RefAttr =Sheet {_gbce ,nil ,_faeg }.Extents ();_dfba :=_fcgc .AbsoluteFilename (_gg ,_fcgc .WorksheetType ,_cefca +1);_fgc .MarshalXML (_aadf ,_dfba ,_faeg );_fgc .MarshalXML (_aadf ,_fgc .RelationsPathFor (_dfba ),_gbce ._adec [_cefca ].X ());};if _dbeb :=_fgc .MarshalXMLByType (_aadf ,_gg ,_fcgc .SharedStringsType ,_gbce .SharedStrings .X ());_dbeb !=nil {return _dbeb ;};if _gbce .Thumbnail !=nil {_ebbe :=_fcgc .AbsoluteFilename (_gg ,_fcgc .ThumbnailType ,0);_fgf ,_gae :=_aadf .Create (_ebbe );if _gae !=nil {return _gae ;};if _edgc :=_fccd .Encode (_fgf ,_gbce .Thumbnail ,nil );_edgc !=nil {return _edgc ;};};for _beecb ,_bcacc :=range _gbce ._aeef {_gaec :=_fcgc .AbsoluteFilename (_gg ,_fcgc .ChartType ,_beecb +1);_fgc .MarshalXML (_aadf ,_gaec ,_bcacc );};for _dgca ,_afda :=range _gbce ._cefb {_cbfc :=_fcgc .AbsoluteFilename (_gg ,_fcgc .TableType ,_dgca +1);_fgc .MarshalXML (_aadf ,_cbfc ,_afda );};for _dgfa ,_cbb :=range _gbce ._gde {_dcec :=_fcgc .AbsoluteFilename (_gg ,_fcgc .DrawingType ,_dgfa +1);_fgc .MarshalXML (_aadf ,_dcec ,_cbb );if !_gbce ._fee [_dgfa ].IsEmpty (){_fgc .MarshalXML (_aadf ,_fgc .RelationsPathFor (_dcec ),_gbce ._fee [_dgfa ].X ());};};for _gfb ,_debd :=range _gbce ._bgce {_fgc .MarshalXML (_aadf ,_fcgc .AbsoluteFilename (_gg ,_fcgc .VMLDrawingType ,_gfb +1),_debd );};for _bfg ,_dfd :=range _gbce .Images {if _gbdd :=_gfdb .AddImageToZip (_aadf ,_dfd ,_bfg +1,_fcgc .DocTypeSpreadsheet );_gbdd !=nil {return _gbdd ;};};if _fagc :=_fgc .MarshalXML (_aadf ,_fcgc .ContentTypesFilename ,_gbce .ContentTypes .X ());_fagc !=nil {return _fagc ;};for _aba ,_gff :=range _gbce ._fbea {if _gff ==nil {continue ;};_fgc .MarshalXML (_aadf ,_fcgc .AbsoluteFilename (_gg ,_fcgc .CommentsType ,_aba +1),_gff );};if _deab :=_gbce .WriteExtraFiles (_aadf );_deab !=nil {return _deab ;};return _aadf .Close ();};

// MergedCells returns the merged cell regions within the sheet.
func (_fcgcd *Sheet )MergedCells ()[]MergedCell {if _fcgcd ._ed .MergeCells ==nil {return nil ;};_ecea :=[]MergedCell {};for _ ,_eag :=range _fcgcd ._ed .MergeCells .MergeCell {_ecea =append (_ecea ,MergedCell {_fcgcd ._bdgb ,_fcgcd ,_eag });};return _ecea ;};

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_dgf TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_dgf ._aceb .From }};

// GetString retrieves a string from the shared strings table by index.
func (_dfac SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_beba .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );};if id > len (_dfac ._fcc .Si ){return "",_beba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_dfac ._fcc .Si ));};_ggga :=_dfac ._fcc .Si [id ];if _ggga .T !=nil {return *_ggga .T ,nil ;};return "",nil ;};

// SetBold causes the text to be displayed in bold.
func (_cbde RichTextRun )SetBold (b bool ){_cbde .ensureRpr ();_cbde ._efec .RPr .B =_efed .NewCT_BooleanProperty ();_cbde ._efec .RPr .B .ValAttr =_fcgc .Bool (b );};func (_dgdc Font )SetItalic (b bool ){if b {_dgdc ._gca .I =[]*_efed .CT_BooleanProperty {{}};}else {_dgdc ._gca .I =nil ;};};

// SetStyle sets the cell style for an entire column.
func (_agd Column )SetStyle (cs CellStyle ){_agd ._de .StyleAttr =_fcgc .Uint32 (cs .Index ())};

// SetOperator sets the operator for the rule.
func (_aaea ConditionalFormattingRule )SetOperator (t _efed .ST_ConditionalFormattingOperator ){_aaea ._defb .OperatorAttr =t ;};

// SetType sets the type of the rule.
func (_gbff ConditionalFormattingRule )SetType (t _efed .ST_CfType ){_gbff ._defb .TypeAttr =t };

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_ebbb *Workbook )AddImage (i _gfdb .Image )(_gfdb .ImageRef ,error ){_bfbac :=_gfdb .MakeImageRef (i ,&_ebbb .DocBase ,_ebbb ._fgga );if i .Data ==nil &&i .Path ==""{return _bfbac ,_edc .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");};if i .Format ==""{return _bfbac ,_edc .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _bfbac ,_edc .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");};_ebbb .Images =append (_ebbb .Images ,_bfbac );return _bfbac ,nil ;};

// BottomRight is a no-op.
func (_gfbg AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};func (_a *Sheet )slideCellsLeft (_bbec []*_efed .CT_Cell )[]*_efed .CT_Cell {for _ ,_fgaa :=range _bbec {_dgeg ,_dddge :=_cgebb .ParseCellReference (*_fgaa .RAttr );if _dddge !=nil {return _bbec ;};_gbg :=_dgeg .ColumnIdx -1;_aebf :=_cgebb .IndexToColumn (_gbg )+_beba .Sprintf ("\u0025\u0064",_dgeg .RowIdx );_fgaa .RAttr =&_aebf ;};return _bbec ;};

// Type returns the type of anchor
func (_gfbc AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };type ConditionalFormattingRule struct{_defb *_efed .CT_CfRule };

// Comments returns the list of comments for this sheet
func (_edd Comments )Comments ()[]Comment {_cfcf :=[]Comment {};for _ ,_decd :=range _edd ._gcdc .CommentList .Comment {_cfcf =append (_cfcf ,Comment {_edd ._gcfe ,_decd ,_edd ._gcdc });};return _cfcf ;};

// Sheet is a single sheet within a workbook.
type Sheet struct{_bdgb *Workbook ;_ccfb *_efed .CT_Sheet ;_ed *_efed .Worksheet ;};

// LockSheet controls the locking of the sheet.
func (_dfa SheetProtection )LockSheet (b bool ){if !b {_dfa ._dgdf .SheetAttr =nil ;}else {_dfa ._dgdf .SheetAttr =_fcgc .Bool (true );};};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_fggf *Sheet )RemoveMergedCell (mc MergedCell ){for _dgbe ,_cgda :=range _fggf ._ed .MergeCells .MergeCell {if _cgda ==mc .X (){copy (_fggf ._ed .MergeCells .MergeCell [_dgbe :],_fggf ._ed .MergeCells .MergeCell [_dgbe +1:]);_fggf ._ed .MergeCells .MergeCell [len (_fggf ._ed .MergeCells .MergeCell )-1]=nil ;_fggf ._ed .MergeCells .MergeCell =_fggf ._ed .MergeCells .MergeCell [:len (_fggf ._ed .MergeCells .MergeCell )-1];};};};

// X returns the inner wrapped XML type.
func (_aacd RichText )X ()*_efed .CT_Rst {return _aacd ._egcd };

// Tables returns a slice of all defined tables in the workbook.
func (_ecaa *Workbook )Tables ()[]Table {if _ecaa ._cefb ==nil {return nil ;};_eaff :=[]Table {};for _ ,_eedb :=range _ecaa ._cefb {_eaff =append (_eaff ,Table {_eedb });};return _eaff ;};

// X returns the inner wrapped XML type.
func (_ecg Sheet )X ()*_efed .Worksheet {return _ecg ._ed };

// ClearFont clears any font configuration from the cell style.
func (_eac CellStyle )ClearFont (){_eac ._ddbb .FontIdAttr =nil ;_eac ._ddbb .ApplyFontAttr =nil };

// DefinedNames returns a slice of all defined names in the workbook.
func (_eddd *Workbook )DefinedNames ()[]DefinedName {if _eddd ._fbc .DefinedNames ==nil {return nil ;};_aad :=[]DefinedName {};for _ ,_cbcg :=range _eddd ._fbc .DefinedNames .DefinedName {_aad =append (_aad ,DefinedName {_cbcg });};return _aad ;};

// StyleSheet is a document style sheet.
type StyleSheet struct{_eacfc *Workbook ;_deb *_efed .StyleSheet ;};func (_bfeed Cell )getLocked ()bool {if _bfeed ._ecbe .SAttr ==nil {return false ;};_dcgf :=*_bfeed ._ecbe .SAttr ;_cfef :=_bfeed ._dcbg .StyleSheet .GetCellStyle (_dcgf );return *_cfef ._ddbb .Protection .LockedAttr ;};

// SetUnderline controls if the run is underlined.
func (_ceebgf RichTextRun )SetUnderline (u _efed .ST_UnderlineValues ){_ceebgf .ensureRpr ();_ceebgf ._efec .RPr .U =_efed .NewCT_UnderlineProperty ();_ceebgf ._efec .RPr .U .ValAttr =u ;};func (_geb Row )renumberAs (_fggd uint32 ){_geb ._dcaa .RAttr =_fcgc .Uint32 (_fggd );for _ ,_gabf :=range _geb .Cells (){_beec ,_eeeb :=_cgebb .ParseCellReference (_gabf .Reference ());if _eeeb ==nil {_fdc :=_beba .Sprintf ("\u0025\u0073\u0025\u0064",_beec .Column ,_fggd );_gabf ._ecbe .RAttr =_fcgc .String (_fdc );};};};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_g *Workbook )AddDefinedName (name ,ref string )DefinedName {if _g ._fbc .DefinedNames ==nil {_g ._fbc .DefinedNames =_efed .NewCT_DefinedNames ();};_faa :=_efed .NewCT_DefinedName ();_faa .Content =ref ;_faa .NameAttr =name ;_g ._fbc .DefinedNames .DefinedName =append (_g ._fbc .DefinedNames .DefinedName ,_faa );return DefinedName {_faa };};

// Col returns the column of the cell marker.
func (_bba CellMarker )Col ()int32 {return _bba ._bbd .Col };

// SetHidden marks the defined name as hidden.
func (_ebef DefinedName )SetHidden (b bool ){_ebef ._edda .HiddenAttr =_fcgc .Bool (b )};func (_fbcf Sheet )validateMergedCells ()error {_efce :=map[uint64 ]struct{}{};for _ ,_fc :=range _fbcf .MergedCells (){_bfba ,_decdc ,_bgef :=_cgebb .ParseRangeReference (_fc .Reference ());if _bgef !=nil {return _beba .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_fbcf .Name (),_fc .Reference ());};for _badd :=_bfba .RowIdx ;_badd <=_decdc .RowIdx ;_badd ++{for _cabe :=_bfba .ColumnIdx ;_cabe <=_decdc .ColumnIdx ;_cabe ++{_bgag :=uint64 (_badd )<<32|uint64 (_cabe );if _ ,_aadfe :=_efce [_bgag ];_aadfe {return _beba .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_fbcf .Name ());};_efce [_bgag ]=struct{}{};};};};return nil ;};func (_bbb Border )SetTop (style _efed .ST_BorderStyle ,c _gbda .Color ){if _bbb ._gafc .Top ==nil {_bbb ._gafc .Top =_efed .NewCT_BorderPr ();};_bbb ._gafc .Top .Color =_efed .NewCT_Color ();_bbb ._gafc .Top .Color .RgbAttr =c .AsRGBAString ();_bbb ._gafc .Top .StyleAttr =style ;};

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_efca *Workbook )Close ()error {if _efca .TmpPath !=""&&_babc .HasPrefix (_efca .TmpPath ,_gccb .TempDir ()){return _gccb .RemoveAll (_efca .TmpPath );};return nil ;};

// SetLocked sets cell locked or not.
func (_fgab *evalContext )SetLocked (cellRef string ,locked bool ){_fgab ._eee .Cell (cellRef ).setLocked (locked );};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_baef Comparer )LessCells (lhs ,rhs Cell )bool {if _baef .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_aecb ,_gcbb :=lhs .getRawSortValue ();_daac ,_adfd :=rhs .getRawSortValue ();switch {case _gcbb &&_adfd :_gdagd ,_ :=_ggfd .ParseFloat (_aecb ,64);_afc ,_ :=_ggfd .ParseFloat (_daac ,64);return _gdagd < _afc ;case _gcbb :return true ;case _adfd :return false ;};_aecb =lhs .GetFormattedValue ();_daac =rhs .GetFormattedValue ();return _aecb < _daac ;};type Fill struct{_fagab *_efed .CT_Fill ;_dgfd *_efed .CT_Fills ;};

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_ebee *Sheet )SetFrozen (firstRow ,firstCol bool ){_ebee ._ed .SheetViews =nil ;_d :=_ebee .AddView ();_d .SetState (_efed .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_d .SetYSplit (1);_d .SetXSplit (1);_d .SetTopLeft ("\u0042\u0032");case firstRow :_d .SetYSplit (1);_d .SetTopLeft ("\u0041\u0032");case firstCol :_d .SetXSplit (1);_d .SetTopLeft ("\u0042\u0031");};};

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_fgeaf Cell )SetTime (d _dfga .Time ){_fgeaf .clearValue ();d =_cec (d );_dbgb :=_fgeaf ._dcbg .Epoch ();if d .Before (_dbgb ){_fcgc .Log ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_gbeff :=d .Sub (_dbgb );_bacg :=new (_dfb .Float );_cafg :=new (_dfb .Float );_cafg .SetPrec (128);_cafg .SetUint64 (uint64 (_gbeff ));_acbb :=new (_dfb .Float );_acbb .SetUint64 (24*60*60*1e9);_bacg .Quo (_cafg ,_acbb );_fgeaf ._ecbe .V =_fcgc .String (_bacg .Text ('g',20));};

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both gooxml and Excel will always set it.
func (_da Cell )Reference ()string {if _da ._ecbe .RAttr !=nil {return *_da ._ecbe .RAttr ;};return "";};

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_dgg DataValidationList )SetRange (cellRange string ){_dgg ._fed .Formula1 =_fcgc .String (cellRange );_dgg ._fed .Formula2 =_fcgc .String ("\u0030");};func _bcced (){_gabc ,_cegad :=_bae .ReadBuildInfo ();if !_cegad {if !_dad {_beba .Printf ("\u0042\u0075il\u0064\u0020\u0069n\u0066\u006f\u0072\u006dati\u006fn \u006d\u0069\u0073\u0073\u0069\u006e\u0067 -\u0020\u0045\u0078\u0069\u0074\u0069\u006eg\u000a");_gccb .Exit (1);}else {return ;};};_faee :=0;for _ ,_cefc :=range _gabc .Deps {if _cefc .Path =="g\u0069\u0074\u0068\u0075\u0062\u002ec\u006f\u006d\u002f\u0075\u006e\u0069\u0064\u006f\u0063/\u0075\u006e\u0069o\u0066f\u0069\u0063\u0065"&&_cefc .Replace ==nil {_faee =1;};};_bfeb :=_dad ;if _babc .HasPrefix (_gabc .Path ,"\u0067i\u0074h\u0075\u0062\u002e\u0063\u006fm\u002f\u0075n\u0069\u0064\u006f\u0063\u002f"){_bfeb =true ;};if _faee !=1&&!_bfeb {_beba .Printf ("\u0050\u0061\u0063\u006b\u0061\u0067\u0065\u0020\u0069\u006e\u0066\u006f\u0072\u006d\u0061\u0074\u0069\u006f\u006e\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u002d\u0020E\u0078\u0069t\u0069\u006e\u0067\u000a");_gccb .Exit (1);};};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_c StyleSheet )AddNumberFormat ()NumberFormat {if _c ._deb .NumFmts ==nil {_c ._deb .NumFmts =_efed .NewCT_NumFmts ();};_cadc :=_efed .NewCT_NumFmt ();_cadc .NumFmtIdAttr =uint32 (200+len (_c ._deb .NumFmts .NumFmt ));_c ._deb .NumFmts .NumFmt =append (_c ._deb .NumFmts .NumFmt ,_cadc );_c ._deb .NumFmts .CountAttr =_fcgc .Uint32 (uint32 (len (_c ._deb .NumFmts .NumFmt )));return NumberFormat {_c ._eacfc ,_cadc };};

// X returns the inner XML entity for a stylesheet.
func (_ecgd StyleSheet )X ()*_efed .StyleSheet {return _ecgd ._deb };

// Fonts returns the list of fonts defined in the stylesheet.
func (_dbc StyleSheet )Fonts ()[]Font {_ce :=[]Font {};for _ ,_bge :=range _dbc ._deb .Fonts .Font {_ce =append (_ce ,Font {_bge ,_dbc ._deb });};return _ce ;};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_gdgf Comment )SetCellReference (cellRef string ){_gdgf ._gcd .RefAttr =cellRef };

// SetHeight sets the row height in points.
func (_bacf Row )SetHeight (d _aag .Distance ){_bacf ._dcaa .HtAttr =_fcgc .Float64 (float64 (d ));_bacf ._dcaa .CustomHeightAttr =_fcgc .Bool (true );};

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_cede AbsoluteAnchor )SetColOffset (m _aag .Distance ){_cede ._adf .Pos .XAttr .ST_CoordinateUnqualified =_fcgc .Int64 (int64 (m /_aag .EMU ));};

// SetFill applies a fill to a cell style.  The fill is referenced by its index
// so modifying the fill afterward will affect all styles that reference it.
func (_agee CellStyle )SetFill (f Fill ){_agee ._ddbb .FillIdAttr =_fcgc .Uint32 (f .Index ());_agee ._ddbb .ApplyFillAttr =_fcgc .Bool (true );};

// Index returns the index of the differential style.
func (_dccdg DifferentialStyle )Index ()uint32 {for _aabf ,_ggcb :=range _dccdg ._deed .Dxf {if _dccdg ._efd ==_ggcb {return uint32 (_aabf );};};return 0;};func (_dacfc Font )SetSize (size float64 ){_dacfc ._gca .Sz =[]*_efed .CT_FontSize {{ValAttr :size }}};func (_cge Font )SetName (name string ){_cge ._gca .Name =[]*_efed .CT_FontName {{ValAttr :name }}};

// SetHeightCells is a no-op.
func (_ccgc OneCellAnchor )SetHeightCells (int32 ){};

// SetError sets the cell type to error and the value to the given error message.
func (_bbdge Cell )SetError (msg string ){_bbdge .clearValue ();_bbdge ._ecbe .V =_fcgc .String (msg );_bbdge ._ecbe .TAttr =_efed .ST_CellTypeE ;};

// X returns the inner wrapped XML type.
func (_eff Table )X ()*_efed .Table {return _eff ._eg };

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_afd DataValidationCompare )SetValue (v string ){_afd ._cabeb .Formula1 =&v };

// LockStructure controls the locking of the workbook structure.
func (_gdaf WorkbookProtection )LockStructure (b bool ){if !b {_gdaf ._cagc .LockStructureAttr =nil ;}else {_gdaf ._cagc .LockStructureAttr =_fcgc .Bool (true );};};const _bdda ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// Comments is the container for comments for a single sheet.
type Comments struct{_gcfe *Workbook ;_gcdc *_efed .Comments ;};func (_ddab Sheet )validateRowCellNumbers ()error {_ba :=map[uint32 ]struct{}{};for _ ,_cbacc :=range _ddab ._ed .SheetData .Row {if _cbacc .RAttr !=nil {if _ ,_baddg :=_ba [*_cbacc .RAttr ];_baddg {return _beba .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_ddab .Name (),*_cbacc .RAttr );};_ba [*_cbacc .RAttr ]=struct{}{};};_ccfa :=map[string ]struct{}{};for _ ,_dfec :=range _cbacc .C {if _dfec .RAttr ==nil {continue ;};if _ ,_ffcb :=_ccfa [*_dfec .RAttr ];_ffcb {return _beba .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_ddab .Name (),*_dfec .RAttr );};_ccfa [*_dfec .RAttr ]=struct{}{};};};return nil ;};func (_aabb StyleSheet )GetCellStyle (id uint32 )CellStyle {for _gafd ,_gdag :=range _aabb ._deb .CellXfs .Xf {if uint32 (_gafd )==id {return CellStyle {_aabb ._eacfc ,_gdag ,_aabb ._deb .CellXfs };};};return CellStyle {};};

// Content returns the content of the defined range (the range in most cases)/
func (_afff DefinedName )Content ()string {return _afff ._edda .Content };

// Sheets returns the sheets from the workbook.
func (_aecd *Workbook )Sheets ()[]Sheet {_fbb :=[]Sheet {};for _cda ,_dgad :=range _aecd ._cbef {_eecd :=_aecd ._fbc .Sheets .Sheet [_cda ];_gddb :=Sheet {_aecd ,_eecd ,_dgad };_fbb =append (_fbb ,_gddb );};return _fbb ;};

// SetMaxLength sets the maximum bar length in percent.
func (_efdg DataBarScale )SetMaxLength (l uint32 ){_efdg ._feba .MaxLengthAttr =_fcgc .Uint32 (l )};

// GetFormula returns the formula for a cell.
func (_beef Cell )GetFormula ()string {if _beef ._ecbe .F !=nil {return _beef ._ecbe .F .Content ;};return "";};

// SetWrapped configures the cell to wrap text.
func (_decda CellStyle )SetWrapped (b bool ){if _decda ._ddbb .Alignment ==nil {_decda ._ddbb .Alignment =_efed .NewCT_CellAlignment ();};if !b {_decda ._ddbb .Alignment .WrapTextAttr =nil ;}else {_decda ._ddbb .Alignment .WrapTextAttr =_fcgc .Bool (true );_decda ._ddbb .ApplyAlignmentAttr =_fcgc .Bool (true );};};

// AddCell adds a cell to a spreadsheet.
func (_dce Row )AddCell ()Cell {_gcda :=uint32 (len (_dce ._dcaa .C ));var _abfb *string ;if _gcda > 0{_gfgf :=_fcgc .Stringf ("\u0025\u0073\u0025\u0064",_cgebb .IndexToColumn (_gcda -1),_dce .RowNumber ());if _dce ._dcaa .C [_gcda -1].RAttr !=nil &&*_dce ._dcaa .C [_gcda -1].RAttr ==*_gfgf {_abfb =_fcgc .Stringf ("\u0025\u0073\u0025\u0064",_cgebb .IndexToColumn (_gcda ),_dce .RowNumber ());};};_ca :=_efed .NewCT_Cell ();_dce ._dcaa .C =append (_dce ._dcaa .C ,_ca );if _abfb ==nil {_fac :=uint32 (0);for _ ,_beac :=range _dce ._dcaa .C {if _beac .RAttr !=nil {_fcgf ,_ :=_cgebb .ParseCellReference (*_beac .RAttr );if _fcgf .ColumnIdx >=_fac {_fac =_fcgf .ColumnIdx +1;};};};_abfb =_fcgc .Stringf ("\u0025\u0073\u0025\u0064",_cgebb .IndexToColumn (_fac ),_dce .RowNumber ());};_ca .RAttr =_abfb ;return Cell {_dce ._gcbf ,_dce ._bcdf ,_dce ._dcaa ,_ca };};

// Reference returns the table reference (the cells within the table)
func (_eecf Table )Reference ()string {return _eecf ._eg .RefAttr };

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_cce Drawing )AddImage (img _gfdb .ImageRef ,at AnchorType )Anchor {_gedb :=0;for _cdbef ,_fccf :=range _cce ._aacf .Images {if _fccf ==img {_gedb =_cdbef +1;break ;};};var _fgaee string ;for _ded ,_gfdg :=range _cce ._aacf ._gde {if _gfdg ==_cce ._gccd {_gaf :=_beba .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_gedb ,img .Format ());_bgac :=_cce ._aacf ._fee [_ded ].AddRelationship (_gaf ,_fcgc .ImageType );_fgaee =_bgac .ID ();break ;};};var _aedaa Anchor ;var _gdad *_gcge .CT_Picture ;switch at {case AnchorTypeAbsolute :_fafbd :=_gbad ();_cce ._gccd .EG_Anchor =append (_cce ._gccd .EG_Anchor ,&_gcge .EG_Anchor {AbsoluteAnchor :_fafbd });_fafbd .Choice =&_gcge .EG_ObjectChoicesChoice {};_fafbd .Choice .Pic =_gcge .NewCT_Picture ();_gdad =_fafbd .Choice .Pic ;_aedaa =AbsoluteAnchor {_fafbd };case AnchorTypeOneCell :_bcga :=_gade ();_cce ._gccd .EG_Anchor =append (_cce ._gccd .EG_Anchor ,&_gcge .EG_Anchor {OneCellAnchor :_bcga });_bcga .Choice =&_gcge .EG_ObjectChoicesChoice {};_bcga .Choice .Pic =_gcge .NewCT_Picture ();_gdad =_bcga .Choice .Pic ;_aedaa =OneCellAnchor {_bcga };case AnchorTypeTwoCell :_fcaf :=_cbc ();_cce ._gccd .EG_Anchor =append (_cce ._gccd .EG_Anchor ,&_gcge .EG_Anchor {TwoCellAnchor :_fcaf });_fcaf .Choice =&_gcge .EG_ObjectChoicesChoice {};_fcaf .Choice .Pic =_gcge .NewCT_Picture ();_gdad =_fcaf .Choice .Pic ;_aedaa =TwoCellAnchor {_fcaf };};_gdad .NvPicPr .CNvPr .IdAttr =uint32 (len (_cce ._gccd .EG_Anchor ));_gdad .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_gdad .BlipFill .Blip =_eada .NewCT_Blip ();_gdad .BlipFill .Blip .EmbedAttr =_fcgc .String (_fgaee );_gdad .BlipFill .Stretch =_eada .NewCT_StretchInfoProperties ();_gdad .SpPr =_eada .NewCT_ShapeProperties ();_gdad .SpPr .Xfrm =_eada .NewCT_Transform2D ();_gdad .SpPr .Xfrm .Off =_eada .NewCT_Point2D ();_gdad .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_fcgc .Int64 (0);_gdad .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_fcgc .Int64 (0);_gdad .SpPr .Xfrm .Ext =_eada .NewCT_PositiveSize2D ();_gdad .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_aag .Pixel72 )/_aag .EMU );_gdad .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_aag .Pixel72 )/_aag .EMU );_gdad .SpPr .PrstGeom =_eada .NewCT_PresetGeometry2D ();_gdad .SpPr .PrstGeom .PrstAttr =_eada .ST_ShapeTypeRect ;_gdad .SpPr .Ln =_eada .NewCT_LineProperties ();_gdad .SpPr .Ln .NoFill =_eada .NewCT_NoFillProperties ();return _aedaa ;};

// SetColOffset sets a column offset in absolute distance.
func (_ffac CellMarker )SetColOffset (m _aag .Distance ){_ffac ._bbd .ColOff .ST_CoordinateUnqualified =_fcgc .Int64 (int64 (m /_aag .EMU ));};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As gooxml formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_abd *Sheet )RecalculateFormulas (){_cgeb :=_acdfa .NewEvaluator ();_gace :=_abd .FormulaContext ();for _ ,_gafe :=range _abd .Rows (){for _ ,_gage :=range _gafe .Cells (){if _gage .X ().F !=nil {_fcbd :=_gage .X ().F .Content ;if _gage .X ().F .TAttr ==_efed .ST_CellFormulaTypeShared &&len (_fcbd )==0{continue ;};_baba :=_cgeb .Eval (_gace ,_fcbd ).AsString ();if _baba .Type ==_acdfa .ResultTypeError {_fcgc .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_fcbd ,_baba .ErrorMessage );_gage .X ().V =nil ;}else {if _baba .Type ==_acdfa .ResultTypeNumber {_gage .X ().TAttr =_efed .ST_CellTypeN ;}else {_gage .X ().TAttr =_efed .ST_CellTypeInlineStr ;};_gage .X ().V =_fcgc .String (_baba .Value ());if _gage .X ().F .TAttr ==_efed .ST_CellFormulaTypeArray {if _baba .Type ==_acdfa .ResultTypeArray {_abd .setArray (_gage .Reference (),_baba );}else if _baba .Type ==_acdfa .ResultTypeList {_abd .setList (_gage .Reference (),_baba );};}else if _gage .X ().F .TAttr ==_efed .ST_CellFormulaTypeShared &&_gage .X ().F .RefAttr !=nil {_cage ,_eda ,_bg :=_cgebb .ParseRangeReference (*_gage .X ().F .RefAttr );if _bg !=nil {_bfa .Printf ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_bg );continue ;};_abd .setShared (_gage .Reference (),_cage ,_eda ,_fcbd );};};};};};};

// SetText sets the text to be displayed.
func (_ddb RichTextRun )SetText (s string ){_ddb ._efec .T =s };

// X returns the inner wrapped XML type.
func (_fbf DataValidation )X ()*_efed .CT_DataValidation {return _fbf ._bdbe };func (_cbac Fills )X ()*_efed .CT_Fills {return _cbac ._bcb };

// SetColor sets teh color of the databar.
func (_eecg DataBarScale )SetColor (c _gbda .Color ){_eecg ._feba .Color =_efed .NewCT_Color ();_eecg ._feba .Color .RgbAttr =c .AsRGBAString ();};

// SetName sets the sheet name.
func (_bfbea *Sheet )SetName (name string ){_bfbea ._ccfb .NameAttr =name };func NewPatternFill (fills *_efed .CT_Fills )PatternFill {_efee :=_efed .NewCT_Fill ();_efee .PatternFill =_efed .NewCT_PatternFill ();return PatternFill {_efee .PatternFill ,_efee };};func _gbc (_dab bool )int {if _dab {return 1;};return 0;};

// AnchorType is the type of anchor.
type AnchorType byte ;

// AddRun adds a new run of text to the cell.
func (_ffdf RichText )AddRun ()RichTextRun {_eacc :=_efed .NewCT_RElt ();_ffdf ._egcd .R =append (_ffdf ._egcd .R ,_eacc );return RichTextRun {_eacc };};func (_gccg *evalContext )NamedRange (ref string )_acdfa .Reference {for _ ,_gdd :=range _gccg ._eee ._bdgb .DefinedNames (){if _gdd .Name ()==ref {return _acdfa .MakeRangeReference (_gdd .Content ());};};for _ ,_cegd :=range _gccg ._eee ._bdgb .Tables (){if _cegd .Name ()==ref {return _acdfa .MakeRangeReference (_beba .Sprintf ("\u0025\u0073\u0021%\u0073",_gccg ._eee .Name (),_cegd .Reference ()));};};return _acdfa .ReferenceInvalid ;};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_dbbc ,_ddbf :=_gccb .Open (filename );if _ddbf !=nil {return nil ,_beba .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_ddbf );};defer _dbbc .Close ();_badcg ,_ddbf :=_gccb .Stat (filename );if _ddbf !=nil {return nil ,_beba .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_ddbf );};_ebe ,_ddbf :=Read (_dbbc ,_badcg .Size ());if _ddbf !=nil {return nil ,_ddbf ;};_fceef ,_ :=_bcfb .Abs (_bcfb .Dir (filename ));_ebe ._gdgg =_bcfb .Join (_fceef ,filename );return _ebe ,nil ;};func _gade ()*_gcge .CT_OneCellAnchor {_cbag :=_gcge .NewCT_OneCellAnchor ();return _cbag };

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_edgd TwoCellAnchor )SetHeightCells (h int32 ){_edgd .SetHeight (0);_gfa :=_edgd .TopLeft ();_fcafb :=_edgd .BottomRight ();_fcafb .SetRow (_gfa .Row ()+h );};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_cgce *Sheet )ClearCachedFormulaResults (){for _ ,_ebeg :=range _cgce .Rows (){for _ ,_decdb :=range _ebeg .Cells (){if _decdb .X ().F !=nil {_decdb .X ().V =nil ;};};};};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_bgg *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_aaeg :=range _bgg .Sheets (){if _aaeg .Name ()==name {return _aaeg ,nil ;};};return Sheet {},ErrorNotFound ;};

// Priority returns the rule priority
func (_fbee ConditionalFormattingRule )Priority ()int32 {return _fbee ._defb .PriorityAttr };

// Comments returns the comments for a sheet.
func (_ebdg *Sheet )Comments ()Comments {for _geee ,_fbe :=range _ebdg ._bdgb ._cbef {if _fbe ==_ebdg ._ed {if _ebdg ._bdgb ._fbea [_geee ]==nil {_ebdg ._bdgb ._fbea [_geee ]=_efed .NewComments ();_ebdg ._bdgb ._adec [_geee ].AddAutoRelationship (_fcgc .DocTypeSpreadsheet ,_fcgc .WorksheetType ,_geee +1,_fcgc .CommentsType );_ebdg ._bdgb .ContentTypes .AddOverride (_fcgc .AbsoluteFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .CommentsType ,_geee +1),_fcgc .CommentsContentType );};if len (_ebdg ._bdgb ._bgce )==0{_ebdg ._bdgb ._bgce =append (_ebdg ._bdgb ._bgce ,_cdbe .NewCommentDrawing ());_egb :=_ebdg ._bdgb ._adec [_geee ].AddAutoRelationship (_fcgc .DocTypeSpreadsheet ,_fcgc .WorksheetType ,1,_fcgc .VMLDrawingType );if _ebdg ._ed .LegacyDrawing ==nil {_ebdg ._ed .LegacyDrawing =_efed .NewCT_LegacyDrawing ();};_ebdg ._ed .LegacyDrawing .IdAttr =_egb .ID ();};return Comments {_ebdg ._bdgb ,_ebdg ._bdgb ._fbea [_geee ]};};};_fcgc .Log ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");return Comments {};};func (_ffeb RichTextRun )ensureRpr (){if _ffeb ._efec .RPr ==nil {_ffeb ._efec .RPr =_efed .NewCT_RPrElt ();};};

// AddGradientStop adds a color gradient stop.
func (_cdae ColorScale )AddGradientStop (color _gbda .Color ){_bd :=_efed .NewCT_Color ();_bd .RgbAttr =color .AsRGBAString ();_cdae ._gabec .Color =append (_cdae ._gabec .Color ,_bd );};

// Clear clears the cell's value and type.
func (_acab Cell )Clear (){_acab .clearValue ();_acab ._ecbe .TAttr =_efed .ST_CellTypeUnset };

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_gddd PatternFill )SetFgColor (c _gbda .Color ){_gddd ._bgcg .FgColor =_efed .NewCT_Color ();_gddd ._bgcg .FgColor .RgbAttr =c .AsRGBAString ();};

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_cgdg Row )AddNamedCell (col string )Cell {_egdf :=_efed .NewCT_Cell ();_egdf .RAttr =_fcgc .Stringf ("\u0025\u0073\u0025\u0064",col ,_cgdg .RowNumber ());_faede :=-1;_bfab :=_cgebb .ColumnToIndex (col );for _dbdg ,_egfg :=range _cgdg ._dcaa .C {_adegd ,_edaf :=_cgebb .ParseCellReference (*_egfg .RAttr );if _edaf !=nil {return Cell {};};if _bfab < _adegd .ColumnIdx {_faede =_dbdg ;break ;};};if _faede ==-1{_cgdg ._dcaa .C =append (_cgdg ._dcaa .C ,_egdf );}else {_cgdg ._dcaa .C =append (_cgdg ._dcaa .C [:_faede ],append ([]*_efed .CT_Cell {_egdf },_cgdg ._dcaa .C [_faede :]...)...);};return Cell {_cgdg ._gcbf ,_cgdg ._bcdf ,_cgdg ._dcaa ,_egdf };};

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_aabfa *Sheet )AddRow ()Row {_gbcb :=uint32 (0);_bbcd :=uint32 (len (_aabfa ._ed .SheetData .Row ));if _bbcd > 0&&_aabfa ._ed .SheetData .Row [_bbcd -1].RAttr !=nil &&*_aabfa ._ed .SheetData .Row [_bbcd -1].RAttr ==_bbcd {return _aabfa .addNumberedRowFast (_bbcd +1);};for _ ,_edfca :=range _aabfa ._ed .SheetData .Row {if _edfca .RAttr !=nil &&*_edfca .RAttr > _gbcb {_gbcb =*_edfca .RAttr ;};};return _aabfa .AddNumberedRow (_gbcb +1);};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_acaf StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_acc :=range _acaf .CellStyles (){if _acc .HasNumberFormat ()&&_acc .NumberFormat ()==uint32 (f ){return _acc ;};};_eeb :=_acaf .AddCellStyle ();_eeb .SetNumberFormatStandard (f );return _eeb ;};func (_bgbg PatternFill )ClearFgColor (){_bgbg ._bgcg .FgColor =nil };

// StandardFormat is a standard ECMA 376 number format.
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;func _cbc ()*_gcge .CT_TwoCellAnchor {_fedg :=_gcge .NewCT_TwoCellAnchor ();_fedg .EditAsAttr =_gcge .ST_EditAsOneCell ;_fedg .From .Col =5;_fedg .From .Row =0;_fedg .From .ColOff .ST_CoordinateUnqualified =_fcgc .Int64 (0);_fedg .From .RowOff .ST_CoordinateUnqualified =_fcgc .Int64 (0);_fedg .To .Col =10;_fedg .To .Row =20;_fedg .To .ColOff .ST_CoordinateUnqualified =_fcgc .Int64 (0);_fedg .To .RowOff .ST_CoordinateUnqualified =_fcgc .Int64 (0);return _fedg ;};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_fcc :_efed .NewSst (),_gfac :make (map[string ]int )};};func (_baa *Sheet )addNumberedRowFast (_dafd uint32 )Row {_aea :=_efed .NewCT_Row ();_aea .RAttr =_fcgc .Uint32 (_dafd );_baa ._ed .SheetData .Row =append (_baa ._ed .SheetData .Row ,_aea );return Row {_baa ._bdgb ,_baa ,_aea };};func (_agag Sheet )validateSheetNames ()error {if len (_agag .Name ())> 31{return _beba .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_agag .Name (),len (_agag .Name ()));};return nil ;};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_gagf *Sheet )SetDrawing (d Drawing ){var _eb _gfdb .Relationships ;for _dbag ,_eaaa :=range _gagf ._bdgb ._cbef {if _eaaa ==_gagf ._ed {_eb =_gagf ._bdgb ._adec [_dbag ];break ;};};var _aaa string ;for _bdea ,_gfdac :=range d ._aacf ._gde {if _gfdac ==d ._gccd {_fggbe :=_eb .AddAutoRelationship (_fcgc .DocTypeSpreadsheet ,_fcgc .WorksheetType ,_bdea +1,_fcgc .DrawingType );_aaa =_fggbe .ID ();break ;};};_gagf ._ed .Drawing =_efed .NewCT_Drawing ();_gagf ._ed .Drawing .IdAttr =_aaa ;};func (_gcdg *Workbook )ensureSharedStringsRelationships (){_fge :=false ;for _ ,_febae :=range _gcdg .ContentTypes .X ().Override {if _febae .ContentTypeAttr ==_fcgc .SharedStringsContentType {_fge =true ;break ;};};if !_fge {_gcdg .ContentTypes .AddOverride (_gfe ,_fcgc .SharedStringsContentType );};_beb :=false ;for _ ,_cae :=range _gcdg ._fgga .Relationships (){if _cae .X ().TargetAttr ==_bdad {_beb =true ;break ;};};if !_beb {_gcdg ._fgga .AddRelationship (_bdad ,_fcgc .SharedStringsType );};};

// AddRule adds and returns a new rule that can be configured.
func (_fgcc ConditionalFormatting )AddRule ()ConditionalFormattingRule {_efcb :=_efed .NewCT_CfRule ();_fgcc ._dcea .CfRule =append (_fgcc ._dcea .CfRule ,_efcb );_dfbab :=ConditionalFormattingRule {_efcb };_dfbab .InitializeDefaults ();_dfbab .SetPriority (int32 (len (_fgcc ._dcea .CfRule )+1));return _dfbab ;};

// IsNumber returns true if the cell is a number type cell.
func (_gbab Cell )IsNumber ()bool {switch _gbab ._ecbe .TAttr {case _efed .ST_CellTypeN :return true ;case _efed .ST_CellTypeS ,_efed .ST_CellTypeB :return false ;};return _gbab ._ecbe .V !=nil &&_eagd .IsNumber (*_gbab ._ecbe .V );};

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_ccd *_gcge .CT_OneCellAnchor };func (_cbfd Fills )AddFill ()Fill {_ggaf :=_efed .NewCT_Fill ();_cbfd ._bcb .Fill =append (_cbfd ._bcb .Fill ,_ggaf );_cbfd ._bcb .CountAttr =_fcgc .Uint32 (uint32 (len (_cbfd ._bcb .Fill )));return Fill {_ggaf ,_cbfd ._bcb };};

// RowOffset returns the offset from the row cell.
func (_eeab CellMarker )RowOffset ()_aag .Distance {if _eeab ._bbd .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _aag .Distance (float64 (*_eeab ._bbd .RowOff .ST_CoordinateUnqualified )*_aag .EMU );};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_deda *Sheet )AddHyperlink (url string )_gfdb .Hyperlink {for _daff ,_abb :=range _deda ._bdgb ._cbef {if _abb ==_deda ._ed {return _deda ._bdgb ._adec [_daff ].AddHyperlink (url );};};return _gfdb .Hyperlink {};};func (_bea *Sheet )removeColumnFromMergedCells (_fefd uint32 )error {if _bea ._ed .MergeCells ==nil ||_bea ._ed .MergeCells .MergeCell ==nil {return nil ;};_fdgc :=[]*_efed .CT_MergeCell {};for _ ,_ceecc :=range _bea .MergedCells (){_fgg :=_bad (_ceecc .Reference (),_fefd ,true );if _fgg !=""{_ceecc .SetReference (_fgg );_fdgc =append (_fdgc ,_ceecc .X ());};};_bea ._ed .MergeCells .MergeCell =_fdgc ;return nil ;};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_dgea Cell )SetFormulaArray (s string ){_dgea .clearValue ();_dgea ._ecbe .TAttr =_efed .ST_CellTypeStr ;_dgea ._ecbe .F =_efed .NewCT_CellFormula ();_dgea ._ecbe .F .TAttr =_efed .ST_CellFormulaTypeArray ;_dgea ._ecbe .F .Content =s ;};

// SetReference sets the regin of cells that the merged cell applies to.
func (_ef MergedCell )SetReference (ref string ){_ef ._ebc .RefAttr =ref };

// X returns the inner wrapped XML type.
func (_eaee ConditionalFormattingRule )X ()*_efed .CT_CfRule {return _eaee ._defb };

// SetHeight sets the height of the anchored object.
func (_dbaa OneCellAnchor )SetHeight (h _aag .Distance ){_dbaa ._ccd .Ext .CyAttr =int64 (h /_aag .EMU )};

// SetFormat sets the number format code.
func (_bcfd NumberFormat )SetFormat (f string ){_bcfd ._ceea .FormatCodeAttr =f };func _gbad ()*_gcge .CT_AbsoluteAnchor {_gee :=_gcge .NewCT_AbsoluteAnchor ();return _gee };

// HasFormula returns true if the cell contains formula.
func (_fegg *evalContext )HasFormula (cellRef string )bool {return _fegg ._eee .Cell (cellRef ).HasFormula ();};func (_fccfg Cell )getRawSortValue ()(string ,bool ){if _fccfg .HasFormula (){_cagdf :=_fccfg .GetCachedFormulaResult ();return _cagdf ,_eagd .IsNumber (_cagdf );};_cgeg ,_ :=_fccfg .GetRawValue ();return _cgeg ,_eagd .IsNumber (_cgeg );};

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_dfe ConditionalFormattingRule )SetIcons ()IconScale {_dfe .clear ();_dfe .SetType (_efed .ST_CfTypeIconSet );_dfe ._defb .IconSet =_efed .NewCT_IconSet ();_bcaa :=IconScale {_dfe ._defb .IconSet };_bcaa .SetIcons (_efed .ST_IconSetType3TrafficLights1 );return _bcaa ;};

// SetColOffset sets the column offset of the two cell anchor.
func (_dcdb TwoCellAnchor )SetColOffset (m _aag .Distance ){_bgee :=m -_dcdb .TopLeft ().ColOffset ();_dcdb .TopLeft ().SetColOffset (m );_dcdb .BottomRight ().SetColOffset (_dcdb .BottomRight ().ColOffset ()+_bgee );};

// X returns the inner wrapped XML type.
func (_fcfc SharedStrings )X ()*_efed .Sst {return _fcfc ._fcc };

// New constructs a new workbook.
func New ()*Workbook {_gbee :=&Workbook {};_gbee ._fbc =_efed .NewWorkbook ();_gcg .SetFinalizer (_gbee ,_gda );_gbee .AppProperties =_gfdb .NewAppProperties ();_gbee .CoreProperties =_gfdb .NewCoreProperties ();_gbee .StyleSheet =NewStyleSheet (_gbee );_gbee .Rels =_gfdb .NewRelationships ();_gbee ._fgga =_gfdb .NewRelationships ();_gbee .Rels .AddRelationship (_fcgc .RelativeFilename (_fcgc .DocTypeSpreadsheet ,"",_fcgc .ExtendedPropertiesType ,0),_fcgc .ExtendedPropertiesType );_gbee .Rels .AddRelationship (_fcgc .RelativeFilename (_fcgc .DocTypeSpreadsheet ,"",_fcgc .CorePropertiesType ,0),_fcgc .CorePropertiesType );_gbee .Rels .AddRelationship (_fcgc .RelativeFilename (_fcgc .DocTypeSpreadsheet ,"",_fcgc .OfficeDocumentType ,0),_fcgc .OfficeDocumentType );_gbee ._fgga .AddRelationship (_fcgc .RelativeFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .OfficeDocumentType ,_fcgc .StylesType ,0),_fcgc .StylesType );_gbee .ContentTypes =_gfdb .NewContentTypes ();_gbee .ContentTypes .AddDefault ("\u0076\u006d\u006c",_fcgc .VMLDrawingContentType );_gbee .ContentTypes .AddOverride (_fcgc .AbsoluteFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");_gbee .ContentTypes .AddOverride (_fcgc .AbsoluteFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .StylesType ,0),_fcgc .SMLStyleSheetContentType );_gbee .SharedStrings =NewSharedStrings ();_gbee .ContentTypes .AddOverride (_fcgc .AbsoluteFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .SharedStringsType ,0),_fcgc .SharedStringsContentType );_gbee ._fgga .AddRelationship (_fcgc .RelativeFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .OfficeDocumentType ,_fcgc .SharedStringsType ,0),_fcgc .SharedStringsType );return _gbee ;};

// SetPattern sets the pattern of the fill.
func (_geg PatternFill )SetPattern (p _efed .ST_PatternType ){_geg ._bgcg .PatternTypeAttr =p };

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_bcac *Sheet )Row (rowNum uint32 )Row {for _ ,_gacf :=range _bcac ._ed .SheetData .Row {if _gacf .RAttr !=nil &&*_gacf .RAttr ==rowNum {return Row {_bcac ._bdgb ,_bcac ,_gacf };};};return _bcac .AddNumberedRow (rowNum );};func (_bc PatternFill )ClearBgColor (){_bc ._bgcg .BgColor =nil };

// SetPassword sets the password hash to a hash of the input password.
func (_agae WorkbookProtection )SetPassword (pw string ){_agae .SetPasswordHash (PasswordHash (pw ))};

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_adae *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_babc .Replace (rangeRef ,"\u0024","",-1);_adae ._ed .AutoFilter =_efed .NewCT_AutoFilter ();_adae ._ed .AutoFilter .RefAttr =_fcgc .String (rangeRef );_ebaf :="\u0027"+_adae .Name ()+"\u0027\u0021";var _dgaf DefinedName ;for _ ,_cegf :=range _adae ._bdgb .DefinedNames (){if _cegf .Name ()==_abgbd {if _babc .HasPrefix (_cegf .Content (),_ebaf ){_dgaf =_cegf ;_dgaf .SetContent (_adae .RangeReference (rangeRef ));break ;};};};if _dgaf .X ()==nil {_dgaf =_adae ._bdgb .AddDefinedName (_abgbd ,_adae .RangeReference (rangeRef ));};for _daea ,_bgae :=range _adae ._bdgb ._cbef {if _bgae ==_adae ._ed {_dgaf .SetLocalSheetID (uint32 (_daea ));};};};const _dade ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";

// X returns the inner wrapped XML type.
func (_gbb Column )X ()*_efed .CT_Col {return _gbb ._de };func (_edabb PatternFill )SetBgColor (c _gbda .Color ){_edabb ._bgcg .BgColor =_efed .NewCT_Color ();_edabb ._bgcg .BgColor .RgbAttr =c .AsRGBAString ();};

// Row returns the row of the cell marker.
func (_ceeb CellMarker )Row ()int32 {return _ceeb ._bbd .Row };

// AddFont adds a new empty font to the stylesheet.
func (_fdbgf StyleSheet )AddFont ()Font {_ecfcc :=_efed .NewCT_Font ();_fdbgf ._deb .Fonts .Font =append (_fdbgf ._deb .Fonts .Font ,_ecfcc );_fdbgf ._deb .Fonts .CountAttr =_fcgc .Uint32 (uint32 (len (_fdbgf ._deb .Fonts .Font )));return Font {_ecfcc ,_fdbgf ._deb };};type evalContext struct{_eee *Sheet ;_bf ,_cde uint32 ;_dbda map[string ]struct{};};

// SetRowOffset sets a column offset in absolute distance.
func (_bec CellMarker )SetRowOffset (m _aag .Distance ){_bec ._bbd .RowOff .ST_CoordinateUnqualified =_fcgc .Int64 (int64 (m /_aag .EMU ));};

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_fabg *Workbook ;_ceea *_efed .CT_NumFmt ;};

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_ccga AbsoluteAnchor )SetRowOffset (m _aag .Distance ){_ccga ._adf .Pos .YAttr .ST_CoordinateUnqualified =_fcgc .Int64 (int64 (m /_aag .EMU ));};

// SetTopLeft sets the top left visible cell after the split.
func (_dea SheetView )SetTopLeft (cellRef string ){_dea .ensurePane ();_dea ._cbbc .Pane .TopLeftCellAttr =&cellRef ;};

// SetPasswordHash sets the password hash to the input.
func (_degf SheetProtection )SetPasswordHash (pwHash string ){_degf ._dgdf .PasswordAttr =_fcgc .String (pwHash );};

// Wrapped returns true if the cell will wrap text.
func (_cag CellStyle )Wrapped ()bool {if _cag ._ddbb .Alignment ==nil {return false ;};if _cag ._ddbb .Alignment .WrapTextAttr ==nil {return false ;};return *_cag ._ddbb .Alignment .WrapTextAttr ;};

// SheetCount returns the number of sheets in the workbook.
func (_ecbb Workbook )SheetCount ()int {return len (_ecbb ._cbef )};

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_eegd Cell )SetBool (v bool ){_eegd .clearValue ();_eegd ._ecbe .V =_fcgc .String (_ggfd .Itoa (_gbc (v )));_eegd ._ecbe .TAttr =_efed .ST_CellTypeB ;};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_eceb *Workbook )AddDrawing ()Drawing {_cged :=_gcge .NewWsDr ();_eceb ._gde =append (_eceb ._gde ,_cged );_bcfe :=_fcgc .AbsoluteFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .DrawingType ,len (_eceb ._gde ));_eceb .ContentTypes .AddOverride (_bcfe ,_fcgc .DrawingContentType );_eceb ._fee =append (_eceb ._fee ,_gfdb .NewRelationships ());return Drawing {_eceb ,_cged };};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_afcg Sheet )Extents ()string {_gc ,_db ,_fcge ,_acae :=_afcg .ExtentsIndex ();return _beba .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_gc ,_db ,_fcge ,_acae );};

// SetCol set the column of the cell marker.
func (_dfbe CellMarker )SetCol (col int32 ){_dfbe ._bbd .Col =col };func (_gfeg *Sheet )updateAfterRemove (_egd uint32 ,_dag _caa .UpdateAction )error {_ggbg :=_gfeg .Name ();_cfbb :=&_caa .UpdateQuery {UpdateType :_dag ,ColumnIdx :_egd ,SheetToUpdate :_ggbg };for _ ,_bgff :=range _gfeg ._bdgb .Sheets (){_cfbb .UpdateCurrentSheet =_ggbg ==_bgff .Name ();for _ ,_dgec :=range _bgff .Rows (){for _ ,_aece :=range _dgec .Cells (){if _aece .X ().F !=nil {_cdf :=_aece .X ().F .Content ;_fcca :=_acdfa .ParseString (_cdf );if _fcca ==nil {_aece .SetError ("\u0023\u0052\u0045F\u0021");}else {_dadf :=_fcca .Update (_cfbb );_aece .X ().F .Content =_beba .Sprintf ("\u003d\u0025\u0073",_dadf .String ());};};};};};return nil ;};func (_ede ConditionalFormattingRule )clear (){_ede ._defb .OperatorAttr =_efed .ST_ConditionalFormattingOperatorUnset ;_ede ._defb .ColorScale =nil ;_ede ._defb .IconSet =nil ;_ede ._defb .Formula =nil ;};var ErrorNotFound =_edc .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// HasFormula returns true if the cell has an asoociated formula.
func (_abebe Cell )HasFormula ()bool {return _abebe ._ecbe .F !=nil };

// SetIcons sets the icon set to use for display.
func (_cb IconScale )SetIcons (t _efed .ST_IconSetType ){_cb ._dba .IconSetAttr =t };

// SetColor sets the text color.
func (_dcba RichTextRun )SetColor (c _gbda .Color ){_dcba .ensureRpr ();_dcba ._efec .RPr .Color =_efed .NewCT_Color ();_ada :="\u0066\u0066"+*c .AsRGBString ();_dcba ._efec .RPr .Color .RgbAttr =&_ada ;};

// X returns the inner wrapped XML type.
func (_cada Drawing )X ()*_gcge .WsDr {return _cada ._gccd };type PatternFill struct{_bgcg *_efed .CT_PatternFill ;_ggca *_efed .CT_Fill ;};

// X returns the inner wrapped XML type.
func (_abcd Font )X ()*_efed .CT_Font {return _abcd ._gca };

// X returns the inner wrapped XML type.
func (_ffdb RichTextRun )X ()*_efed .CT_RElt {return _ffdb ._efec };

// Cell returns the actual cell behind the merged region
func (_degd MergedCell )Cell ()Cell {_ggfb :=_degd .Reference ();if _ggaa :=_babc .Index (_degd .Reference (),"\u003a");_ggaa !=-1{_ggfb =_ggfb [0:_ggaa ];return _degd ._ecca .Cell (_ggfb );};return Cell {};};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_fed *_efed .CT_DataValidation };func (_efg Border )SetBottom (style _efed .ST_BorderStyle ,c _gbda .Color ){if _efg ._gafc .Bottom ==nil {_efg ._gafc .Bottom =_efed .NewCT_BorderPr ();};_efg ._gafc .Bottom .Color =_efed .NewCT_Color ();_efg ._gafc .Bottom .Color .RgbAttr =c .AsRGBAString ();_efg ._gafc .Bottom .StyleAttr =style ;};

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_afcf *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_ecbcb :=_efed .NewCT_ConditionalFormatting ();_afcf ._ed .ConditionalFormatting =append (_afcf ._ed .ConditionalFormatting ,_ecbcb );_feacc :=make (_efed .ST_Sqref ,0,0);_ecbcb .SqrefAttr =&_feacc ;for _ ,_ebgf :=range cellRanges {*_ecbcb .SqrefAttr =append (*_ecbcb .SqrefAttr ,_ebgf );};return ConditionalFormatting {_ecbcb };};

// MoveTo is a no-op.
func (_bdc AbsoluteAnchor )MoveTo (x ,y int32 ){};

// AddFormatValue adds a format value (databars require two).
func (_dca DataBarScale )AddFormatValue (t _efed .ST_CfvoType ,val string ){_cfdb :=_efed .NewCT_Cfvo ();_cfdb .TypeAttr =t ;_cfdb .ValAttr =_fcgc .String (val );_dca ._feba .Cfvo =append (_dca ._feba .Cfvo ,_cfdb );};func (_defde *Sheet )setShared (_bdcd string ,_egac ,_bfee _cgebb .CellReference ,_egff string ){_ebdec :=_defde .FormulaContext ();_ebbcf :=_acdfa .NewEvaluator ();for _fbcc :=_egac .RowIdx ;_fbcc <=_bfee .RowIdx ;_fbcc ++{for _gcfc :=_egac .ColumnIdx ;_gcfc <=_bfee .ColumnIdx ;_gcfc ++{_dcfg :=_fbcc -_egac .RowIdx ;_fdbc :=_gcfc -_egac .ColumnIdx ;_ebdec .SetOffset (_fdbc ,_dcfg );_cbe :=_ebbcf .Eval (_ebdec ,_egff );_gfdf :=_beba .Sprintf ("\u0025\u0073\u0025\u0064",_cgebb .IndexToColumn (_gcfc ),_fbcc );_gcac :=_defde .Cell (_gfdf );if _cbe .Type ==_acdfa .ResultTypeNumber {_gcac .X ().TAttr =_efed .ST_CellTypeN ;}else {_gcac .X ().TAttr =_efed .ST_CellTypeInlineStr ;};_gcac .X ().V =_fcgc .String (_cbe .Value ());};};_ =_ebbcf ;_ =_ebdec ;};

// SetWidth sets the width of the anchored object.
func (_cggda OneCellAnchor )SetWidth (w _aag .Distance ){_cggda ._ccd .Ext .CxAttr =int64 (w /_aag .EMU )};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_ccc Cell )GetValueAsTime ()(_dfga .Time ,error ){if _ccc ._ecbe .TAttr !=_efed .ST_CellTypeUnset {return _dfga .Time {},_edc .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");};if _ccc ._ecbe .V ==nil {return _dfga .Time {},_edc .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_eefg ,_ ,_egag :=_dfb .ParseFloat (*_ccc ._ecbe .V ,10,128,_dfb .ToNearestEven );if _egag !=nil {return _dfga .Time {},_egag ;};_dbea :=new (_dfb .Float );_dbea .SetUint64 (uint64 (24*_dfga .Hour ));_eefg .Mul (_eefg ,_dbea );_aaad ,_ :=_eefg .Uint64 ();_ececb :=_ccc ._dcbg .Epoch ().Add (_dfga .Duration (_aaad ));return _cfca (_ececb ),nil ;};

// AddDataValidation adds a data validation rule to a sheet.
func (_efde *Sheet )AddDataValidation ()DataValidation {if _efde ._ed .DataValidations ==nil {_efde ._ed .DataValidations =_efed .NewCT_DataValidations ();};_cab :=_efed .NewCT_DataValidation ();_cab .ShowErrorMessageAttr =_fcgc .Bool (true );_efde ._ed .DataValidations .DataValidation =append (_efde ._ed .DataValidations .DataValidation ,_cab );_efde ._ed .DataValidations .CountAttr =_fcgc .Uint32 (uint32 (len (_efde ._ed .DataValidations .DataValidation )));return DataValidation {_cab };};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_gfdb .DocBase ;_fbc *_efed .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_fbea []*_efed .Comments ;_cbef []*_efed .Worksheet ;_adec []_gfdb .Relationships ;_fgga _gfdb .Relationships ;_aff []*_eada .Theme ;_gde []*_gcge .WsDr ;_fee []_gfdb .Relationships ;_bgce []*_cdbe .Container ;_aeef []*_aegbf .ChartSpace ;_cefb []*_efed .Table ;_gdgg string ;};

// CellStyle is a formatting style for a cell.  CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_gddc *Workbook ;_ddbb *_efed .CT_Xf ;_bca *_efed .CT_CellXfs ;};

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_gffa *Sheet )RemoveColumn (column string )error {_ea ,_ecag :=_gffa .getAllCellsInFormulaArraysForColumn ();if _ecag !=nil {return _ecag ;};_bga :=_cgebb .ColumnToIndex (column );for _ ,_bcbe :=range _gffa .Rows (){_gacfa :=_beba .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_bcbe .X ().RAttr );if _ ,_ffc :=_ea [_gacfa ];_ffc {return nil ;};};for _ ,_fcbf :=range _gffa .Rows (){_fffb :=_fcbf ._dcaa .C ;for _fcgef ,_adga :=range _fffb {_eccg ,_aagbb :=_cgebb .ParseCellReference (*_adga .RAttr );if _aagbb !=nil {return _aagbb ;};if _eccg .ColumnIdx ==_bga {_fcbf ._dcaa .C =append (_fffb [:_fcgef ],_gffa .slideCellsLeft (_fffb [_fcgef +1:])...);break ;}else if _eccg .ColumnIdx > _bga {_fcbf ._dcaa .C =append (_fffb [:_fcgef ],_gffa .slideCellsLeft (_fffb [_fcgef :])...);break ;};};};_ecag =_gffa .updateAfterRemove (_bga ,_caa .UpdateActionRemoveColumn );if _ecag !=nil {return _ecag ;};_ecag =_gffa .removeColumnFromNamedRanges (_bga );if _ecag !=nil {return _ecag ;};_ecag =_gffa .removeColumnFromMergedCells (_bga );if _ecag !=nil {return _ecag ;};for _ ,_fbae :=range _gffa ._bdgb .Sheets (){_fbae .RecalculateFormulas ();};return nil ;};

// SetXSplit sets the column split point
func (_adac SheetView )SetXSplit (v float64 ){_adac .ensurePane ();_adac ._cbbc .Pane .XSplitAttr =_fcgc .Float64 (v );};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_dac StyleSheet )RemoveFont (f Font )error {for _ddgb ,_ffccb :=range _dac ._deb .Fonts .Font {if _ffccb ==f .X (){_dac ._deb .Fonts .Font =append (_dac ._deb .Fonts .Font [:_ddgb ],_dac ._deb .Fonts .Font [_ddgb +1:]...);return nil ;};};return _edc .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_defd TwoCellAnchor )SetWidthCells (w int32 ){_gaa :=_defd .TopLeft ();_cee :=_defd .BottomRight ();_cee .SetCol (_gaa .Col ()+w );};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_eebb DataValidationList )SetValues (values []string ){_eebb ._fed .Formula1 =_fcgc .String ("\u0022"+_babc .Join (values ,"\u002c")+"\u0022");_eebb ._fed .Formula2 =_fcgc .String ("\u0030");};var _bdad =_fcgc .RelativeFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .OfficeDocumentType ,_fcgc .SharedStringsType ,0);

// MoveTo repositions the anchor without changing the objects size.
func (_caab TwoCellAnchor )MoveTo (col ,row int32 ){_gcag :=_caab .TopLeft ();_bbff :=_caab .BottomRight ();_aebb :=_bbff .Col ()-_gcag .Col ();_gfd :=_bbff .Row ()-_gcag .Row ();_gcag .SetCol (col );_gcag .SetRow (row );_bbff .SetCol (col +_aebb );_bbff .SetRow (row +_gfd );};

// SetSize sets the text size for a rich text run.
func (_ead RichTextRun )SetSize (m _aag .Distance ){_ead .ensureRpr ();_ead ._efec .RPr .Sz =_efed .NewCT_FontSize ();_ead ._efec .RPr .Sz .ValAttr =float64 (m /_aag .Point );};

// SetNumber sets the cell type to number, and the value to the given number
func (_gbcda Cell )SetNumber (v float64 ){_gbcda .clearValue ();if _aggf .IsNaN (v )||_aggf .IsInf (v ,0){_gbcda ._ecbe .TAttr =_efed .ST_CellTypeE ;_gbcda ._ecbe .V =_fcgc .String ("\u0023\u004e\u0055M\u0021");return ;};_gbcda ._ecbe .TAttr =_efed .ST_CellTypeN ;_gbcda ._ecbe .V =_fcgc .String (_ggfd .FormatFloat (v ,'f',-1,64));};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_aebc Row )Cell (col string )Cell {_abee :=_beba .Sprintf ("\u0025\u0073\u0025\u0064",col ,_aebc .RowNumber ());for _ ,_eab :=range _aebc ._dcaa .C {if _eab .RAttr !=nil &&*_eab .RAttr ==_abee {return Cell {_aebc ._gcbf ,_aebc ._bcdf ,_aebc ._dcaa ,_eab };};};return _aebc .AddNamedCell (col );};

// IsSheetLocked returns whether the sheet is locked.
func (_gdeeg SheetProtection )IsSheetLocked ()bool {return _gdeeg ._dgdf .SheetAttr !=nil &&*_gdeeg ._dgdf .SheetAttr ;};

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_eeba NumberFormat )ID ()uint32 {return _eeba ._ceea .NumFmtIdAttr };func init (){_bcced ()};

// AddMergedCells merges cells within a sheet.
func (_bfgb *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _bfgb ._ed .MergeCells ==nil {_bfgb ._ed .MergeCells =_efed .NewCT_MergeCells ();};_bead :=_efed .NewCT_MergeCell ();_bead .RefAttr =_beba .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );_bfgb ._ed .MergeCells .MergeCell =append (_bfgb ._ed .MergeCells .MergeCell ,_bead );_bfgb ._ed .MergeCells .CountAttr =_fcgc .Uint32 (uint32 (len (_bfgb ._ed .MergeCells .MergeCell )));return MergedCell {_bfgb ._bdgb ,_bfgb ,_bead };};

// TopLeft returns the top-left corner of the anchored object.
func (_ced OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_ced ._ccd .From }};var _geca *_beg .Regexp =_beg .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_bdb ,_gebb int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_cagd _aag .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_aagba int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_edfc _aag .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_eef int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_agac _aag .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_ffff _aag .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_gdb Row )RowNumber ()uint32 {if _gdb ._dcaa .RAttr !=nil {return *_gdb ._dcaa .RAttr ;};return 0;};

// LockWindow controls the locking of the workbook windows.
func (_efdb WorkbookProtection )LockWindow (b bool ){if !b {_efdb ._cagc .LockWindowsAttr =nil ;}else {_efdb ._cagc .LockWindowsAttr =_fcgc .Bool (true );};};func _gda (_bccf *Workbook ){_bccf .Close ()};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_aceb *_gcge .CT_TwoCellAnchor };

// ClearFill clears any fill configuration from the cell style.
func (_dcee CellStyle )ClearFill (){_dcee ._ddbb .FillIdAttr =nil ;_dcee ._ddbb .ApplyFillAttr =nil };

// X returns the inner wrapped XML type.
func (_abbd MergedCell )X ()*_efed .CT_MergeCell {return _abbd ._ebc };func (_acdc CellStyle )SetShrinkToFit (b bool ){if _acdc ._ddbb .Alignment ==nil {_acdc ._ddbb .Alignment =_efed .NewCT_CellAlignment ();};_acdc ._ddbb .ApplyAlignmentAttr =_fcgc .Bool (true );if !b {_acdc ._ddbb .Alignment .ShrinkToFitAttr =nil ;}else {_acdc ._ddbb .Alignment .ShrinkToFitAttr =_fcgc .Bool (b );};};

// AddCellStyle adds a new empty cell style to the stylesheet.
func (_bfgf StyleSheet )AddCellStyle ()CellStyle {_fdcb :=_efed .NewCT_Xf ();_bfgf ._deb .CellXfs .Xf =append (_bfgf ._deb .CellXfs .Xf ,_fdcb );_bfgf ._deb .CellXfs .CountAttr =_fcgc .Uint32 (uint32 (len (_bfgf ._deb .CellXfs .Xf )));return CellStyle {_bfgf ._eacfc ,_fdcb ,_bfgf ._deb .CellXfs };};func (_cbd DataValidation )clear (){_cbd ._bdbe .Formula1 =_fcgc .String ("\u0030");_cbd ._bdbe .Formula2 =_fcgc .String ("\u0030");};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_dcaf Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_dcaf .SetNumber (v );_dcaf .SetStyle (_dcaf ._dcbg .StyleSheet .GetOrCreateStandardNumberFormat (f ));};func (_fdebf PatternFill )X ()*_efed .CT_PatternFill {return _fdebf ._bgcg };

// IsHidden returns whether the row is hidden or not.
func (_acce Row )IsHidden ()bool {return _acce ._dcaa .HiddenAttr !=nil &&*_acce ._dcaa .HiddenAttr };func (_cfea *Sheet )setList (_dd string ,_efa _acdfa .Result )error {_beee ,_eea :=_cgebb .ParseCellReference (_dd );if _eea !=nil {return _eea ;};_ceca :=_cfea .Row (_beee .RowIdx );for _cadag ,_fcf :=range _efa .ValueList {_efga :=_ceca .Cell (_cgebb .IndexToColumn (_beee .ColumnIdx +uint32 (_cadag )));if _fcf .Type !=_acdfa .ResultTypeEmpty {if _fcf .IsBoolean {_efga .SetBool (_fcf .ValueNumber !=0);}else {_efga .SetCachedFormulaResult (_fcf .String ());};};};return nil ;};func (_gabb CellStyle )Index ()uint32 {for _dcf ,_aegb :=range _gabb ._bca .Xf {if _gabb ._ddbb ==_aegb {return uint32 (_dcf );};};return 0;};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_bce *Workbook )Epoch ()_dfga .Time {if _bce .Uses1904Dates (){_dfga .Date (1904,1,1,0,0,0,0,_dfga .UTC );};return _dfga .Date (1899,12,30,0,0,0,0,_dfga .UTC );};

// LockObject controls the locking of the sheet objects.
func (_aebbf SheetProtection )LockObject (b bool ){if !b {_aebbf ._dgdf .ObjectsAttr =nil ;}else {_aebbf ._dgdf .ObjectsAttr =_fcgc .Bool (true );};};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_edda *_efed .CT_DefinedName };

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_cdbg Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_bggb :=[]Cell {};for _ggcg :=uint32 (0);_ggcg <=lastColIdx ;_ggcg ++{_cgcf :=_cdbg .Cell (_cgebb .IndexToColumn (_ggcg ));_bggb =append (_bggb ,_cgcf );};return _bggb ;};

// GetEpoch returns a workbook's time epoch.
func (_ggbf *evalContext )GetEpoch ()_dfga .Time {return _ggbf ._eee ._bdgb .Epoch ()};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_adf *_gcge .CT_AbsoluteAnchor };

// X returns the inner wrapped XML type.
func (_abc *Workbook )X ()*_efed .Workbook {return _abc ._fbc };

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_bggg *Sheet )InitialView ()SheetView {if _bggg ._ed .SheetViews ==nil ||len (_bggg ._ed .SheetViews .SheetView )==0{return _bggg .AddView ();};return SheetView {_bggg ._ed .SheetViews .SheetView [0]};};

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_cabeb *_efed .CT_DataValidation };

// X returns the inner wrapped XML type.
func (_cgaa DifferentialStyle )X ()*_efed .CT_Dxf {return _cgaa ._efd };

// X returns the inner wrapped XML type.
func (_eface DataBarScale )X ()*_efed .CT_DataBar {return _eface ._feba };

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_ebad ConditionalFormattingRule )SetColorScale ()ColorScale {_ebad .clear ();_ebad .SetType (_efed .ST_CfTypeColorScale );_ebad ._defb .ColorScale =_efed .NewCT_ColorScale ();return ColorScale {_ebad ._defb .ColorScale };};

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_de *_efed .CT_Col };

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_bdcb :=_efed .NewStyleSheet ();_bdcb .CellStyleXfs =_efed .NewCT_CellStyleXfs ();_bdcb .CellXfs =_efed .NewCT_CellXfs ();_bdcb .CellStyles =_efed .NewCT_CellStyles ();_cfbea :=_efed .NewCT_CellStyle ();_cfbea .NameAttr =_fcgc .String ("\u004e\u006f\u0072\u006d\u0061\u006c");_cfbea .XfIdAttr =0;_cfbea .BuiltinIdAttr =_fcgc .Uint32 (0);_bdcb .CellStyles .CellStyle =append (_bdcb .CellStyles .CellStyle ,_cfbea );_bdcb .CellStyles .CountAttr =_fcgc .Uint32 (uint32 (len (_bdcb .CellStyles .CellStyle )));_egdc :=_efed .NewCT_Xf ();_egdc .NumFmtIdAttr =_fcgc .Uint32 (0);_egdc .FontIdAttr =_fcgc .Uint32 (0);_egdc .FillIdAttr =_fcgc .Uint32 (0);_egdc .BorderIdAttr =_fcgc .Uint32 (0);_bdcb .CellStyleXfs .Xf =append (_bdcb .CellStyleXfs .Xf ,_egdc );_bdcb .CellStyleXfs .CountAttr =_fcgc .Uint32 (uint32 (len (_bdcb .CellStyleXfs .Xf )));_agbd :=NewFills ();_bdcb .Fills =_agbd .X ();_cfa :=_agbd .AddFill ().SetPatternFill ();_cfa .SetPattern (_efed .ST_PatternTypeNone );_cfa =_agbd .AddFill ().SetPatternFill ();_cfa .SetPattern (_efed .ST_PatternTypeGray125 );_bdcb .Fonts =_efed .NewCT_Fonts ();_bdcb .Borders =_efed .NewCT_Borders ();_egf :=StyleSheet {wb ,_bdcb };_egf .AddBorder ().InitializeDefaults ();_eabf :=_egf .AddFont ();_eabf .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_eabf .SetSize (11);_aegd :=_efed .NewCT_Xf ();*_aegd =*_egdc ;_aegd .XfIdAttr =_fcgc .Uint32 (0);_bdcb .CellXfs .Xf =append (_bdcb .CellXfs .Xf ,_aegd );_bdcb .CellXfs .CountAttr =_fcgc .Uint32 (uint32 (len (_bdcb .CellXfs .Xf )));return _egf ;};

// AddString adds a string to the shared string cache.
func (_fbfea SharedStrings )AddString (v string )int {if _feda ,_dda :=_fbfea ._gfac [v ];_dda {return _feda ;};_ffdg :=_efed .NewCT_Rst ();_ffdg .T =_fcgc .String (v );_fbfea ._fcc .Si =append (_fbfea ._fcc .Si ,_ffdg );_cdc :=len (_fbfea ._fcc .Si )-1;_fbfea ._gfac [v ]=_cdc ;_fbfea ._fcc .CountAttr =_fcgc .Uint32 (uint32 (len (_fbfea ._fcc .Si )));_fbfea ._fcc .UniqueCountAttr =_fbfea ._fcc .CountAttr ;return _cdc ;};

// Protection controls the protection on an individual sheet.
func (_acef *Sheet )Protection ()SheetProtection {if _acef ._ed .SheetProtection ==nil {_acef ._ed .SheetProtection =_efed .NewCT_SheetProtection ();};return SheetProtection {_acef ._ed .SheetProtection };};func (_gbe DifferentialStyle )Fill ()Fill {if _gbe ._efd .Fill ==nil {_gbe ._efd .Fill =_efed .NewCT_Fill ();};return Fill {_gbe ._efd .Fill ,nil };};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_dbb *Sheet )Cell (cellRef string )Cell {_fggc ,_dgfc :=_cgebb .ParseCellReference (cellRef );if _dgfc !=nil {_fcgc .Log ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_dgfc );return _dbb .AddRow ().AddCell ();};return _dbb .Row (_fggc .RowIdx ).Cell (_fggc .Column );};

// Index returns the index of the border for use with a cell style.
func (_ffcc Border )Index ()uint32 {for _bgaab ,_bgfg :=range _ffcc ._efaa .Border {if _bgfg ==_ffcc ._gafc {return uint32 (_bgaab );};};return 0;};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_dcbf StyleSheet )Fills ()Fills {return Fills {_dcbf ._deb .Fills }};

// Cell is a single cell within a sheet.
type Cell struct{_dcbg *Workbook ;_dbgd *Sheet ;_dcg *_efed .CT_Row ;_ecbe *_efed .CT_Cell ;};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_aee Border )InitializeDefaults (){_aee ._gafc .Left =_efed .NewCT_BorderPr ();_aee ._gafc .Bottom =_efed .NewCT_BorderPr ();_aee ._gafc .Right =_efed .NewCT_BorderPr ();_aee ._gafc .Top =_efed .NewCT_BorderPr ();_aee ._gafc .Diagonal =_efed .NewCT_BorderPr ();};

// IsEmpty checks if the cell style contains nothing.
func (_dae CellStyle )IsEmpty ()bool {return _dae ._gddc ==nil ||_dae ._ddbb ==nil ||_dae ._bca ==nil ||_dae ._bca .Xf ==nil ;};const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_dbe Cell )GetCachedFormulaResult ()string {if _dbe ._ecbe .V !=nil {return *_dbe ._ecbe .V ;};return "";};

// SetHidden hides or unhides the row
func (_aefa Row )SetHidden (hidden bool ){if !hidden {_aefa ._dcaa .HiddenAttr =nil ;}else {_aefa ._dcaa .HiddenAttr =_fcgc .Bool (true );};};func (_bcfbg Cell )setLocked (_ffcf bool ){_fbbd :=_bcfbg ._ecbe .SAttr ;if _fbbd !=nil {_decbd :=_bcfbg ._dcbg .StyleSheet .GetCellStyle (*_fbbd );if _decbd ._ddbb .Protection ==nil {_decbd ._ddbb .Protection =_efed .NewCT_CellProtection ();};_decbd ._ddbb .Protection .LockedAttr =&_ffcf ;};};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_eba *Workbook )RemoveSheetByName (name string )error {_eade :=-1;for _ceed ,_fffgd :=range _eba .Sheets (){if name ==_fffgd .Name (){_eade =_ceed ;break ;};};if _eade ==-1{return ErrorNotFound ;};return _eba .RemoveSheet (_eade );};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_ceg :=uint16 (0);if len (s )> 0{for _cgdd :=len (s )-1;_cgdd >=0;_cgdd --{_aeb :=s [_cgdd ];_ceg =((_ceg >>14)&0x01)|((_ceg <<1)&0x7fff);_ceg ^=uint16 (_aeb );};_ceg =((_ceg >>14)&0x01)|((_ceg <<1)&0x7fff);_ceg ^=uint16 (len (s ));_ceg ^=(0x8000|('N'<<8)|'K');};return _beba .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_ceg ));};

// SetPasswordHash sets the password hash to the input.
func (_fedd WorkbookProtection )SetPasswordHash (pwHash string ){_fedd ._cagc .WorkbookPasswordAttr =_fcgc .String (pwHash );};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_eacf Comment )CellReference ()string {return _eacf ._gcd .RefAttr };var _gfe =_fcgc .AbsoluteFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .SharedStringsType ,0);

// X returns the inner wrapped XML type.
func (_fcac DefinedName )X ()*_efed .CT_DefinedName {return _fcac ._edda };

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_cega Cell )GetString ()string {switch _cega ._ecbe .TAttr {case _efed .ST_CellTypeInlineStr :if _cega ._ecbe .Is !=nil &&_cega ._ecbe .Is .T !=nil {return *_cega ._ecbe .Is .T ;};if _cega ._ecbe .V !=nil {return *_cega ._ecbe .V ;};case _efed .ST_CellTypeS :if _cega ._ecbe .V ==nil {return "";};_fbgg ,_eeac :=_ggfd .Atoi (*_cega ._ecbe .V );if _eeac !=nil {return "";};_adfb ,_eeac :=_cega ._dcbg .SharedStrings .GetString (_fbgg );if _eeac !=nil {return "";};return _adfb ;};if _cega ._ecbe .V ==nil {return "";};return *_cega ._ecbe .V ;};

// Name returns the name of the defined name.
func (_fgbg DefinedName )Name ()string {return _fgbg ._edda .NameAttr };

// IsStructureLocked returns whether the workbook structure is locked.
func (_gdee WorkbookProtection )IsStructureLocked ()bool {return _gdee ._cagc .LockStructureAttr !=nil &&*_gdee ._cagc .LockStructureAttr ;};func (_degfg Sheet )IsValid ()bool {return _degfg ._ed !=nil };

// HasNumberFormat returns true if the cell style has a number format applied.
func (_fgdf CellStyle )HasNumberFormat ()bool {return _fgdf ._ddbb .NumFmtIdAttr !=nil &&_fgdf ._ddbb .ApplyNumberFormatAttr !=nil &&*_fgdf ._ddbb .ApplyNumberFormatAttr ;};

// SetWidth is a no-op.
func (_cedg TwoCellAnchor )SetWidth (w _aag .Distance ){};func (_ecf StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));};for _ ,_abfe :=range _ecf ._deb .NumFmts .NumFmt {if _abfe .NumFmtIdAttr ==id {return NumberFormat {_ecf ._eacfc ,_abfe };};};return NumberFormat {};};

// SetConditionValue sets the condition value to be used for style applicaton.
func (_bfb ConditionalFormattingRule )SetConditionValue (v string ){_bfb ._defb .Formula =[]string {v }};

// X returns the inner wrapped XML type.
func (_gaeg ConditionalFormatting )X ()*_efed .CT_ConditionalFormatting {return _gaeg ._dcea };

// DataValidation controls cell validation
type DataValidation struct{_bdbe *_efed .CT_DataValidation };type Fills struct{_bcb *_efed .CT_Fills };

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_dcea *_efed .CT_ConditionalFormatting ;};

// X returns the inner wrapped XML type.
func (_fffe WorkbookProtection )X ()*_efed .CT_WorkbookProtection {return _fffe ._cagc };

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_fbbda Cell )SetCachedFormulaResult (s string ){_fbbda ._ecbe .V =&s };

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_ebag Cell )GetFormattedValue ()string {_dbcf :=_ebag .getFormat ();switch _ebag ._ecbe .TAttr {case _efed .ST_CellTypeB :_bcd ,_ :=_ebag .GetValueAsBool ();if _bcd {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _efed .ST_CellTypeN :_bccd ,_ :=_ebag .GetValueAsNumber ();return _eagd .Number (_bccd ,_dbcf );case _efed .ST_CellTypeE :if _ebag ._ecbe .V !=nil {return *_ebag ._ecbe .V ;};return "";case _efed .ST_CellTypeS ,_efed .ST_CellTypeInlineStr :return _eagd .String (_ebag .GetString (),_dbcf );case _efed .ST_CellTypeStr :_dec :=_ebag .GetString ();if _eagd .IsNumber (_dec ){_bgf ,_ :=_ggfd .ParseFloat (_dec ,64);return _eagd .Number (_bgf ,_dbcf );};return _eagd .String (_dec ,_dbcf );case _efed .ST_CellTypeUnset :fallthrough;default:_gbef ,_ :=_ebag .GetRawValue ();if len (_gbef )==0{return "";};_afb ,_abg :=_ebag .GetValueAsNumber ();if _abg ==nil {return _eagd .Number (_afb ,_dbcf );};return _eagd .String (_gbef ,_dbcf );};};

// SetRowOffset sets the row offset of the top-left anchor.
func (_dcbfb OneCellAnchor )SetRowOffset (m _aag .Distance ){_dcbfb .TopLeft ().SetRowOffset (m )};func (_dabec DataValidation )SetList ()DataValidationList {_dabec .clear ();_dabec ._bdbe .TypeAttr =_efed .ST_DataValidationTypeList ;_dabec ._bdbe .OperatorAttr =_efed .ST_DataValidationOperatorEqual ;return DataValidationList {_dabec ._bdbe };};type WorkbookProtection struct{_cagc *_efed .CT_WorkbookProtection };

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_bed StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _bed ._deb .Dxfs ==nil {_bed ._deb .Dxfs =_efed .NewCT_Dxfs ();};_fccb :=_efed .NewCT_Dxf ();_bed ._deb .Dxfs .Dxf =append (_bed ._deb .Dxfs .Dxf ,_fccb );_bed ._deb .Dxfs .CountAttr =_fcgc .Uint32 (uint32 (len (_bed ._deb .Dxfs .Dxf )));return DifferentialStyle {_fccb ,_bed ._eacfc ,_bed ._deb .Dxfs };};

// SetMinLength sets the minimum bar length in percent.
func (_ccdd DataBarScale )SetMinLength (l uint32 ){_ccdd ._feba .MinLengthAttr =_fcgc .Uint32 (l )};

// SetShowRuler controls the visibility of the ruler
func (_ggd SheetView )SetShowRuler (b bool ){if !b {_ggd ._cbbc .ShowRulerAttr =_fcgc .Bool (false );}else {_ggd ._cbbc .ShowRulerAttr =nil ;};};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_bgaa Cell )SetRichTextString ()RichText {_bgaa .clearValue ();_bgaa ._ecbe .Is =_efed .NewCT_Rst ();_bgaa ._ecbe .TAttr =_efed .ST_CellTypeInlineStr ;return RichText {_bgaa ._ecbe .Is };};func (_gede CellStyle )SetNumberFormat (s string ){_badc :=_gede ._gddc .StyleSheet .AddNumberFormat ();_badc .SetFormat (s );_gede ._ddbb .ApplyNumberFormatAttr =_fcgc .Bool (true );_gede ._ddbb .NumFmtIdAttr =_fcgc .Uint32 (_badc .ID ());};

// SetBorder applies a border to a cell style.  The border is referenced by its
// index so modifying the border afterward will affect all styles that reference
// it.
func (_gab CellStyle )SetBorder (b Border ){_gab ._ddbb .BorderIdAttr =_fcgc .Uint32 (b .Index ());_gab ._ddbb .ApplyBorderAttr =_fcgc .Bool (true );};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_dedf *Sheet )ClearSheetViews (){_dedf ._ed .SheetViews =nil };

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_dc *Sheet )SetBorder (cellRange string ,border Border )error {_bage ,_gdaa ,_ag :=_cgebb .ParseRangeReference (cellRange );if _ag !=nil {return _ag ;};_bedg :=_dc ._bdgb .StyleSheet .AddCellStyle ();_bfcd :=_dc ._bdgb .StyleSheet .AddBorder ();_bedg .SetBorder (_bfcd );_bfcd ._gafc .Top =border ._gafc .Top ;_bfcd ._gafc .Left =border ._gafc .Left ;_eabg :=_dc ._bdgb .StyleSheet .AddCellStyle ();_aab :=_dc ._bdgb .StyleSheet .AddBorder ();_eabg .SetBorder (_aab );_aab ._gafc .Top =border ._gafc .Top ;_aab ._gafc .Right =border ._gafc .Right ;_fdac :=_dc ._bdgb .StyleSheet .AddCellStyle ();_bcbb :=_dc ._bdgb .StyleSheet .AddBorder ();_fdac .SetBorder (_bcbb );_bcbb ._gafc .Top =border ._gafc .Top ;_fba :=_dc ._bdgb .StyleSheet .AddCellStyle ();_bcg :=_dc ._bdgb .StyleSheet .AddBorder ();_fba .SetBorder (_bcg );_bcg ._gafc .Left =border ._gafc .Left ;_fcfg :=_dc ._bdgb .StyleSheet .AddCellStyle ();_e :=_dc ._bdgb .StyleSheet .AddBorder ();_fcfg .SetBorder (_e );_e ._gafc .Right =border ._gafc .Right ;_eded :=_dc ._bdgb .StyleSheet .AddCellStyle ();_bdfbc :=_dc ._bdgb .StyleSheet .AddBorder ();_eded .SetBorder (_bdfbc );_bdfbc ._gafc .Bottom =border ._gafc .Bottom ;_aegc :=_dc ._bdgb .StyleSheet .AddCellStyle ();_gfed :=_dc ._bdgb .StyleSheet .AddBorder ();_aegc .SetBorder (_gfed );_gfed ._gafc .Bottom =border ._gafc .Bottom ;_gfed ._gafc .Left =border ._gafc .Left ;_aabe :=_dc ._bdgb .StyleSheet .AddCellStyle ();_gece :=_dc ._bdgb .StyleSheet .AddBorder ();_aabe .SetBorder (_gece );_gece ._gafc .Bottom =border ._gafc .Bottom ;_gece ._gafc .Right =border ._gafc .Right ;_befa :=_bage .RowIdx ;_geeb :=_bage .ColumnIdx ;_gabe :=_gdaa .RowIdx ;_efcd :=_gdaa .ColumnIdx ;for _egfd :=_befa ;_egfd <=_gabe ;_egfd ++{for _cbed :=_geeb ;_cbed <=_efcd ;_cbed ++{_aed :=_beba .Sprintf ("\u0025\u0073\u0025\u0064",_cgebb .IndexToColumn (_cbed ),_egfd );switch {case _egfd ==_befa &&_cbed ==_geeb :_dc .Cell (_aed ).SetStyle (_bedg );case _egfd ==_befa &&_cbed ==_efcd :_dc .Cell (_aed ).SetStyle (_eabg );case _egfd ==_gabe &&_cbed ==_geeb :_dc .Cell (_aed ).SetStyle (_aegc );case _egfd ==_gabe &&_cbed ==_efcd :_dc .Cell (_aed ).SetStyle (_aabe );case _egfd ==_befa :_dc .Cell (_aed ).SetStyle (_fdac );case _egfd ==_gabe :_dc .Cell (_aed ).SetStyle (_eded );case _cbed ==_geeb :_dc .Cell (_aed ).SetStyle (_fba );case _cbed ==_efcd :_dc .Cell (_aed ).SetStyle (_fcfg );};};};return nil ;};

// SetYSplit sets the row split point
func (_gf SheetView )SetYSplit (v float64 ){_gf .ensurePane ();_gf ._cbbc .Pane .YSplitAttr =_fcgc .Float64 (v );};var _gfebc =[...]uint8 {0,18,37};

// Name returns the sheet name
func (_abfd Sheet )Name ()string {return _abfd ._ccfb .NameAttr };

// Author returns the author of the comment
func (_adc Comment )Author ()string {if _adc ._gcd .AuthorIdAttr < uint32 (len (_adc ._egg .Authors .Author )){return _adc ._egg .Authors .Author [_adc ._gcd .AuthorIdAttr ];};return "";};

// SetWidth sets the width of the anchored object.
func (_ccge AbsoluteAnchor )SetWidth (w _aag .Distance ){_ccge ._adf .Ext .CxAttr =int64 (w /_aag .EMU )};

// Rows returns all of the rows in a sheet.
func (_dgc *Sheet )Rows ()[]Row {_cfb :=[]Row {};for _ ,_fage :=range _dgc ._ed .SheetData .Row {_cfb =append (_cfb ,Row {_dgc ._bdgb ,_dgc ,_fage });};return _cfb ;};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_dcgc Sheet )RangeReference (n string )string {_eca :=_babc .Split (n ,"\u003a");_ged ,_ :=_cgebb .ParseCellReference (_eca [0]);_bdeg :=_beba .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_ged .Column ,_ged .RowIdx );if len (_eca )==1{return _beba .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_dcgc .Name (),_bdeg );};_gfdfa ,_ :=_cgebb .ParseCellReference (_eca [1]);_cbf :=_beba .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_gfdfa .Column ,_gfdfa .RowIdx );return _beba .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_dcgc .Name (),_bdeg ,_cbf );};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;func (_edb Border )SetLeft (style _efed .ST_BorderStyle ,c _gbda .Color ){if _edb ._gafc .Left ==nil {_edb ._gafc .Left =_efed .NewCT_BorderPr ();};_edb ._gafc .Left .Color =_efed .NewCT_Color ();_edb ._gafc .Left .Color .RgbAttr =c .AsRGBAString ();_edb ._gafc .Left .StyleAttr =style ;};var _afg []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};

// SetHeightCells is a no-op.
func (_gdfb AbsoluteAnchor )SetHeightCells (int32 ){};

// Name returns the name of the table
func (_cgg Table )Name ()string {if _cgg ._eg .NameAttr !=nil {return *_cgg ._eg .NameAttr ;};return "";};func (_feb Comments )getOrCreateAuthor (_babaf string )uint32 {for _fagg ,_af :=range _feb ._gcdc .Authors .Author {if _af ==_babaf {return uint32 (_fagg );};};_fdgd :=uint32 (len (_feb ._gcdc .Authors .Author ));_feb ._gcdc .Authors .Author =append (_feb ._gcdc .Authors .Author ,_babaf );return _fdgd ;};func (_ebf DataValidationCompare )SetValue2 (v string ){_ebf ._cabeb .Formula2 =&v };

// X returns the inner wrapped XML type.
func (_faff Row )X ()*_efed .CT_Row {return _faff ._dcaa };

// AddView adds a sheet view.
func (_ggf *Sheet )AddView ()SheetView {if _ggf ._ed .SheetViews ==nil {_ggf ._ed .SheetViews =_efed .NewCT_SheetViews ();};_fecg :=_efed .NewCT_SheetView ();_ggf ._ed .SheetViews .SheetView =append (_ggf ._ed .SheetViews .SheetView ,_fecg );return SheetView {_fecg };};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_dbad *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_cfg :=-1;for _fddfg ,_acd :=range _dbad .Sheets (){if name ==_acd .Name (){_cfg =_fddfg ;break ;};};if _cfg ==-1{return Sheet {},ErrorNotFound ;};return _dbad .CopySheet (_cfg ,copiedSheetName );};

// X returns the inner wrapped XML type.
func (_egec Border )X ()*_efed .CT_Border {return _egec ._gafc };

// X returns the inner wrapped XML type.
func (_ga NumberFormat )X ()*_efed .CT_NumFmt {return _ga ._ceea };

// SetHeight sets the height of the anchored object.
func (_daec AbsoluteAnchor )SetHeight (h _aag .Distance ){_daec ._adf .Ext .CyAttr =int64 (h /_aag .EMU )};

// SetAllowBlank controls if blank values are accepted.
func (_cdda DataValidation )SetAllowBlank (b bool ){if !b {_cdda ._bdbe .AllowBlankAttr =nil ;}else {_cdda ._bdbe .AllowBlankAttr =_fcgc .Bool (true );};};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_cca Cell )SetString (s string )int {_cca ._dcbg .ensureSharedStringsRelationships ();_cca .clearValue ();_cddg :=_cca ._dcbg .SharedStrings .AddString (s );_cca ._ecbe .V =_fcgc .String (_ggfd .Itoa (_cddg ));_cca ._ecbe .TAttr =_efed .ST_CellTypeS ;return _cddg ;};

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_fdg *Sheet )InsertRow (rowNum int )Row {_cga :=uint32 (rowNum );for _ ,_bdcdg :=range _fdg .Rows (){if _bdcdg ._dcaa .RAttr !=nil &&*_bdcdg ._dcaa .RAttr >=_cga {*_bdcdg ._dcaa .RAttr ++;for _ ,_aefg :=range _bdcdg .Cells (){_bgb ,_ddgc :=_cgebb .ParseCellReference (_aefg .Reference ());if _ddgc !=nil {continue ;};_bgb .RowIdx ++;_aefg ._ecbe .RAttr =_fcgc .String (_bgb .String ());};};};for _ ,_bab :=range _fdg .MergedCells (){_gfad ,_bded ,_fdde :=_cgebb .ParseRangeReference (_bab .Reference ());if _fdde !=nil {continue ;};if int (_gfad .RowIdx )>=rowNum {_gfad .RowIdx ++;};if int (_bded .RowIdx )>=rowNum {_bded .RowIdx ++;};_efcg :=_beba .Sprintf ("\u0025\u0073\u003a%\u0073",_gfad ,_bded );_bab .SetReference (_efcg );};return _fdg .AddNumberedRow (_cga );};

// SetHeightAuto sets the row height to be automatically determined.
func (_geaa Row )SetHeightAuto (){_geaa ._dcaa .HtAttr =nil ;_geaa ._dcaa .CustomHeightAttr =nil };

// MaxColumnIdx returns the max used column of the sheet.
func (_abe Sheet )MaxColumnIdx ()uint32 {_ddde :=uint32 (0);for _ ,_faag :=range _abe .Rows (){_eacg :=_faag ._dcaa .C ;if len (_eacg )> 0{_gacc :=_eacg [len (_eacg )-1];_fddf ,_ :=_cgebb .ParseCellReference (*_gacc .RAttr );if _ddde < _fddf .ColumnIdx {_ddde =_fddf .ColumnIdx ;};};};return _ddde ;};func _fbeg (_aac string )bool {_aac =_babc .Replace (_aac ,"\u0024","",-1);if _ge :=_geca .FindStringSubmatch (_babc .ToLower (_aac ));len (_ge )> 2{_abgg :=_ge [1];_cdgb ,_bfbb :=_ggfd .Atoi (_ge [2]);if _bfbb !=nil {return false ;};return _cdgb <=1048576&&_abgg <="\u007a\u007a";};return false ;};

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_eaeb *Sheet )FormulaContext ()_acdfa .Context {return _agc (_eaeb )};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_cbbc *_efed .CT_SheetView };

// X returns the inner wrapped XML type.
func (_bcae Comment )X ()*_efed .CT_Comment {return _bcae ._gcd };func (_gad *Sheet )removeColumnFromNamedRanges (_bbeg uint32 )error {for _ ,_gfef :=range _gad ._bdgb .DefinedNames (){_fcab :=_gfef .Name ();_fddb :=_gfef .Content ();_cgbgf :=_babc .Split (_fddb ,"\u0021");if len (_cgbgf )!=2{return _edc .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_fddb );};_fdbf :=_cgbgf [0];if _gad .Name ()==_fdbf {_fcfd :=_gad ._bdgb .RemoveDefinedName (_gfef );if _fcfd !=nil {return _fcfd ;};_aeea :=_bad (_cgbgf [1],_bbeg ,true );if _aeea !=""{_dafc :=_fdbf +"\u0021"+_aeea ;_gad ._bdgb .AddDefinedName (_fcab ,_dafc );};};};_fabb :=0;if _gad ._ed .TableParts !=nil &&_gad ._ed .TableParts .TablePart !=nil {_fabb =len (_gad ._ed .TableParts .TablePart );};if _fabb !=0{_beeg :=0;for _ ,_fe :=range _gad ._bdgb .Sheets (){if _fe .Name ()==_gad .Name (){break ;}else {if _fe ._ed .TableParts !=nil &&_fe ._ed .TableParts .TablePart !=nil {_beeg +=len (_fe ._ed .TableParts .TablePart );};};};_dfc :=_gad ._bdgb ._cefb [_beeg :_beeg +_fabb ];for _beab ,_ebg :=range _dfc {_baeg :=_ebg ;_baeg .RefAttr =_bad (_baeg .RefAttr ,_bbeg ,false );_gad ._bdgb ._cefb [_beeg +_beab ]=_baeg ;};};return nil ;};

// Type returns the type of anchor
func (_gfba TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_ggde *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _ggde .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _aacc _gfdb .Relationship ;for _ ,_gba :=range _ggde ._fgga .Relationships (){if _gba .ID ()==_ggde ._fbc .Sheets .Sheet [ind ].IdAttr {var _ecec bool ;if _aacc ,_ecec =_ggde ._fgga .CopyRelationship (_gba .ID ());!_ecec {return Sheet {},ErrorNotFound ;};break ;};};_ggde .ContentTypes .CopyOverride (_fcgc .AbsoluteFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .WorksheetContentType ,ind +1),_fcgc .AbsoluteFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .WorksheetContentType ,len (_ggde .ContentTypes .X ().Override )));_bbde :=*_ggde ._cbef [ind ];_ggde ._cbef =append (_ggde ._cbef ,&_bbde );var _aeff uint32 =0;for _ ,_gbcd :=range _ggde ._fbc .Sheets .Sheet {if _gbcd .SheetIdAttr > _aeff {_aeff =_gbcd .SheetIdAttr ;};};_aeff ++;_fb :=*_ggde ._fbc .Sheets .Sheet [ind ];_fb .IdAttr =_aacc .ID ();_fb .NameAttr =copiedSheetName ;_fb .SheetIdAttr =_aeff ;_ggde ._fbc .Sheets .Sheet =append (_ggde ._fbc .Sheets .Sheet ,&_fb );_abfc :=_gfdb .NewRelationshipsCopy (_ggde ._adec [ind ]);_ggde ._adec =append (_ggde ._adec ,_abfc );_ffd :=_ggde ._fbea [ind ];if _ffd ==nil {_ggde ._fbea =append (_ggde ._fbea ,nil );}else {_cfed :=*_ffd ;_ggde ._fbea =append (_ggde ._fbea ,&_cfed );};_f :=Sheet {_ggde ,&_fb ,&_bbde };return _f ,nil ;};

// Row is a row within a spreadsheet.
type Row struct{_gcbf *Workbook ;_bcdf *Sheet ;_dcaa *_efed .CT_Row ;};

// RemoveSheet removes the sheet with the given index from the workbook.
func (_dded *Workbook )RemoveSheet (ind int )error {if _dded .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_fda :=range _dded ._fgga .Relationships (){if _fda .ID ()==_dded ._fbc .Sheets .Sheet [ind ].IdAttr {_dded ._fgga .Remove (_fda );break ;};};_dded .ContentTypes .RemoveOverride (_fcgc .AbsoluteFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .WorksheetContentType ,ind +1));copy (_dded ._cbef [ind :],_dded ._cbef [ind +1:]);_dded ._cbef =_dded ._cbef [:len (_dded ._cbef )-1];_cabd :=_dded ._fbc .Sheets .Sheet [ind ];copy (_dded ._fbc .Sheets .Sheet [ind :],_dded ._fbc .Sheets .Sheet [ind +1:]);_dded ._fbc .Sheets .Sheet =_dded ._fbc .Sheets .Sheet [:len (_dded ._fbc .Sheets .Sheet )-1];for _eefga :=range _dded ._fbc .Sheets .Sheet {if _dded ._fbc .Sheets .Sheet [_eefga ].SheetIdAttr > _cabd .SheetIdAttr {_dded ._fbc .Sheets .Sheet [_eefga ].SheetIdAttr --;};};copy (_dded ._adec [ind :],_dded ._adec [ind +1:]);_dded ._adec =_dded ._adec [:len (_dded ._adec )-1];copy (_dded ._fbea [ind :],_dded ._fbea [ind +1:]);_dded ._fbea =_dded ._fbea [:len (_dded ._fbea )-1];return nil ;};

// AddFormatValue adds a format value to be used to determine the cell background.
func (_eeg ColorScale )AddFormatValue (t _efed .ST_CfvoType ,val string ){_beacc :=_efed .NewCT_Cfvo ();_beacc .TypeAttr =t ;_beacc .ValAttr =_fcgc .String (val );_eeg ._gabec .Cfvo =append (_eeg ._gabec .Cfvo ,_beacc );};

// GetFilename returns the filename of the context's workbook.
func (_bgga *evalContext )GetFilename ()string {return _bgga ._eee ._bdgb .GetFilename ()};

// SetFont applies a font to a cell style.  The font is referenced by its
// index so modifying the font afterward will affect all styles that reference
// it.
func (_aa CellStyle )SetFont (f Font ){_aa ._ddbb .FontIdAttr =_fcgc .Uint32 (f .Index ());_aa ._ddbb .ApplyFontAttr =_fcgc .Bool (true );};

// SetHidden controls the visibility of a column.
func (_dcd Column )SetHidden (b bool ){if !b {_dcd ._de .HiddenAttr =nil ;}else {_dcd ._de .HiddenAttr =_fcgc .Bool (true );};};

// SetHidden marks the defined name as hidden.
func (_ff DefinedName )SetLocalSheetID (id uint32 ){_ff ._edda .LocalSheetIdAttr =_fcgc .Uint32 (id )};

// MoveTo moves the top-left of the anchored object.
func (_fbbg OneCellAnchor )MoveTo (col ,row int32 ){_fbbg .TopLeft ().SetCol (col );_fbbg .TopLeft ().SetRow (row );};func (_fbd Border )SetDiagonal (style _efed .ST_BorderStyle ,c _gbda .Color ,up ,down bool ){if _fbd ._gafc .Diagonal ==nil {_fbd ._gafc .Diagonal =_efed .NewCT_BorderPr ();};_fbd ._gafc .Diagonal .Color =_efed .NewCT_Color ();_fbd ._gafc .Diagonal .Color .RgbAttr =c .AsRGBAString ();_fbd ._gafc .Diagonal .StyleAttr =style ;if up {_fbd ._gafc .DiagonalUpAttr =_fcgc .Bool (true );};if down {_fbd ._gafc .DiagonalDownAttr =_fcgc .Bool (true );};};

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_aeg Comments )AddComment (cellRef string ,author string )RichText {_dbafg :=_efed .NewCT_Comment ();_aeg ._gcdc .CommentList .Comment =append (_aeg ._gcdc .CommentList .Comment ,_dbafg );_dbafg .RefAttr =cellRef ;_dbafg .AuthorIdAttr =_aeg .getOrCreateAuthor (author );_dbafg .Text =_efed .NewCT_Rst ();return RichText {_dbafg .Text };};

// Type returns the type of anchor
func (_ddga OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// IsEmpty returns true if the cell is empty.
func (_be Cell )IsEmpty ()bool {return _be ._ecbe .TAttr ==_efed .ST_CellTypeUnset &&_be ._ecbe .V ==nil &&_be ._ecbe .F ==nil ;};

// Type returns the type of the rule
func (_fec ConditionalFormattingRule )Type ()_efed .ST_CfType {return _fec ._defb .TypeAttr };

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_fa Cell )SetFormulaShared (formula string ,rows ,cols uint32 )error {_fa .clearValue ();_fa ._ecbe .TAttr =_efed .ST_CellTypeStr ;_fa ._ecbe .F =_efed .NewCT_CellFormula ();_fa ._ecbe .F .TAttr =_efed .ST_CellFormulaTypeShared ;_fa ._ecbe .F .Content =formula ;_gbeg ,_acf :=_cgebb .ParseCellReference (_fa .Reference ());if _acf !=nil {return _acf ;};_fbfc :=uint32 (0);for _ ,_bbda :=range _fa ._dbgd .Rows (){for _ ,_add :=range _bbda ._dcaa .C {if _add .F !=nil &&_add .F .SiAttr !=nil &&*_add .F .SiAttr >=_fbfc {_fbfc =*_add .F .SiAttr ;};};};_fbfc ++;_ccb :=_beba .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_gbeg .Column ,_gbeg .RowIdx ,_cgebb .IndexToColumn (_gbeg .ColumnIdx +cols ),_gbeg .RowIdx +rows );_fa ._ecbe .F .RefAttr =_fcgc .String (_ccb );_fa ._ecbe .F .SiAttr =_fcgc .Uint32 (_fbfc );_acec :=Sheet {_fa ._dcbg ,_fa ._dbgd ._ccfb ,_fa ._dbgd ._ed };for _dcbe :=_gbeg .RowIdx ;_dcbe <=_gbeg .RowIdx +rows ;_dcbe ++{for _badg :=_gbeg .ColumnIdx ;_badg <=_gbeg .ColumnIdx +cols ;_badg ++{if _dcbe ==_gbeg .RowIdx &&_badg ==_gbeg .ColumnIdx {continue ;};_abfcg :=_beba .Sprintf ("\u0025\u0073\u0025\u0064",_cgebb .IndexToColumn (_badg ),_dcbe );_acec .Cell (_abfcg ).Clear ();_acec .Cell (_abfcg ).X ().F =_efed .NewCT_CellFormula ();_acec .Cell (_abfcg ).X ().F .TAttr =_efed .ST_CellFormulaTypeShared ;_acec .Cell (_abfcg ).X ().F .SiAttr =_fcgc .Uint32 (_fbfc );};};return nil ;};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_fdf *Workbook )ClearCachedFormulaResults (){for _ ,_gac :=range _fdf .Sheets (){_gac .ClearCachedFormulaResults ();};};

// AddSheet adds a new sheet to a workbook.
func (_dfaa *Workbook )AddSheet ()Sheet {_aebbb :=_efed .NewCT_Sheet ();_aebbb .SheetIdAttr =1;for _ ,_gbea :=range _dfaa ._fbc .Sheets .Sheet {if _aebbb .SheetIdAttr <=_gbea .SheetIdAttr {_aebbb .SheetIdAttr =_gbea .SheetIdAttr +1;};};_dfaa ._fbc .Sheets .Sheet =append (_dfaa ._fbc .Sheets .Sheet ,_aebbb );_aebbb .NameAttr =_beba .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_aebbb .SheetIdAttr );_dccd :=_efed .NewWorksheet ();_dccd .Dimension =_efed .NewCT_SheetDimension ();_dccd .Dimension .RefAttr ="\u0041\u0031";_dfaa ._cbef =append (_dfaa ._cbef ,_dccd );_gd :=_gfdb .NewRelationships ();_dfaa ._adec =append (_dfaa ._adec ,_gd );_dccd .SheetData =_efed .NewCT_SheetData ();_dfaa ._fbea =append (_dfaa ._fbea ,nil );_ccf :=_fcgc .DocTypeSpreadsheet ;_gadab :=_dfaa ._fgga .AddAutoRelationship (_ccf ,_fcgc .OfficeDocumentType ,len (_dfaa ._fbc .Sheets .Sheet ),_fcgc .WorksheetType );_aebbb .IdAttr =_gadab .ID ();_dfaa .ContentTypes .AddOverride (_fcgc .AbsoluteFilename (_ccf ,_fcgc .WorksheetContentType ,len (_dfaa ._fbc .Sheets .Sheet )),_fcgc .WorksheetContentType );return Sheet {_dfaa ,_aebbb ,_dccd };};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As gooxml formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_ddd *Workbook )RecalculateFormulas (){for _ ,_bcf :=range _ddd .Sheets (){_bcf .RecalculateFormulas ();};};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_feba *_efed .CT_DataBar };

// Column returns the cell column
func (_dge Cell )Column ()(string ,error ){_dffb ,_gcdf :=_cgebb .ParseCellReference (_dge .Reference ());if _gcdf !=nil {return "",_gcdf ;};return _dffb .Column ,nil ;};

// PasswordHash returns the hash of the workbook password.
func (_ebbc WorkbookProtection )PasswordHash ()string {if _ebbc ._cagc .WorkbookPasswordAttr ==nil {return "";};return *_ebbc ._cagc .WorkbookPasswordAttr ;};func (_edbcg DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_edbcg .clear ();_edbcg ._bdbe .TypeAttr =_efed .ST_DataValidationType (t );_edbcg ._bdbe .OperatorAttr =_efed .ST_DataValidationOperator (op );return DataValidationCompare {_edbcg ._bdbe };};

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_fbce *Workbook )Uses1904Dates ()bool {if _fbce ._fbc .WorkbookPr ==nil ||_fbce ._fbc .WorkbookPr .Date1904Attr ==nil {return false ;};return *_fbce ._fbc .WorkbookPr .Date1904Attr ;};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_ecc *Sheet )SheetViews ()[]SheetView {if _ecc ._ed .SheetViews ==nil {return nil ;};_bebb :=[]SheetView {};for _ ,_bdag :=range _ecc ._ed .SheetViews .SheetView {_bebb =append (_bebb ,SheetView {_bdag });};return _bebb ;};

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_adce *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_fbfg :=_adce ._ed .SheetData .Row ;_cgf :=_adce .Rows ();for _ccab ,_gfadb :=range _cgf {if _gfadb .RowNumber ()==firstRow {_fbfg =_adce ._ed .SheetData .Row [_ccab :];break ;};};_cddca :=Comparer {Order :order };_efac .Slice (_fbfg ,func (_cfbe ,_fag int )bool {return _cddca .LessRows (column ,Row {_adce ._bdgb ,_adce ,_fbfg [_cfbe ]},Row {_adce ._bdgb ,_adce ,_fbfg [_fag ]});});for _cdee ,_dbbcb :=range _adce .Rows (){_gbag :=uint32 (_cdee +1);if _dbbcb .RowNumber ()!=_gbag {_dbbcb .renumberAs (_gbag );};};};

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_agg *Sheet )AddNumberedRow (rowNum uint32 )Row {_bdd :=_efed .NewCT_Row ();_bdd .RAttr =_fcgc .Uint32 (rowNum );_agg ._ed .SheetData .Row =append (_agg ._ed .SheetData .Row ,_bdd );_efac .Slice (_agg ._ed .SheetData .Row ,func (_ecfc ,_ceeca int )bool {_fced :=_agg ._ed .SheetData .Row [_ecfc ].RAttr ;_gaba :=_agg ._ed .SheetData .Row [_ceeca ].RAttr ;if _fced ==nil {return true ;};if _gaba ==nil {return true ;};return *_fced < *_gaba ;});return Row {_agg ._bdgb ,_agg ,_bdd };};

// X returns the inner wrapped XML type.
func (_cfeeb SheetView )X ()*_efed .CT_SheetView {return _cfeeb ._cbbc };func (_fded *evalContext )Cell (ref string ,ev _acdfa .Evaluator )_acdfa .Result {if !_fbeg (ref ){return _acdfa .MakeErrorResultType (_acdfa .ErrorTypeName ,"");};_dbdc :=_fded ._eee .Name ()+"\u0021"+ref ;if _ddbff ,_df :=ev .GetFromCache (_dbdc );_df {return _ddbff ;};_bdegg ,_ebcg :=_cgebb .ParseCellReference (ref );if _ebcg !=nil {return _acdfa .MakeErrorResult (_beba .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_ebcg ));};if _fded ._bf !=0&&!_bdegg .AbsoluteColumn {_bdegg .ColumnIdx +=_fded ._bf ;_bdegg .Column =_cgebb .IndexToColumn (_bdegg .ColumnIdx );};if _fded ._cde !=0&&!_bdegg .AbsoluteRow {_bdegg .RowIdx +=_fded ._cde ;};_gcb :=_fded ._eee .Cell (_bdegg .String ());if _gcb .HasFormula (){if _ ,_gag :=_fded ._dbda [ref ];_gag {return _acdfa .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );};_fded ._dbda [ref ]=struct{}{};_cddd :=ev .Eval (_fded ,_gcb .GetFormula ());delete (_fded ._dbda ,ref );ev .SetCache (_dbdc ,_cddd );return _cddd ;};if _gcb .IsEmpty (){_ecbc :=_acdfa .MakeEmptyResult ();ev .SetCache (_dbdc ,_ecbc );return _ecbc ;}else if _gcb .IsNumber (){_gbec ,_ :=_gcb .GetValueAsNumber ();_bfc :=_acdfa .MakeNumberResult (_gbec );ev .SetCache (_dbdc ,_bfc );return _bfc ;}else if _gcb .IsBool (){_gccgd ,_ :=_gcb .GetValueAsBool ();_gddca :=_acdfa .MakeBoolResult (_gccgd );ev .SetCache (_dbdc ,_gddca );return _gddca ;};_efcac ,_ :=_gcb .GetRawValue ();if _gcb .IsError (){_gga :=_acdfa .MakeErrorResult ("");_gga .ValueString =_efcac ;ev .SetCache (_dbdc ,_gga );return _gga ;};_ccfd :=_acdfa .MakeStringResult (_efcac );ev .SetCache (_dbdc ,_ccfd );return _ccfd ;};

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_cfcae IconScale )AddFormatValue (t _efed .ST_CfvoType ,val string ){_fgb :=_efed .NewCT_Cfvo ();_fgb .TypeAttr =t ;_fgb .ValAttr =_fcgc .String (val );_cfcae ._dba .Cfvo =append (_cfcae ._dba .Cfvo ,_fgb );};

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_fgdd Cell )SetFormulaRaw (s string ){_fgdd .clearValue ();_fgdd ._ecbe .TAttr =_efed .ST_CellTypeStr ;_fgdd ._ecbe .F =_efed .NewCT_CellFormula ();_fgdd ._ecbe .F .Content =s ;};

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _afdf .ReaderAt ,size int64 )(*Workbook ,error ){_gfee :=New ();_cdg ,_gdgc :=_gfbac .TempDir ("","g\u006f\u006f\u0078\u006d\u006c\u002d\u0078\u006c\u0073\u0078");if _gdgc !=nil {return nil ,_gdgc ;};_gfee .TmpPath =_cdg ;_eacd ,_gdgc :=_fccde .NewReader (r ,size );if _gdgc !=nil {return nil ,_beba .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_gdgc );};_abge :=[]*_fccde .File {};_abge =append (_abge ,_eacd .File ...);_gfga :=_fgc .DecodeMap {};_gfga .SetOnNewRelationshipFunc (_gfee .onNewRelationship );_gfga .AddTarget (_fcgc .ContentTypesFilename ,_gfee .ContentTypes .X (),"",0);_gfga .AddTarget (_fcgc .BaseRelsFilename ,_gfee .Rels .X (),"",0);if _cgdb :=_gfga .Decode (_abge );_cgdb !=nil {return nil ,_cgdb ;};for _ ,_gge :=range _abge {if _gge ==nil {continue ;};if _aagce :=_gfee .AddExtraFileFromZip (_gge );_aagce !=nil {return nil ,_aagce ;};};return _gfee ,nil ;};

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_fef Cell )SetStyleIndex (idx uint32 ){_fef ._ecbe .SAttr =_fcgc .Uint32 (idx )};func (_bfd Border )SetRight (style _efed .ST_BorderStyle ,c _gbda .Color ){if _bfd ._gafc .Right ==nil {_bfd ._gafc .Right =_efed .NewCT_BorderPr ();};_bfd ._gafc .Right .Color =_efed .NewCT_Color ();_bfd ._gafc .Right .Color .RgbAttr =c .AsRGBAString ();_bfd ._gafc .Right .StyleAttr =style ;};

// SortOrder is a column sort order.
//go:generate stringer -type=SortOrder
type SortOrder byte ;

// SetWidthCells is a no-op.
func (_gdc AbsoluteAnchor )SetWidthCells (int32 ){};

// IsSheetLocked returns whether the sheet objects are locked.
func (_ggda SheetProtection )IsObjectLocked ()bool {return _ggda ._dgdf .ObjectsAttr !=nil &&*_ggda ._dgdf .ObjectsAttr ;};

// TopLeft is a no-op.
func (_gddcb AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_bde *Workbook )GetFilename ()string {return _bde ._gdgg };

// GetFormat sets the number format code.
func (_gead NumberFormat )GetFormat ()string {return _gead ._ceea .FormatCodeAttr };

// IconScale maps values to icons.
type IconScale struct{_dba *_efed .CT_IconSet };

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_afa *Sheet )Column (idx uint32 )Column {for _ ,_fafb :=range _afa ._ed .Cols {for _ ,_gcdd :=range _fafb .Col {if idx >=_gcdd .MinAttr &&idx <=_gcdd .MaxAttr {return Column {_gcdd };};};};var _abff *_efed .CT_Cols ;if len (_afa ._ed .Cols )==0{_abff =_efed .NewCT_Cols ();_afa ._ed .Cols =append (_afa ._ed .Cols ,_abff );}else {_abff =_afa ._ed .Cols [0];};_ffde :=_efed .NewCT_Col ();_ffde .MinAttr =idx ;_ffde .MaxAttr =idx ;_abff .Col =append (_abff .Col ,_ffde );return Column {_ffde };};func _bad (_aga string ,_fgd uint32 ,_efea bool )string {_eedbg ,_aace ,_daeg :=_cgebb .ParseRangeReference (_aga );if _daeg ==nil {_cfc ,_bggd :=_eedbg .ColumnIdx ,_aace .ColumnIdx ;if _fgd >=_cfc &&_fgd <=_bggd {if _cfc ==_bggd {if _efea {return "";}else {return _aga ;};}else {_defdg :=_aace .Update (_caa .UpdateActionRemoveColumn );return _beba .Sprintf ("\u0025\u0073\u003a%\u0073",_eedbg .String (),_defdg .String ());};}else if _fgd < _cfc {_cbdg :=_eedbg .Update (_caa .UpdateActionRemoveColumn );_ggg :=_aace .Update (_caa .UpdateActionRemoveColumn );return _beba .Sprintf ("\u0025\u0073\u003a%\u0073",_cbdg .String (),_ggg .String ());};}else {_bbffb ,_ecbg ,_aef :=_cgebb .ParseColumnRangeReference (_aga );if _aef !=nil {return "";};_dcc ,_cf :=_bbffb .ColumnIdx ,_ecbg .ColumnIdx ;if _fgd >=_dcc &&_fgd <=_cf {if _dcc ==_cf {if _efea {return "";}else {return _aga ;};}else {_cgd :=_ecbg .Update (_caa .UpdateActionRemoveColumn );return _beba .Sprintf ("\u0025\u0073\u003a%\u0073",_bbffb .String (),_cgd .String ());};}else if _fgd < _dcc {_decb :=_bbffb .Update (_caa .UpdateActionRemoveColumn );_edf :=_ecbg .Update (_caa .UpdateActionRemoveColumn );return _beba .Sprintf ("\u0025\u0073\u003a%\u0073",_decb .String (),_edf .String ());};};return "";};func _cec (_dabe _dfga .Time )_dfga .Time {_dabe =_dabe .Local ();return _dfga .Date (_dabe .Year (),_dabe .Month (),_dabe .Day (),_dabe .Hour (),_dabe .Minute (),_dabe .Second (),_dabe .Nanosecond (),_dfga .UTC );};

// SetRotation configures the cell to be rotated.
func (_ecd CellStyle )SetRotation (deg uint8 ){if _ecd ._ddbb .Alignment ==nil {_ecd ._ddbb .Alignment =_efed .NewCT_CellAlignment ();};_ecd ._ddbb .ApplyAlignmentAttr =_fcgc .Bool (true );_ecd ._ddbb .Alignment .TextRotationAttr =_fcgc .Uint8 (deg );};

// SetPassword sets the password hash to a hash of the input password.
func (_gbf SheetProtection )SetPassword (pw string ){_gbf .SetPasswordHash (PasswordHash (pw ))};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_aeda SheetView )SetZoom (pct uint32 ){_aeda ._cbbc .ZoomScaleAttr =&pct };

// SetInlineString adds a string inline instead of in the shared strings table.
func (_aaba Cell )SetInlineString (s string ){_aaba .clearValue ();_aaba ._ecbe .Is =_efed .NewCT_Rst ();_aaba ._ecbe .Is .T =_fcgc .String (s );_aaba ._ecbe .TAttr =_efed .ST_CellTypeInlineStr ;};

// Comment is a single comment within a sheet.
type Comment struct{_gfeb *Workbook ;_gcd *_efed .CT_Comment ;_egg *_efed .Comments ;};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_bfbe Cell )SetDate (d _dfga .Time ){_bfbe .clearValue ();d =_cec (d );_gfbe :=_bfbe ._dcbg .Epoch ();if d .Before (_gfbe ){_fcgc .Log ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_acdf :=d .Sub (_gfbe );_ebb :=new (_dfb .Float );_gb :=new (_dfb .Float );_gb .SetPrec (128);_gb .SetUint64 (uint64 (_acdf ));_ceec :=new (_dfb .Float );_ceec .SetUint64 (24*60*60*1e9);_ebb .Quo (_gb ,_ceec );_gabbbf ,_ :=_ebb .Uint64 ();_bfbe ._ecbe .V =_fcgc .Stringf ("\u0025\u0064",_gabbbf );};

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_fcc *_efed .Sst ;_gfac map[string ]int ;};func (_dbgbg Font )Index ()uint32 {for _ccdb ,_cecd :=range _dbgbg ._acefe .Fonts .Font {if _dbgbg ._gca ==_cecd {return uint32 (_ccdb );};};return 0;};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_bfe Sheet )ValidateWithPath (path string )error {return _bfe ._ed .ValidateWithPath (path )};

// ColOffset returns the offset from the row cell.
func (_ad CellMarker )ColOffset ()_aag .Distance {if _ad ._bbd .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _aag .Distance (float64 (*_ad ._bbd .ColOff .ST_CoordinateUnqualified )*_aag .EMU );};func (_aeed *evalContext )SetOffset (col ,row uint32 ){_aeed ._bf =col ;_aeed ._cde =row };

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_dffd DataValidation )SetRange (cellRange string ){_dffd ._bdbe .SqrefAttr =_efed .ST_Sqref {cellRange };};func (_egaf Cell )GetRawValue ()(string ,error ){switch _egaf ._ecbe .TAttr {case _efed .ST_CellTypeInlineStr :if _egaf ._ecbe .Is ==nil ||_egaf ._ecbe .Is .T ==nil {return "",nil ;};return *_egaf ._ecbe .Is .T ,nil ;case _efed .ST_CellTypeS :if _egaf ._ecbe .V ==nil {return "",nil ;};_abdg ,_ace :=_ggfd .Atoi (*_egaf ._ecbe .V );if _ace !=nil {return "",_ace ;};return _egaf ._dcbg .SharedStrings .GetString (_abdg );case _efed .ST_CellTypeStr :if _egaf ._ecbe .F !=nil {return _egaf ._ecbe .F .Content ,nil ;};};if _egaf ._ecbe .V ==nil {return "",nil ;};return *_egaf ._ecbe .V ,nil ;};

// SetColOffset sets the column offset of the top-left anchor.
func (_efe OneCellAnchor )SetColOffset (m _aag .Distance ){_efe .TopLeft ().SetColOffset (m )};

// ClearBorder clears any border configuration from the cell style.
func (_dede CellStyle )ClearBorder (){_dede ._ddbb .BorderIdAttr =nil ;_dede ._ddbb .ApplyBorderAttr =nil ;};func (_fab Cell )getLabelPrefix ()string {if _fab ._ecbe .SAttr ==nil {return "";};_fgae :=*_fab ._ecbe .SAttr ;_afdc :=_fab ._dcbg .StyleSheet .GetCellStyle (_fgae );switch _afdc ._ddbb .Alignment .HorizontalAttr {case _efed .ST_HorizontalAlignmentLeft :return "\u0027";case _efed .ST_HorizontalAlignmentRight :return "\u0022";case _efed .ST_HorizontalAlignmentCenter :return "\u005e";case _efed .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;type MergedCell struct{_gdf *Workbook ;_ecca *Sheet ;_ebc *_efed .CT_MergeCell ;};

// Border is a cell border configuraton.
type Border struct{_gafc *_efed .CT_Border ;_efaa *_efed .CT_Borders ;};

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_fafe TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_fafe ._aceb .To }};

// AddHyperlink creates and sets a hyperlink on a cell.
func (_gbcc Cell )AddHyperlink (url string ){for _fbec ,_dcb :=range _gbcc ._dcbg ._cbef {if _dcb ==_gbcc ._dbgd ._ed {_gbcc .SetHyperlink (_gbcc ._dcbg ._adec [_fbec ].AddHyperlink (url ));return ;};};};

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_fdb Drawing )AddChart (at AnchorType )(_bfde .Chart ,Anchor ){_dcbc :=_aegbf .NewChartSpace ();_fdb ._aacf ._aeef =append (_fdb ._aacf ._aeef ,_dcbc );_ecb :=_fcgc .AbsoluteFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .ChartContentType ,len (_fdb ._aacf ._aeef ));_fdb ._aacf .ContentTypes .AddOverride (_ecb ,_fcgc .ChartContentType );var _caga string ;for _gfc ,_cdef :=range _fdb ._aacf ._gde {if _cdef ==_fdb ._gccd {_fede :=_fcgc .RelativeFilename (_fcgc .DocTypeSpreadsheet ,_fcgc .DrawingType ,_fcgc .ChartType ,len (_fdb ._aacf ._aeef ));_ebec :=_fdb ._aacf ._fee [_gfc ].AddRelationship (_fede ,_fcgc .ChartType );_caga =_ebec .ID ();break ;};};var _cd Anchor ;var _ege *_gcge .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_gfdbf :=_gbad ();_fdb ._gccd .EG_Anchor =append (_fdb ._gccd .EG_Anchor ,&_gcge .EG_Anchor {AbsoluteAnchor :_gfdbf });_gfdbf .Choice =&_gcge .EG_ObjectChoicesChoice {};_gfdbf .Choice .GraphicFrame =_gcge .NewCT_GraphicalObjectFrame ();_ege =_gfdbf .Choice .GraphicFrame ;_cd =AbsoluteAnchor {_gfdbf };case AnchorTypeOneCell :_ega :=_gade ();_fdb ._gccd .EG_Anchor =append (_fdb ._gccd .EG_Anchor ,&_gcge .EG_Anchor {OneCellAnchor :_ega });_ega .Choice =&_gcge .EG_ObjectChoicesChoice {};_ega .Choice .GraphicFrame =_gcge .NewCT_GraphicalObjectFrame ();_ege =_ega .Choice .GraphicFrame ;_cd =OneCellAnchor {_ega };case AnchorTypeTwoCell :_ffb :=_cbc ();_fdb ._gccd .EG_Anchor =append (_fdb ._gccd .EG_Anchor ,&_gcge .EG_Anchor {TwoCellAnchor :_ffb });_ffb .Choice =&_gcge .EG_ObjectChoicesChoice {};_ffb .Choice .GraphicFrame =_gcge .NewCT_GraphicalObjectFrame ();_ege =_ffb .Choice .GraphicFrame ;_cd =TwoCellAnchor {_ffb };};_ege .NvGraphicFramePr =_gcge .NewCT_GraphicalObjectFrameNonVisual ();_ege .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_fdb ._gccd .EG_Anchor ));_ege .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_ege .Graphic =_eada .NewGraphic ();_ege .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";_ccgcb :=_aegbf .NewChart ();_ccgcb .IdAttr =_caga ;_ege .Graphic .GraphicData .Any =[]_fcgc .Any {_ccgcb };_bda :=_bfde .MakeChart (_dcbc );_bda .Properties ().SetSolidFill (_gbda .White );_bda .SetDisplayBlanksAs (_aegbf .ST_DispBlanksAsGap );return _bda ,_cd ;};

// SetShowValue controls if the cell value is displayed.
func (_dbg DataBarScale )SetShowValue (b bool ){_dbg ._feba .ShowValueAttr =_fcgc .Bool (b )};

// SetWidth controls the width of a column.
func (_fffgb Column )SetWidth (w _aag .Distance ){_fffgb ._de .WidthAttr =_fcgc .Float64 (float64 (w /_aag .Character ));};

// SetContent sets the defined name content.
func (_fcb DefinedName )SetContent (s string ){_fcb ._edda .Content =s };

// SetDateWithStyle sets a date with the default date style applied.
func (_ecda Cell )SetDateWithStyle (d _dfga .Time ){_ecda .SetDate (d );for _ ,_aca :=range _ecda ._dcbg .StyleSheet .CellStyles (){if _aca .HasNumberFormat ()&&_aca .NumberFormat ()==uint32 (StandardFormatDate ){_ecda .SetStyle (_aca );return ;};};_fggb :=_ecda ._dcbg .StyleSheet .AddCellStyle ();_fggb .SetNumberFormatStandard (StandardFormatDate );_ecda .SetStyle (_fggb );};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_gadb CellStyle )NumberFormat ()uint32 {if _gadb ._ddbb .NumFmtIdAttr ==nil {return 0;};return *_gadb ._ddbb .NumFmtIdAttr ;};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_dgb *Workbook )SetActiveSheetIndex (idx uint32 ){if _dgb ._fbc .BookViews ==nil {_dgb ._fbc .BookViews =_efed .NewCT_BookViews ();};if len (_dgb ._fbc .BookViews .WorkbookView )==0{_dgb ._fbc .BookViews .WorkbookView =append (_dgb ._fbc .BookViews .WorkbookView ,_efed .NewCT_BookView ());};_dgb ._fbc .BookViews .WorkbookView [0].ActiveTabAttr =_fcgc .Uint32 (idx );};

// ClearProtection removes any protections applied to teh sheet.
func (_cddc *Sheet )ClearProtection (){_cddc ._ed .SheetProtection =nil };

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_bdf CellStyle )SetVerticalAlignment (a _efed .ST_VerticalAlignment ){if _bdf ._ddbb .Alignment ==nil {_bdf ._ddbb .Alignment =_efed .NewCT_CellAlignment ();};_bdf ._ddbb .ApplyAlignmentAttr =_fcgc .Bool (true );_bdf ._ddbb .Alignment .VerticalAttr =a ;};const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;);

// IsError returns true if the cell is an error type cell.
func (_feeg Cell )IsError ()bool {return _feeg ._ecbe .TAttr ==_efed .ST_CellTypeE };

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_aacf *Workbook ;_gccd *_gcge .WsDr ;};

// SetHyperlink sets a hyperlink on a cell.
func (_eebf Cell )SetHyperlink (hl _gfdb .Hyperlink ){_fff :=_eebf ._dbgd ._ed ;if _fff .Hyperlinks ==nil {_fff .Hyperlinks =_efed .NewCT_Hyperlinks ();};_afdd :=_gfdb .Relationship (hl );_bee :=_efed .NewCT_Hyperlink ();_bee .RefAttr =_eebf .Reference ();_bee .IdAttr =_fcgc .String (_afdd .ID ());_fff .Hyperlinks .Hyperlink =append (_fff .Hyperlinks .Hyperlink ,_bee );};

// IsWindowLocked returns whether the workbook windows are locked.
func (_ddgd WorkbookProtection )IsWindowLocked ()bool {return _ddgd ._cagc .LockWindowsAttr !=nil &&*_ddgd ._cagc .LockWindowsAttr ;};func (_gea SortOrder )String ()string {if _gea >=SortOrder (len (_gfebc )-1){return _beba .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_gea );};return _dade [_gfebc [_gea ]:_gfebc [_gea +1]];};func (_ebea Cell )getFormat ()string {if _ebea ._ecbe .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_cbcd :=*_ebea ._ecbe .SAttr ;_daa :=_ebea ._dcbg .StyleSheet .GetCellStyle (_cbcd );_bef :=_ebea ._dcbg .StyleSheet .GetNumberFormat (_daa .NumberFormat ());return _bef .GetFormat ();};

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_dde *Workbook )RemoveCalcChain (){var _abbf string ;for _ ,_bggaf :=range _dde ._fgga .Relationships (){if _bggaf .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_abbf ="\u0078\u006c\u002f"+_bggaf .Target ();_dde ._fgga .Remove (_bggaf );break ;};};if _abbf ==""{return ;};_dde .ContentTypes .RemoveOverride (_abbf );for _gce ,_gbaa :=range _dde .ExtraFiles {if _gbaa .ZipPath ==_abbf {_dde .ExtraFiles [_gce ]=_dde .ExtraFiles [len (_dde .ExtraFiles )-1];_dde .ExtraFiles =_dde .ExtraFiles [:len (_dde .ExtraFiles )-1];return ;};};};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_agbe Sheet )Validate ()error {_bbaa :=[]func ()error {_agbe .validateRowCellNumbers ,_agbe .validateMergedCells ,_agbe .validateSheetNames };for _ ,_bccc :=range _bbaa {if _fedb :=_bccc ();_fedb !=nil {return _fedb ;};};if _bcee :=_agbe ._ed .Validate ();_bcee !=nil {return _bcee ;};return _agbe ._ed .Validate ();};var _dad =false ;

// AddCommentWithStyle adds a new comment styled in a default way
func (_deg Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_adeg :=_deg .AddComment (cellRef ,author );_fcabf :=_adeg .AddRun ();_fcabf .SetBold (true );_fcabf .SetSize (10);_fcabf .SetColor (_gbda .Black );_fcabf .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_fcabf .SetText (author +"\u003a");_fcabf =_adeg .AddRun ();_fcabf .SetSize (10);_fcabf .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_fcabf .SetColor (_gbda .Black );_fcabf .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_gfg ,_fcbdf :=_cgebb .ParseCellReference (cellRef );if _fcbdf !=nil {return _fcbdf ;};_deg ._gcfe ._bgce [0].Shape =append (_deg ._gcfe ._bgce [0].Shape ,_cdbe .NewCommentShape (int64 (_gfg .ColumnIdx ),int64 (_gfg .RowIdx -1)));return nil ;};

// X returns the inner wrapped XML type.
func (_cded CellMarker )X ()*_gcge .CT_Marker {return _cded ._bbd };const (DVOpGreater =_efed .ST_DataValidationOperatorGreaterThanOrEqual ;);const _abgbd ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";

// CellStyles returns the list of defined cell styles
func (_dfdc StyleSheet )CellStyles ()[]CellStyle {_gddg :=[]CellStyle {};for _ ,_ccdde :=range _dfdc ._deb .CellXfs .Xf {_gddg =append (_gddg ,CellStyle {_dfdc ._eacfc ,_ccdde ,_dfdc ._deb .CellXfs });};return _gddg ;};

// GetLocked returns true if the cell is locked.
func (_geae *evalContext )GetLocked (cellRef string )bool {return _geae ._eee .Cell (cellRef ).getLocked ()};

// Reference returns the region of cells that are merged.
func (_gfag MergedCell )Reference ()string {return _gfag ._ebc .RefAttr };