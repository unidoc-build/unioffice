//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_dd "encoding/hex";_a "errors";_gf "fmt";_fb "github.com/unidoc/unioffice/common/tempstorage";_d "io";_ba "io/ioutil";_f "math/rand";_g "sync";);func _ceg (_fa int )(string ,error ){_cdb :=make ([]byte ,_fa );if _ ,_gd :=_f .Read (_cdb );_gd !=nil {return "",_gd ;};return _dd .EncodeToString (_cdb ),nil ;};

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_ff *memFile )Write (p []byte )(int ,error ){_ff ._dc ._fd =append (_ff ._dc ._fd ,p ...);_ff ._dc ._ffa +=int64 (len (p ));return len (p ),nil ;};

// TempDir creates a name for a new temp directory using a pattern argument
func (_dcb *memStorage )TempDir (pattern string )(string ,error ){return _geg (pattern ),nil };

// Open returns tempstorage File object by name
func (_bg *memStorage )Open (path string )(_fb .File ,error ){_dde ,_cg :=_bg ._gg .Load (path );if !_cg {return nil ,_a .New (_gf .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));};return &memFile {_dc :_dde .(*memDataCell )},nil ;};

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_e *memFile )Read (p []byte )(int ,error ){_eb :=_e ._fe ;_eg :=_e ._dc ._ffa ;_ee :=int64 (len (p ));if _ee > _eg {_ee =_eg ;p =p [:_ee ];};if _eb >=_eg {return 0,_d .EOF ;};_c :=_eb +_ee ;if _c >=_eg {_c =_eg ;};_cc :=copy (p ,_e ._dc ._fd [_eb :_c ]);_e ._fe =_c ;return _cc ,nil ;};

// RemoveAll removes all files according to the dir argument prefix
func (_gfb *memStorage )RemoveAll (dir string )error {_gfb ._gg .Range (func (_gga ,_dg interface{})bool {_gfb ._gg .Delete (_gga );return true });return nil ;};

// Close is not applicable in this implementation
func (_bf *memFile )Close ()error {return nil };

// TempFile creates a new empty file in the storage and returns it
func (_ac *memStorage )TempFile (dir ,pattern string )(_fb .File ,error ){_de :=dir +"\u002f"+_geg (pattern );_feg :=&memDataCell {_ad :_de ,_fd :[]byte {}};_ggd :=&memFile {_dc :_feg };_ac ._gg .Store (_de ,_feg );return _ggd ,nil ;};type memDataCell struct{_ad string ;_fd []byte ;_ffa int64 ;};type memFile struct{_dc *memDataCell ;_fe int64 ;};func _geg (_da string )string {_db ,_ :=_ceg (6);return _da +_db };type memStorage struct{_gg _g .Map };

// Add reads a file from a disk and adds it to the storage
func (_egc *memStorage )Add (path string )error {_ ,_gb :=_egc ._gg .Load (path );if _gb {return nil ;};_cd ,_ge :=_ba .ReadFile (path );if _ge !=nil {return _ge ;};_egc ._gg .Store (path ,&memDataCell {_ad :path ,_fd :_cd ,_ffa :int64 (len (_cd ))});return nil ;};

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_ebd :=memStorage {_gg :_g .Map {}};_fb .SetAsStorage (&_ebd )};

// Name returns the filename of the underlying memDataCell
func (_ce *memFile )Name ()string {return _ce ._dc ._ad };