//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_bdg "archive/zip";_bba "bytes";_geg "encoding/xml";_de "fmt";_egeg "github.com/unidoc/unioffice";_fe "github.com/unidoc/unioffice/algo";_ad "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_cg "io";_efe "io/ioutil";_geag "os";_be "path";_bbc "sort";_ba "strings";_aa "time";);

// AddFileFromDisk reads a file from disk and adds it at a given path to a zip file.
func AddFileFromDisk (z *_bdg .Writer ,zipPath ,diskPath string )error {_gaa ,_dg :=z .Create (zipPath );if _dg !=nil {return _de .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_dg );};_ga ,_dg :=_geag .Open (diskPath );if _dg !=nil {return _de .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",diskPath ,_dg );};_ ,_dg =_cg .Copy (_gaa ,_ga );return _dg ;};func MarshalXMLByType (z *_bdg .Writer ,dt _egeg .DocType ,typ string ,v interface{})error {_feb :=_egeg .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_feb ,v );};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_ggb *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _ggb ._egb ==nil {_ggb ._egb =make (map[string ]Target );_ggb ._bg =make (map[*_ad .Relationships ]string );_ggb ._cce =make (map[string ]struct{});_ggb ._ee =make (map[string ]int );};_fc :=_be .Clean (filePath );if _ ,_a :=_ggb ._cce [_fc ];_a {return false ;};_ggb ._cce [_fc ]=struct{}{};_ggb ._egb [_fc ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_ff *DecodeMap )Decode (files []*_bdg .File )error {_fbc :=1;for _fbc > 0{for len (_ff ._gg )> 0{_abd :=_ff ._gg [len (_ff ._gg )-1];_ff ._gg =_ff ._gg [0:len (_ff ._gg )-1];_dbe :=_abd .Ifc .(*_ad .Relationships );for _ ,_ae :=range _dbe .Relationship {_gdc ,_ :=_ff ._bg [_dbe ];_ff ._eb (_ff ,_gdc +_ae .TargetAttr ,_ae .TypeAttr ,files ,_ae ,_abd );};};for _fd ,_bfd :=range files {if _bfd ==nil {continue ;};if _gd ,_e :=_ff ._egb [_bfd .Name ];_e {delete (_ff ._egb ,_bfd .Name );if _bef :=Decode (_bfd ,_gd .Ifc );_bef !=nil {return _bef ;};files [_fd ]=nil ;if _aaf ,_ace :=_gd .Ifc .(*_ad .Relationships );_ace {_ff ._gg =append (_ff ._gg ,_gd );_gga ,_ :=_be .Split (_be .Clean (_bfd .Name +"\u002f\u002e\u002e\u002f"));_ff ._bg [_aaf ]=_gga ;_fbc ++;};};};_fbc --;};return nil ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_ccee *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_ccee ._eb =fn };

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_bdg .Writer ,zipPath string ,data []byte )error {_dc ,_f :=z .Create (zipPath );if _f !=nil {return _de .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_f );};_ ,_f =_cg .Copy (_dc ,_bba .NewReader (data ));return _f ;};func (_g SelfClosingWriter )Write (b []byte )(int ,error ){_ggd :=0;_ac :=0;for _ag :=0;_ag < len (b )-2;_ag ++{if b [_ag ]=='>'&&b [_ag +1]=='<'&&b [_ag +2]=='/'{_ge :=[]byte {};_cd :=_ag ;for _efc :=_ag ;_efc >=0;_efc --{if b [_efc ]==' '{_cd =_efc ;}else if b [_efc ]=='<'{_ge =b [_efc +1:_cd ];break ;};};_ef :=[]byte {};for _bbgg :=_ag +3;_bbgg < len (b );_bbgg ++{if b [_bbgg ]=='>'{_ef =b [_ag +3:_bbgg ];break ;};};if !_bba .Equal (_ge ,_ef ){continue ;};_ea ,_cf :=_g .W .Write (b [_ggd :_ag ]);if _cf !=nil {return _ac +_ea ,_cf ;};_ac +=_ea ;_ ,_cf =_g .W .Write (_d );if _cf !=nil {return _ac ,_cf ;};_ac +=3;for _bf :=_ag +2;_bf < len (b )&&b [_bf ]!='>';_bf ++{_ac ++;_ggd =_bf +2;_ag =_ggd ;};};};_gb ,_eff :=_g .W .Write (b [_ggd :]);return _gb +_ac ,_eff ;};func (_dbc *DecodeMap )RecordIndex (path string ,idx int ){_dbc ._ee [path ]=idx };

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_bdg .File ,path string )(string ,error ){_fag ,_egg :=_efe .TempFile (path ,"\u007a\u007a");if _egg !=nil {return "",_egg ;};defer _fag .Close ();_gea ,_egg :=f .Open ();if _egg !=nil {return "",_egg ;};defer _gea .Close ();_ ,_egg =_cg .Copy (_fag ,_gea );if _egg !=nil {return "",_egg ;};return _fag .Name (),nil ;};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_egb map[string ]Target ;_bg map[*_ad .Relationships ]string ;_gg []Target ;_eb OnNewRelationshipFunc ;_cce map[string ]struct{};_ee map[string ]int ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _cg .Writer ;};func (_ab *DecodeMap )IndexFor (path string )int {return _ab ._ee [path ]};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_bdg .Writer ,filename string ,v interface{})error {_bd :=&_bdg .FileHeader {};_bd .Method =_bdg .Deflate ;_bd .Name =filename ;_bd .SetModTime (_aa .Now ());_gba ,_bbg :=z .CreateHeader (_bd );if _bbg !=nil {return _de .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_bbg );};_ ,_bbg =_gba .Write ([]byte (XMLHeader ));if _bbg !=nil {return _de .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_bbg );};if _bbg =_geg .NewEncoder (SelfClosingWriter {_gba }).Encode (v );_bbg !=nil {return _de .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_bbg );};_ ,_bbg =_gba .Write (_b );return _bbg ;};var _b =[]byte {'\r','\n'};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_egc :=_ba .Split (path ,"\u002f");_cc :=_ba .Join (_egc [0:len (_egc )-1],"\u002f");_ege :=_egc [len (_egc )-1];_cc +="\u002f_\u0072\u0065\u006c\u0073\u002f";_ege +="\u002e\u0072\u0065l\u0073";return _cc +_ege ;};var _d =[]byte {'/','>'};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_bdg .File ,dest interface{})error {_fcf ,_aed :=f .Open ();if _aed !=nil {return _de .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_aed );};defer _fcf .Close ();_eg :=_geg .NewDecoder (_fcf );if _cdc :=_eg .Decode (dest );_cdc !=nil {return _de .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_cdc );};if _bbe ,_bc :=dest .(*_ad .Relationships );_bc {for _fg ,_ebc :=range _bbe .Relationship {switch _ebc .TypeAttr {case _egeg .OfficeDocumentTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .OfficeDocumentType ;case _egeg .StylesTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .StylesType ;case _egeg .ThemeTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .ThemeType ;case _egeg .SettingsTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .SettingsType ;case _egeg .ImageTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .ImageType ;case _egeg .CommentsTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .CommentsType ;case _egeg .ThumbnailTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .ThumbnailType ;case _egeg .DrawingTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .DrawingType ;case _egeg .ChartTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .ChartType ;case _egeg .ExtendedPropertiesTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .ExtendedPropertiesType ;case _egeg .CustomXMLTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .CustomXMLType ;case _egeg .WorksheetTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .WorksheetType ;case _egeg .SharedStringsTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .SharedStringsType ;case _egeg .TableTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .TableType ;case _egeg .HeaderTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .HeaderType ;case _egeg .FooterTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .FooterType ;case _egeg .NumberingTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .NumberingType ;case _egeg .FontTableTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .FontTableType ;case _egeg .WebSettingsTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .WebSettingsType ;case _egeg .FootNotesTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .FootNotesType ;case _egeg .EndNotesTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .EndNotesType ;case _egeg .SlideTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .SlideType ;case _egeg .VMLDrawingTypeStrict :_bbe .Relationship [_fg ].TypeAttr =_egeg .VMLDrawingType ;};};_bbc .Slice (_bbe .Relationship ,func (_db ,_bgc int )bool {_fbcg :=_bbe .Relationship [_db ];_gbd :=_bbe .Relationship [_bgc ];return _fe .NaturalLess (_fbcg .IdAttr ,_gbd .IdAttr );});};return nil ;};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where gooxml will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_fbe *DecodeMap ,_bfg ,_bad string ,_abg []*_bdg .File ,_ebd *_ad .Relationship ,_bea Target )error ;type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};func MarshalXMLByTypeIndex (z *_bdg .Writer ,dt _egeg .DocType ,typ string ,idx int ,v interface{})error {_ce :=_egeg .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_ce ,v );};