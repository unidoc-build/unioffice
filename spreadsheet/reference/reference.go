//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package reference ;import (_bg "errors";_ce "fmt";_eae "github.com/unidoc/unioffice/spreadsheet/update";_ee "regexp";_eed "strconv";_be "strings";);

// ColumnToIndex maps a column to a zero based index (e.g. A = 0, B = 1, AA = 26)
func ColumnToIndex (col string )uint32 {col =_be .ToUpper (col );_ff :=uint32 (0);for _ ,_ebe :=range col {_ff *=26;_ff +=uint32 (_ebe -'A'+1);};return _ff -1;};var _fg =_ee .MustCompile ("^\u005b\u0061\u002d\u007aA-\u005a]\u0028\u005b\u0061\u002d\u007aA\u002d\u005a\u005d\u003f\u0029\u0024");

// ParseColumnReference parses a column reference of the form 'Sheet1!A' and splits it
// into sheet name and column segments.
func ParseColumnReference (s string )(ColumnReference ,error ){s =_be .TrimSpace (s );if len (s )< 1{return ColumnReference {},_bg .New ("\u0063\u006f\u006c\u0075\u006d\u006e \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065\u0020a\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0063\u0068a\u0072a\u0063\u0074\u0065\u0072");};_cbg :=ColumnReference {};_fa :=_be .Split (s ,"\u0021");if len (_fa )==2{_cbg .SheetName =_fa [0];s =_fa [1];};if s [0]=='$'{_cbg .AbsoluteColumn =true ;s =s [1:];};if !_fg .MatchString (s ){return ColumnReference {},_bg .New ("\u0063\u006f\u006c\u0075\u006dn\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0062\u0065\u0074\u0077\u0065\u0065\u006e\u0020\u0041\u0020\u0061\u006e\u0064\u0020\u005a\u005a");};_cbg .Column =s ;_cbg .ColumnIdx =ColumnToIndex (_cbg .Column );return _cbg ,nil ;};

// CellReference is a parsed reference to a cell.  Input is of the form 'A1',
// '$C$2', etc.
type CellReference struct{RowIdx uint32 ;ColumnIdx uint32 ;Column string ;AbsoluteColumn bool ;AbsoluteRow bool ;SheetName string ;};

// ParseRangeReference splits a range reference of the form "A1:B5" into its
// components.
func ParseRangeReference (s string )(_cd ,_cc CellReference ,_aed error ){_ecb :="";_daf :=_be .Split (s ,"\u0021");if len (_daf )==2{_ecb =_daf [0];s =_daf [1];};_ad :=_be .Split (s ,"\u003a");if len (_ad )!=2{return CellReference {},CellReference {},_bg .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006eg\u0065\u0020\u0066\u006frm\u0061\u0074");};if _ecb !=""{_ad [0]=_ecb +"\u0021"+_ad [0];_ad [1]=_ecb +"\u0021"+_ad [1];};_bf ,_aed :=ParseCellReference (_ad [0]);if _aed !=nil {return CellReference {},CellReference {},_aed ;};_b ,_aed :=ParseCellReference (_ad [1]);if _aed !=nil {return CellReference {},CellReference {},_aed ;};return _bf ,_b ,nil ;};

// IndexToColumn maps a column number to a column name (e.g. 0 = A, 1 = B, 26 = AA)
func IndexToColumn (col uint32 )string {var _edc [64+1]byte ;_fc :=len (_edc );_fca :=col ;const _f =26;for _fca >=_f {_fc --;_ega :=_fca /_f ;_edc [_fc ]=byte ('A'+uint (_fca -_ega *_f ));_fca =_ega -1;};_fc --;_edc [_fc ]=byte ('A'+uint (_fca ));return string (_edc [_fc :]);};

// ParseCellReference parses a cell reference of the form 'A10' and splits it
// into column/row segments.
func ParseCellReference (s string )(CellReference ,error ){s =_be .TrimSpace (s );if len (s )< 2{return CellReference {},_bg .New ("\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066e\u0072\u0065\u006ece\u0020\u006d\u0075\u0073\u0074\u0020h\u0061\u0076\u0065\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0074\u0077o\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0073");};_eb :=CellReference {};_eg :=_be .Split (s ,"\u0021");if len (_eg )==2{_eb .SheetName =_eg [0];s =_eg [1];};if s [0]=='$'{_eb .AbsoluteColumn =true ;s =s [1:];};_eea :=-1;_da :for _ea :=0;_ea < len (s );_ea ++{switch {case s [_ea ]>='0'&&s [_ea ]<='9'||s [_ea ]=='$':_eea =_ea ;break _da ;};};switch _eea {case 0:return CellReference {},_ce .Errorf ("\u006e\u006f\u0020\u006cet\u0074\u0065\u0072\u0020\u0070\u0072\u0065\u0066\u0069\u0078\u0020\u0069\u006e\u0020%\u0073",s );case -1:return CellReference {},_ce .Errorf ("\u006eo\u0020d\u0069\u0067\u0069\u0074\u0073\u0020\u0069\u006e\u0020\u0025\u0073",s );};_eb .Column =s [0:_eea ];if s [_eea ]=='$'{_eb .AbsoluteRow =true ;_eea ++;};_eb .ColumnIdx =ColumnToIndex (_eb .Column );_ebee ,_e :=_eed .ParseUint (s [_eea :],10,32);if _e !=nil {return CellReference {},_ce .Errorf ("e\u0072\u0072\u006f\u0072 p\u0061r\u0073\u0069\u006e\u0067\u0020r\u006f\u0077\u003a\u0020\u0025\u0073",_e );};_eb .RowIdx =uint32 (_ebee );return _eb ,nil ;};

// ParseColumnRangeReference splits a range reference of the form "A:B" into its
// components.
func ParseColumnRangeReference (s string )(_ab ,_cg ColumnReference ,_g error ){_d :="";_abc :=_be .Split (s ,"\u0021");if len (_abc )==2{_d =_abc [0];s =_abc [1];};_c :=_be .Split (s ,"\u003a");if len (_c )!=2{return ColumnReference {},ColumnReference {},_bg .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006eg\u0065\u0020\u0066\u006frm\u0061\u0074");};if _d !=""{_c [0]=_d +"\u0021"+_c [0];_c [1]=_d +"\u0021"+_c [1];};_gd ,_g :=ParseColumnReference (_c [0]);if _g !=nil {return ColumnReference {},ColumnReference {},_g ;};_bc ,_g :=ParseColumnReference (_c [1]);if _g !=nil {return ColumnReference {},ColumnReference {},_g ;};return _gd ,_bc ,nil ;};

// String returns a string representation of ColumnReference.
func (_ffb ColumnReference )String ()string {_aa :=make ([]byte ,0,4);if _ffb .AbsoluteColumn {_aa =append (_aa ,'$');};_aa =append (_aa ,_ffb .Column ...);return string (_aa );};

// ColumnReference is a parsed reference to a column.  Input is of the form 'A',
// '$C', etc.
type ColumnReference struct{ColumnIdx uint32 ;Column string ;AbsoluteColumn bool ;SheetName string ;};

// String returns a string representation of CellReference.
func (_cef CellReference )String ()string {_abe :=make ([]byte ,0,4);if _cef .AbsoluteColumn {_abe =append (_abe ,'$');};_abe =append (_abe ,_cef .Column ...);if _cef .AbsoluteRow {_abe =append (_abe ,'$');};_abe =_eed .AppendInt (_abe ,int64 (_cef .RowIdx ),10);return string (_abe );};

// Update updates reference to point one of the neighboring cells with respect to the update type after removing a row/column.
func (_a *CellReference )Update (updateType _eae .UpdateAction )*CellReference {switch updateType {case _eae .UpdateActionRemoveColumn :_ec :=_a ;_ec .ColumnIdx =_a .ColumnIdx -1;_ec .Column =IndexToColumn (_ec .ColumnIdx );return _ec ;default:return _a ;};};

// Update updates reference to point one of the neighboring columns with respect to the update type after removing a row/column.
func (_cee *ColumnReference )Update (updateType _eae .UpdateAction )*ColumnReference {switch updateType {case _eae .UpdateActionRemoveColumn :_cb :=_cee ;_cb .ColumnIdx =_cee .ColumnIdx -1;_cb .Column =IndexToColumn (_cb .ColumnIdx );return _cb ;default:return _cee ;};};