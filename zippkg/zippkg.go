//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_afae "archive/zip";_gef "bytes";_ddg "encoding/xml";_fbd "fmt";_ede "github.com/unidoc/unioffice";_ag "github.com/unidoc/unioffice/algo";_ea "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_bff "io";_ef "io/ioutil";_age "os";_be "path";_ddf "sort";_ged "strings";_ga "time";);

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_cac :=_ged .Split (path ,"\u002f");_bcb :=_ged .Join (_cac [0:len (_cac )-1],"\u002f");_d :=_cac [len (_cac )-1];_bcb +="\u002f_\u0072\u0065\u006c\u0073\u002f";_d +="\u002e\u0072\u0065l\u0073";return _bcb +_d ;};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_afae .File ,path string )(string ,error ){_ed ,_ece :=_ef .TempFile (path ,"\u007a\u007a");if _ece !=nil {return "",_ece ;};defer _ed .Close ();_acf ,_ece :=f .Open ();if _ece !=nil {return "",_ece ;};defer _acf .Close ();_ ,_ece =_bff .Copy (_ed ,_acf );if _ece !=nil {return "",_ece ;};return _ed .Name (),nil ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_fa *DecodeMap )Decode (files []*_afae .File )error {_eg :=1;for _eg > 0{for len (_fa ._beb )> 0{_b :=_fa ._beb [len (_fa ._beb )-1];_fa ._beb =_fa ._beb [0:len (_fa ._beb )-1];_cab :=_b .Ifc .(*_ea .Relationships );for _ ,_egd :=range _cab .Relationship {_faf ,_ :=_fa ._bcd [_cab ];_fa ._ac (_fa ,_faf +_egd .TargetAttr ,_egd .TypeAttr ,files ,_egd ,_b );};};for _g ,_bbe :=range files {if _bbe ==nil {continue ;};if _cacc ,_cb :=_fa ._bbc [_bbe .Name ];_cb {delete (_fa ._bbc ,_bbe .Name );if _aff :=Decode (_bbe ,_cacc .Ifc );_aff !=nil {return _aff ;};files [_g ]=nil ;if _fe ,_fb :=_cacc .Ifc .(*_ea .Relationships );_fb {_fa ._beb =append (_fa ._beb ,_cacc );_adf ,_ :=_be .Split (_be .Clean (_bbe .Name +"\u002f\u002e\u002e\u002f"));_fa ._bcd [_fe ]=_adf ;_eg ++;};};};_eg --;};return nil ;};func (_fdd *DecodeMap )RecordIndex (path string ,idx int ){_fdd ._ddc [path ]=idx };var _e =[]byte {'\r','\n'};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_afae .File ,dest interface{})error {_fdg ,_fc :=f .Open ();if _fc !=nil {return _fbd .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_fc );};defer _fdg .Close ();_gcd :=_ddg .NewDecoder (_fdg );if _bf :=_gcd .Decode (dest );_bf !=nil {return _fbd .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_bf );};if _bea ,_ae :=dest .(*_ea .Relationships );_ae {for _dg ,_aa :=range _bea .Relationship {switch _aa .TypeAttr {case _ede .OfficeDocumentTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .OfficeDocumentType ;case _ede .StylesTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .StylesType ;case _ede .ThemeTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .ThemeType ;case _ede .SettingsTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .SettingsType ;case _ede .ImageTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .ImageType ;case _ede .CommentsTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .CommentsType ;case _ede .ThumbnailTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .ThumbnailType ;case _ede .DrawingTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .DrawingType ;case _ede .ChartTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .ChartType ;case _ede .ExtendedPropertiesTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .ExtendedPropertiesType ;case _ede .CustomXMLTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .CustomXMLType ;case _ede .WorksheetTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .WorksheetType ;case _ede .SharedStringsTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .SharedStringsType ;case _ede .TableTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .TableType ;case _ede .HeaderTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .HeaderType ;case _ede .FooterTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .FooterType ;case _ede .NumberingTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .NumberingType ;case _ede .FontTableTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .FontTableType ;case _ede .WebSettingsTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .WebSettingsType ;case _ede .FootNotesTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .FootNotesType ;case _ede .EndNotesTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .EndNotesType ;case _ede .SlideTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .SlideType ;case _ede .VMLDrawingTypeStrict :_bea .Relationship [_dg ].TypeAttr =_ede .VMLDrawingType ;};};_ddf .Slice (_bea .Relationship ,func (_afe ,_bb int )bool {_ab :=_bea .Relationship [_afe ];_ff :=_bea .Relationship [_bb ];return _ag .NaturalLess (_ab .IdAttr ,_ff .IdAttr );});};return nil ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_afae .Writer ,filename string ,v interface{})error {_gc :=&_afae .FileHeader {};_gc .Method =_afae .Deflate ;_gc .Name =filename ;_gc .SetModTime (_ga .Now ());_feb ,_gb :=z .CreateHeader (_gc );if _gb !=nil {return _fbd .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_gb );};_ ,_gb =_feb .Write ([]byte (XMLHeader ));if _gb !=nil {return _fbd .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_gb );};if _gb =_ddg .NewEncoder (SelfClosingWriter {_feb }).Encode (v );_gb !=nil {return _fbd .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_gb );};_ ,_gb =_feb .Write (_e );return _gb ;};func (_bc SelfClosingWriter )Write (b []byte )(int ,error ){_ega :=0;_bd :=0;for _afa :=0;_afa < len (b )-2;_afa ++{if b [_afa ]=='>'&&b [_afa +1]=='<'&&b [_afa +2]=='/'{_fd :=[]byte {};_bec :=_afa ;for _bca :=_afa ;_bca >=0;_bca --{if b [_bca ]==' '{_bec =_bca ;}else if b [_bca ]=='<'{_fd =b [_bca +1:_bec ];break ;};};_deg :=[]byte {};for _a :=_afa +3;_a < len (b );_a ++{if b [_a ]=='>'{_deg =b [_afa +3:_a ];break ;};};if !_gef .Equal (_fd ,_deg ){continue ;};_dd ,_c :=_bc .W .Write (b [_ega :_afa ]);if _c !=nil {return _bd +_dd ,_c ;};_bd +=_dd ;_ ,_c =_bc .W .Write (_bde );if _c !=nil {return _bd ,_c ;};_bd +=3;for _cea :=_afa +2;_cea < len (b )&&b [_cea ]!='>';_cea ++{_bd ++;_ega =_cea +2;_afa =_ega ;};};};_beg ,_ca :=_bc .W .Write (b [_ega :]);return _beg +_bd ,_ca ;};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};

// AddFileFromDisk reads a file from disk and adds it at a given path to a zip file.
func AddFileFromDisk (z *_afae .Writer ,zipPath ,diskPath string )error {_cec ,_cbf :=z .Create (zipPath );if _cbf !=nil {return _fbd .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_cbf );};_eag ,_cbf :=_age .Open (diskPath );if _cbf !=nil {return _fbd .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",diskPath ,_cbf );};_ ,_cbf =_bff .Copy (_cec ,_eag );return _cbf ;};func MarshalXMLByType (z *_afae .Writer ,dt _ede .DocType ,typ string ,v interface{})error {_gce :=_ede .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_gce ,v );};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_bbc map[string ]Target ;_bcd map[*_ea .Relationships ]string ;_beb []Target ;_ac OnNewRelationshipFunc ;_dbe map[string ]struct{};_ddc map[string ]int ;};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_dfg *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _dfg ._bbc ==nil {_dfg ._bbc =make (map[string ]Target );_dfg ._bcd =make (map[*_ea .Relationships ]string );_dfg ._dbe =make (map[string ]struct{});_dfg ._ddc =make (map[string ]int );};_aag :=_be .Clean (filePath );if _ ,_abf :=_dfg ._dbe [_aag ];_abf {return false ;};_dfg ._dbe [_aag ]=struct{}{};_dfg ._bbc [_aag ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};func MarshalXMLByTypeIndex (z *_afae .Writer ,dt _ede .DocType ,typ string ,idx int ,v interface{})error {_egf :=_ede .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_egf ,v );};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_ggf *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_ggf ._ac =fn };var _bde =[]byte {'/','>'};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where gooxml will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_cc *DecodeMap ,_af ,_ad string ,_ce []*_afae .File ,_bae *_ea .Relationship ,_afd Target )error ;

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_afae .Writer ,zipPath string ,data []byte )error {_df ,_de :=z .Create (zipPath );if _de !=nil {return _fbd .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_de );};_ ,_de =_bff .Copy (_df ,_gef .NewReader (data ));return _de ;};func (_f *DecodeMap )IndexFor (path string )int {return _f ._ddc [path ]};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _bff .Writer ;};